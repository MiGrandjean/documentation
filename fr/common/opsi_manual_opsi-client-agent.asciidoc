////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; Until we found a better license:
; All rights reserved.
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Date:      05.05.2011
:Revision:  4.0.1
:toclevels: 6


include::../common/opsi_terms.asciidoc[]

[[opsi-manual-clientagent]]
== opsi-client-agent

[[opsi-manual-clientagent-overview]]
=== Overview

To make Software distribution manageable for the system administrator, a client computer has to notice that new software-packets or updates are available and install them without user interaction. It is important to make user-interaction completely obsolete as the installation can run unattended this way and a user cannot stop the installation during the installation process.

These requirements are implemented in opsi by the '{opsi-client-agent}': 

On the client side the service 'opsiclientd' usally at boot time before the user logs in examines whether an update has to be installed for this client. 

If there are software to be installed on the client, the script processing program 'opsi-winst' is being started to do the installation job. The server provides all the installation scripts and software files on a file share. At this time the user has no chance to interfere with the installation process. 

As an additional option the module 'loginblocker' can be installed to prevent a user login before the end of the installation process is reached.

Before a software can be installed with the 'opsi-winst' program, they have to be prepared as '{opsi-product-package}'. For details see Chapter 'Integration of new software packets into the opsi software deployment' at the 'getting started' manual.

[[opsi-manual-clientagent-directories]]
=== Directories of the opsi-client-agent

The '{opsi-client-agent}' is installed at `%ProgramFiles%\opsi.org\opsi-client-agent`.


This directory contains all programs of the '{opsi-client-agent}' like e.g. the '{opsiclientd}', the '{opsiclientd-notifier}' the '{opsi-winst}' and some needed libraries. Also we will find here the configuration files and graphical templates (skins) of the mentioned programs.

The directory `%ProgramFiles%\opsi.org\opsi-client-agent` is protected against manipulation by users without administartor priviliges. +
The directory `%ProgramFiles%\opsi.org\opsi-client-agent\opsiclientd` contains the configuration file of the '{opsiclientd}' and you need administrator privilges to read it.

There is a other directory `c:\opsi.org`.

This directory is used (at the moment) for caching installation files and data (see WAN-Extension). In future it will have some more function like containig log files. +
You need administrator privilges to read the directory `c:\opsi.org`.

The log files of the '{opsi-client-agent}' you will find at `c:\tmp`.

[[opsi-manual-clientagent-service]]
=== The service: opsiclientd

The '{opsiclientd}' is the core of the '{opsi-client-agent}'. The '{opsiclientd}' starts at boot time and runs with administrative privileges.

The important features are:

* Event based control: +
The activity of the opsi client agent (opsiclientd) may be triggered by different events in the client system. According to this fact the start of the installation is not fixed at the system start up any more.

* Control via web service: +
This interface is used for 'push' installations and for maintenance purpose as well.

* Remote configuration: +
The configuration data for the clients may be changed (globally or client specific) at the server by editing the 'Host parameter'.

The '{opsi-client-agent}' consists of multiple components :

* '{opsiclientd}': the central service
* '{opsiclientd-notifier}': information and communication window
* '{opsi-login-blocker}': block the login until the installation has finished

[[opsi-manual-clientagent-installation]]
==== Installation

In case of automatic OS-Installation with opsi (not image based), the '{opsi-client-agent}' will be installed automatically.

You may set the action request 'unstall' to uninstall the '{opsi-client-agent}'.

For a subsequent installation on a existing Windows system or for repair purposes see at the 'getting started' manual.
////
<<opsi-manual-clientagent-subsequent-installation>>.
////

[[opsi-manual-clientagent-opsiclientd]]
==== opsiclientd

Core component of the '{opsi-client-agent}' is the service '{opsiclientd}'. This service starts at the boot time.

The '{opsiclientd}' has the following tasks:

* while the system is booting and the '{opsiclientd}' is waiting for the GUI to come up the 'block_login_notifier' is started wich shows a padlock at the righit upper corner of the screen.

* Getting active if the configuration event takes place. If it geat active the '{opsiclientd}' contacts the opsi server via web service (JSON-RPC) and ask for configuration data and required actions. +
The default event is 'gui_startup' which will fire at boot time and before login.

* Creates a named pipe which is used by the '{opsi-login-blocker}' to ask via JSON-RPC the '{opsiclientd}' when to unblock the login.

* Starting the '{opsiclientd-notifier}' as thread for information and interaction with the user.

* If needed, it connects to the '{opsi-depot}', update and start of the '{opsi-winst}' and start this program to process the '{action-requests}' (installations).

[[opsi-manual-clientagent-opsiclientd-notifier]]
==== opsiclientd notifier

The '{opsiclientd-notifier}' implements the interaction with the user. They displays status messages and may give the possibility to interact with the process.

There are different situations where the '{opsiclientd-notifier}' will become active in different ways:

blocking notifier::
Indicates that the '{opsi-login-blocker}' is blocking

.opsiclientd blocklogin notifier
image::../images/opsiclientd-blocklogin-notifier.png["opsiclientd blocklogin notifier",width=80]

event notifier::
Give information to a started event.

.opsiclientd event notifier
image::../images/opsiclientd-event-notifier.png["opsiclientd event notifier",width=150]

action notifier::
Shows state of the event processing

.opsiclientd action notifier
image::../images/opsiclientd-action-notifier.png["opsiclientd action notifier",width=150]

shutdown notifier::
Gives information about a requested reboot / shutdown 
(if +shutdown_warning_time+ > 0)

.opsiclientd shutdown notifier
image::../images/opsiclientd-shutdown-notifier.png["opsiclientd shutdown notifier",width=150]

CAUTION: The names and functionality of the notifier has changed from opsi 4.0 to opsi 4.0.1. +
The opsi 4.0 event notifier doesn't exist's anymore. +
The opsi 4.0.1 event notifier is equal to the opsi 4.0 action notifier. +
The opsi 4.0.1 action notifier has nearly the same functionality like the opsi 4.0 event notifier, but it will only be activated if there is a '{action-request}'.


[[opsi-manual-clientagent-loginblocker]]
==== {opsi-login-blocker}
The '{opsi-login-blocker}' for NT5 Win2K/WinXP is implemented as 'GINA'  ('opsigina.dll').
This 'GINA' waits until the opsiclientd tells, that all '{product-actions}' are finished or if the opsiclientd is not reachable, until the connection timeout to the opsiclientd is reached (normally 120 seconds). Then the complete control is forwarded to the next 'GINA' which is normally the `msgina.dll`.

The '{opsi-login-blocker}' for NT6 (Vista/Win7) is implemented as 'credential provider filter' ('OpsiLoginBlocker.dll').
This 'credential provider filter' blocks all 'credential providers' until the opsiclientd tells, that all '{product-actions}' are finished or if the opsiclientd is not reachable, until the connection timeout to the opsiclientd is reached (normally 120 seconds).

[[opsi-manual-clientagent-event-flow]]
==== Processing sequence

How the opsiclientd works may be configured in many details. To understand these configuration possibilities, it is necessary to understand the processing sequence. Here a overview of the work flow of a 'standard event' like the 'event_gui_startup'.

.simplified work flow of a 'standard event'
image::../images/eventflowchsrt.png["simplified work flow of a 'standard event'",height=400]

The most important parameters have the following relations:

. 1. If a event fires, the +event_notifier_command+ will be started. +
Now the opsiclientd try to reach the '{opsi-configserver}' 2. using the url address. +
If after +user_cancelable_after+ seconds there is still no connection established, so the '{opsiclientd-notifier}' will enable a 'Abort' button. If no connection could be established in +connection_timeout+ seconds, the 'opsiclientd' connection process will be aborted and the events ends with a error message. To avoid a user from aborting, set +user_cancelable_after+ = +connection_timeout+ .

TIP: If there is a error while connecting to the '{opsi-configserver}' the log of this problem can not be send to the server. But you may find the log at the file `opsiclientd.log` in the log directory (`c:\tmp`) at the client..

. After a successful connection to the '{opsi-configserver}', the 'opsiclientd' check if there are 'action requests' for this client. If there are 'action requests' and the +action_warning_time+ > 0, the +action_notifier_command+ will be executed. +
This is noramally '{opsiclientd-notifier}' which shows now the list of 'action requests' for this client for +action_warning_time+ seconds. +
Is the +action_warning_time+ = 0 (default) the +action_notifier_command+ will not be executed. +
You may allow the user to suspend the process at this time by setting +action_user_cancelable+ >= 0. The user may suspend the actions eactly +action_user_cancelable+ times. After +action_user_cancelable+ aborts in sequence or if +action_user_cancelable+ = 0 the user gets no possibility to suspend the actions. +
In every case ther will be a button which allows the user to start the installations without waiting until the conut down of +action_warning_time+ seconds has finished. The by the '{opsiclientd-notifier}' displayed messages may be configurted by the options +action_message+ or +action_message[lang]+ . This messages may contain the placeholders +%action_user_cancelable%+ (total number of allowed suspendings) and +%action_cancel_counter%+ (number of suspends already triggred by the user). +
If the actions are not suspenden by the user, the +action_cancel_counter+ will be reset and the '{opsi-winst}' will be executed to process the 'action requests'.

. If the '{opsi-winst}' terminates with a reboot or shutdown request so the +shutdown_notifier_command+ will be executed if +shutdown_warning_time+ > 0. +
The now starting +shutdown_notifier_command+ show for +shutdown_warning_time+ seconds a message that the client will be rebooted. If +shutdown_user_cancelable+ > 0 the user may suspend the reboot +shutdown_user_cancelable+ times in sequence. If the user suspends the reboot, the +shutdown_notifier_command+ will be restarted after +shutdown_warning_repetition_time+. The +shutdown_notifier_command+ shows a message which may be configured by +shutdown_warning_message+ or +shutdown_warning_message[lang]+. This message may contain the placeholders  +%shutdown_user_cancelable%+ (total number of allowed suspendings) and +%shutdown_cancel_counter%+ number of suspends already triggred by the user). +
If the client is rebooted (by the user or the 'opsi-client-agent') the +%shutdown_cancel_counter%+ will be reset.

TIP: The sequence of event processing and user actions is visulized in a timeline graphic at the info page of the '{opsiclientd}'. 

////
(<<opsi-manual-clientagent-infopage>>).
////

.Complete work flow of a event
image::../images/opsiclientd-event-processing-flow.png["Complete work flow of a event",height=650]

[[opsi-manual-clientagent-configuration]]
==== Configuration

[[opsi-manual-clientagent-configuration-events]]
===== Configuration off different events

To meet the requirements of the various different situations in which the '{opsi-client-agent}' will become active a slightly complex configuration is needed. To reduce the complexity, the configuration file uses something like inheritance. +
In the '{opsiclientd}' configuration section headers like +[event_<config-id>]+ introduce a new event configuration. A event configuration may be disabled by setting the opstion +active = false+.

There are different types of event configurations (+type+).

* There are 'event configuration templates' (type = template) +
Event configurations may inherit configurations frm a other event. Is the opstion +super+ points t a other event, this events inherits all parameters from this event (beside the parameter +active+). These inherited parameters may now be overridden by parameters in the actual event section. So a event section need only these parameters which are different to the +super+ event. +
Setting a event to +active = false+ does not change anything in the inheritance process.

* The other event types are: +
  - +gui startup+ +
A +gui startup+ event starts while booting the client and loading the 'graphical user interface' (GUI). It is the most used event and set to active in the default configuration.

  - +custom+ +
Event configurations of the type +custom+ are fired by +wql+ event. This +wql+ event is defined by the +wql+ statement in the event configuration. If the +wql+ statement is empty the event will never be fired by it self.

  - +user login+ +
will be fired at the login of a user

  - +timer+ +
will be fired all +interval+ seconds

  - +sync completed+ +
will be fired if the synchronisation of configurations (+sync_config_from_server+) or products (+cache_products+) is completed.

  - +sw on demand+ +
will be fired by the user choosing 'Start actions now' in the 'software-on-demand' web page of the opsiclientd. Will never be fired if 'software-on-Demand' is not used. (Do not puzzle with the push installation via 'on_demand').

* There are 'Preconditions' +
'Preconditions' define special system states (e.g. a user is loged in).
In the '{opsiclientd}' configuration a section haeder of the form +[precondition_<precondition-id>]+ starts the declaration of a 'Precondition'.
A 'Precondition' is true, if all declared options are true.
Eine not declared (but possible) option is assumed as true. +
Possible options for 'Preconditions' are:
  - +user_logged_in+: is true if a user is loged in to the system.
  - +config_cached+: is true if the caching of configuration data is completed (see: +sync_config_from_server+).
  - +products_cached+: is true if the caching of product files is completed (see: +cache_products+).

* A 'Precondition' can be assigned to a event configuration. +
This can be done by giving the 'precondition' in curly brackets at the end of the event configuration section hedaer (e.g. +[event_on_demand{user_logged_in}]+). +
If there is a 'Precondition' in a event configuration header, there must be a configuration for this event without any 'precondition'.
Is there for example a event configuration +event_on_demand{user_logged_in}+ there have to be also a event configuration +event_on_demand+ !
In this case the event configuration with the precondition inherits the parameters from the event configuration without 'precondition'. +
If the event is fired, at first ist is checked which 'preconditions' are true. If there is no 'prcondition' true, the configuration without 'precondition' is used.
Is one 'precondition' true, the configuration is used which is bound to this 'precondition'.
If there are more then one 'preconditions' are true, the event configuration is used which is bound to a 'precondition' declaration which decribes the situation most excatly (has the most opstions).


Ein Beispiel zur Erläuterung: +
Im Rahmen einer Installation kann es notwendig sein den Rechner zu rebooten.
Ist gerade ein Benutzer am System angemeldet, sollte dieser über den anstehenden Reboot informiert werden.
Hierbei ist eine angemessene Wartezeit vor dem Ausführen des Reboots angebracht.
Zusätzlich kann es sinnvoll sein, dem Benutzer die Entscheidung zu überlassen, ob der Reboot besser zu einem späteren Zeitpunkt ausgeführt werden soll. +
Ist zum Zeitpunkt des benötigten Reboots jedoch kein Benutzer angemeldet, ist es sinnvoll, den Reboot ohne weitere Wartezeit sofort durchzuführen. +
Dieses Problem wird am Beispiel von +event_on_demand+ wie folgt konfiguriert:

* Es wird eine 'Precondition' +user_logged_in+ definiert, die erfüllt ist, wenn ein Benutzer am System angemeldet ist (+user_logged_in = true+).
* In der Event-Konfiguration +event_on_demand+ (ohne 'Precondition') wird +shutdown_warning_time = 0+ gesetzt (sofortiger Reboot ohne Meldung).
* In der Event-Konfiguration +event_on_demand{user_logged_in}+ wird +shutdown_warning_time = 300+ gesetzt (300 Sekunden Vorwarnzeit).


[[opsi-manual-clientagent-configuration-file]]
===== Konfiguration über die Konfigurationsdatei

Die Konfigurationsdatei ist: +
`c:\program files\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf`

CAUTION: Diese Konfigurationsdatei ist UTF-8 kodiert. +
Änderungen mit Editoren, die diese Kodierung nicht beherrschen (z.B. notepad.exe), zerstören die Umlaute in dieser Datei.

Die hier festgelegte Konfiguration kann nach erfolgreicher Verbindung zum '{opsi-configserver}' durch die dort festgelegte '{opsi-config-object}' überschrieben werden.
Beispiel `opsiclientd.conf`:
[source,ini]
----
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; =     configuration file for opsiclientd                              =
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     global settings                                                 -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[global]

# Location of the log file.
log_file = c:\\tmp\\opsiclientd.log

# Set the log (verbosity) level
# (0 <= log level <= 9)
# 0: nothing, 1: essential, 2: critical, 3: errors, 4: warnings, 5: notices
# 6: infos, 7: debug messages, 8: more debug messages, 9: passwords
log_level = 4

# Client id.
host_id = 

# Opsi host key.
opsi_host_key = 

# Verify opsi server certs
verify_server_cert = false

# On every daemon startup the user login gets blocked
# If the gui starts up and no events are being processed the login gets unblocked
# If no gui startup is noticed after <wait_for_gui_timeout> the login gets unblocked
# Set to 0 to wait forever
wait_for_gui_timeout = 120

# Application to run while blocking login
block_login_notifier = %global.base_dir%\\notifier.exe -s notifier\\block_login.ini

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     config service settings                                         -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[config_service]
# Service url.
# http(s)://<opsi config server address>:<port>/rpc
url = https://opsi.uib.local:4447/rpc

# Conection timeout.
connection_timeout = 30

# The time in seconds after which the user can cancel the connection establishment
user_cancelable_after = 30

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     depot server settings                                           -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[depot_server]

# Depot server id
depot_id =

# Depot url.
# smb://<depot address>/<share name>/<path to products>
url =

# Local depot drive
drive =

# Username that is used for network connection [domain\]<username>
username = pcpatch

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     cache service settings                                          -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[cache_service]
# Maximum product cache size in bytes
product_cache_max_size = 5000000000

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     control server settings                                         -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[control_server]

# The network interfaces to bind to.
# This must be the IP address of an network interface.
# Use 0.0.0.0 to listen to all interfaces
interface = 0.0.0.0

# The port where opsiclientd will listen for HTTPS rpc requests.
port = 4441

# The location of the server certificate.
ssl_server_cert_file = %global.base_dir%\\opsiclientd\\opsiclientd.pem

# The location of the server private key
ssl_server_key_file = %global.base_dir%\\opsiclientd\\opsiclientd.pem

# The location of the static files
static_dir = %global.base_dir%\\opsiclientd\\static_html

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     notification server settings                                    -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[notification_server]

# The network interfaces to bind to.
# This must be the IP address of an network interface.
# Use 0.0.0.0 to listen to all interfaces
interface = 127.0.0.1

# The first port where opsiclientd will listen for notification clients.
start_port = 44000

# Port for popup notification server
popup_port = 45000

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     opsiclientd notifier settings                                   -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[opsiclientd_notifier]

# Notifier application command
command = %global.base_dir%\\notifier.exe -p %port% -i %id%

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     opsiclientd rpc tool settings                                   -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[opsiclientd_rpc]

# RPC tool command
command = %global.base_dir%\\opsiclientd_rpc.exe "%global.host_id%" "%global.opsi_host_key%" "%control_server.port%"

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     action processor settings                                       -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[action_processor]
# Locations of action processor
local_dir = %global.base_dir%\\opsi-winst
remote_dir = \\install\\opsi-winst\\files\\opsi-winst
filename = winst32.exe
# Action processor command
command = "%action_processor.local_dir%\\%action_processor.filename%" /opsiservice "%service_url%" /clientid %global.host_id% /username %global.host_id% /password %global.opsi_host_key%

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     events                                                          -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[event_default]
; === Event configuration
# Type of the event (string)
type = template
# Interval for timer events in seconds (int)
interval = -1
# Maximum number of event repetitions after which the event will be deactivated (int, -1 = forever)
max_repetitions = -1
# Time in seconds to wait before event becomes active (int, 0 to disable delay)
activation_delay = 0
# Time in seconds to wait before an event will be fired (int, 0 to disable delay)
notification_delay = 0
# Event notifier command (string)
event_notifier_command = %opsiclientd_notifier.command% -s notifier\\event.ini
# The desktop on which the event notifier will be shown on (current/default/winlogon)
event_notifier_desktop = current
# Block login while event is been executed (bool)
block_login = false
# Lock workstation on event occurrence (bool)
lock_workstation = false
# Logoff the current logged in user on event occurrence (bool)
logoff_current_user = false
# Get config settings from service (bool)
get_config_from_service = true
# Store config settings in config file (bool)
update_config_file = true
# Transmit log file to opsi service after the event processing has finished (bool)
write_log_to_service = true
# Shutdown machine after action processing has finished (bool)
shutdown = false
# Reboot machine after action processing has finished (bool)
reboot = false

; === Sync/cache settings
# Sync configuration from local config cache to server (bool)
sync_config_to_server = false
# Sync configuration from server to local config cache (bool)
sync_config_from_server = false
# Sync configuration from local config cache to server after action processing (bool)
post_sync_config_to_server = false
# Sync configuration from server to local config cache after action processing (bool)
post_sync_config_from_server = false
# Work on local config cache
use_cached_config = false
# Cache products for which actions should be executed in local depot cache (bool)
cache_products = false
# Maximum transfer rate when caching products in byte/s (int, 0 = no limit)
cache_max_bandwidth = 0
# Dynamically adapt bandwith to other network traffic (bool)
cache_dynamic_bandwidth = false
# Work on local depot cache
use_cached_products = false

; === Action notification (if product actions should be processed)
# Time in seconds for how long the action notification is shown (int, 0 to disable)
action_warning_time = 0
# Action notifier command (string)
action_notifier_command = %opsiclientd_notifier.command% -s notifier\\action.ini
# The desktop on which the action notifier will be shown on (current/default/winlogon)
action_notifier_desktop = current
# Message shown in the action notifier window (string)
action_message = Starting to process product actions. You are allowed to cancel this event a total of %action_user_cancelable% time(s). The event was already canceled %state.action_processing_cancel_counter% time(s).
# German translation (string)
action_message[de] = Starte die Bearbeitung von Produkt-Aktionen. Sie können diese Aktion insgesamt %action_user_cancelable% mal abbrechen. Die Aktion wurde bereits %state.action_processing_cancel_counter% mal abgebrochen.
# Number of times the user is allowed to cancel the execution of actions (int)
action_user_cancelable = 0

; === Action processing
# Should action be processed by action processor (bool)
process_actions = true
# Type of action processing (default/login)
action_type = default
# Update the action processor from server before starting it (bool)
update_action_processor = true
# Command which should be executed before start of action processor
pre_action_processor_command =
# Action processor command (string)
action_processor_command = %action_processor.command%
# The desktop on which the action processor command will be started on (current/default/winlogon)
action_processor_desktop = current
# Action processor timout in seconds (int)
action_processor_timeout = 10800
# Command which should be executed before after action processor has ended
post_action_processor_command =

; === Shutdown notification (if machine should be shut down or rebooted)
# Process shutdown requests from action processor
process_shutdown_requests = true
# Time in seconds for how long the shutdown notification is shown (int, 0 to disable)
shutdown_warning_time = 0
# Shutdown notifier command (string)
shutdown_notifier_command = %opsiclientd_notifier.command% -s notifier\\shutdown.ini
# The desktop on which the action notifier will be shown on (current/default/winlogon)
shutdown_notifier_desktop = current
# Message shown in the shutdown notifier window (string)
shutdown_warning_message = A reboot is required to complete software installation tasks. You are allowed to delay this reboot a total of %shutdown_user_cancelable% time(s). The reboot was already delayed %state.shutdown_cancel_counter% time(s).
# German translation (string)
shutdown_warning_message[de] = Ein Neustart wird benötigt um die Software-Installationen abzuschliessen. Sie können diesen Neustart insgesamt %shutdown_user_cancelable% mal verschieben. Der Neustart wurde bereits %state.shutdown_cancel_counter% mal verschoben.
# Number of times the user is allowed to cancel the shutdown (int)
shutdown_user_cancelable = 0
# Time in seconds after the shutdown notification will be shown again after the user has canceled the shutdown (int)
shutdown_warning_repetition_time = 3600

[event_gui_startup]
super = default
type = gui startup
name = gui_startup
block_login = true

[event_gui_startup{user_logged_in}]
name = gui_startup
shutdown_warning_time = 300
block_login = false

[event_gui_startup{cache_ready}]
use_cached_config = true
use_cached_products = true
action_user_cancelable = 3
action_warning_time = 60

[event_on_demand]
super = default
type = custom
name = on_demand

[event_on_demand{user_logged_in}]
name = on_demand
shutdown_warning_time = 300

[event_software_on_demand]
super = default
type = sw on demand

[event_sync]
super = default
type = template
process_actions = false
event_notifier_command = 
sync_config_to_server = true
sync_config_from_server = true
cache_products = true
cache_dynamic_bandwidth = true

[event_timer]
super = sync
type = timer
active = false
interval = 300

[event_net_connection]
super = sync
type = custom
active = false
wql = SELECT * FROM __InstanceModificationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_NetworkAdapter' AND TargetInstance.NetConnectionStatus = 2

[event_sync_completed]
super = default
type = sync completed
event_notifier_command = 
process_actions = false
get_config_from_service = false
write_log_to_service = false

[event_sync_completed{cache_ready_user_logged_in}]
reboot = true
shutdown_user_cancelable = 10
shutdown_warning_time = 300

[event_sync_completed{cache_ready}]
reboot = true

[event_user_login]
super = default
type = user login
action_type = login
active = false
message = Starting to process user login actions.
message[de] = Beginne mit der Verarbeitung der Benutzer-Anmeldungs-Aktionen.
block_login = false
process_shutdown_requests = false
get_config_from_service = false
update_config_file = false
write_log_to_service = false
update_action_processor = false
action_notifier_command = %opsiclientd_notifier.command% -s notifier\\userlogin.ini
action_notifier_desktop = default
action_processor_command = %action_processor.command% /usercontext %event.user%
action_processor_desktop = default
action_processor_timeout = 300

[precondition_user_logged_in]
user_logged_in = true

[precondition_cache_ready]
config_cached = true
products_cached = true

[precondition_cache_ready_user_logged_in]
user_logged_in = true
config_cached = true
products_cached = true
----

[[opsi-manual-clientagent-configuration-webservice]]
===== Konfiguration über den Webservice ({opsi-config-object})

Die Konfiguration kann auch zentral gesteuert werden. Hierzu dienen Einträge in der '{opsi-config-object}' des '{opsi-configserver}s'.

Diese Einträge müssen dem folgenden Muster folgen: +
`opsiclientd.<name der section>.<name der option>`

Ein Beispiel: +
`opsiclientd.event_gui_startup.action_warning_time = 20` +
setzt in der Konfigurationsdatei `opsiclientd.conf` in der Sektion +[global]+ den Wert von +action_warning_time+ auf 20.

Die folgende Abbildung zeigt, wie diese Werte als Defaults für alle Clients über den '{opsi-configed}' gesetzt werden können.

.Serverweite Konfiguration des {opsiclientd} über den {opsi-configed}
image::../images/opsiclientd-configuration-via-configed-serverdefault.png["Abbildung: Serverweite Konfiguration des {opsiclientd} über den {opsi-configed}",width=400]

Hier kann über das Kontextmenü +Property hinzufügen+ ein neuer Wert gesetzt werden.

Um einen {opsi-config-object} zu löschen, verwenden Sie das Werkzeug '{opsi-admin}'.
Beispiel:
[source,prompt]
----
opsi-admin -d method config_delete "opsiclientd.event_gui_startup.action_warning_time"
----

Eine Client-spezifische Änderung über den '{opsi-configed}' führen Sie über den 'Hosts-Parameter' Tab in der Client-Konfiguration aus.
Um Client-spezifische Einträge zu löschen, verwenden Sie das Werkzeug '{opsi-admin}'.
Beispiel:
[source,prompt]
----
@opsi-admin> method configState_delete "opsiclientd.event_gui_startup.action_warning_time" "myclient.uib.local"
----

.Client-spezifische Konfiguration des {opsiclientd} über den {opsi-configed}
image::../images/opsiclientd-configuration-via-configed.png["Abbildung: Client spezifische Konfiguration des {opsiclientd} über den {opsi-configed}",width=400]


[[opsi-manual-clientagent-logging]]
==== Logging

Die Log-Datei des '{opsiclientd}' ist standardmäßig `c:\tmp\opsicliend.log`.

Die Log-Informationen werden auch an den '{opsi-configserver}' übertragen.
Dort liegen sie unter '/var/log/opsi/clientconnect/<ip-bzw.-name-des-clients>.log'.
Sie sind auch im '{opsi-configed}' über Logdateien => Clientconnect einsehbar.

Jede Zeile in der Logdatei folgt dem Muster: +
+[<log level>] [<datum zeit>] [Quelle der Meldung] Meldung   (Quellcode-Datei|Zeilennummer).+

Dabei gibt es die folgenden Log-Level:
....
# Set the log (verbosity) level
# (0 <= log level <= 9)
# 0: nothing, 1: essential, 2: critical, 3: errors, 4: warnings, 5: notices
# 6: infos, 7: debug messages, 8: more debug messages, 9: passwords
....

Beispiel:
[source,opsilog]
----
(...)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed{cache_ready}' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup{cache_ready}' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'on_demand' added to event generator 'on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed{cache_ready_user_logged_in}' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup{user_logged_in}' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'software_on_demand' added to event generator 'software_on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'on_demand{user_logged_in}' added to event generator 'on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Updating config file: 'C:\Program Files (x86)\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf'   (Config.pyo|287)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] No need to write config file 'C:\Program Files (x86)\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf', config file is up to date   (Config.pyo|318)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] No product action requests set   (EventProcessing.pyo|591)
[5] [Mar 22 10:17:49] [ event processing gui_startup  ] Writing log to service   (EventProcessing.pyo|247)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] shutdownRequested: 0   (Windows.pyo|340)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] rebootRequested: 0   (Windows.pyo|326)
[5] [Mar 22 10:17:49] [ opsiclientd                   ] Block login now set to 'False'   (Opsiclientd.pyo|111)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] Terminating block login notifier app (pid 1620)   (Opsiclientd.pyo|148)
[6] [Mar 22 10:17:49] [ event processing gui_startup  ] Stopping notification server   (EventProcessing.pyo|225)
[6] [Mar 22 10:17:51] [ control server                ] client connection lost   (Message.pyo|464)
[6] [Mar 22 10:17:52] [ event processing gui_startup  ] Notification server stopped   (Message.pyo|651)
[5] [Mar 22 10:17:52] [ event processing gui_startup  ] ============= EventProcessingThread for event 'gui_startup' ended =============   (EventProcessing.pyo|1172)
[5] [Mar 22 10:17:52] [ opsiclientd                   ] Done processing event '<ocdlib.Events.GUIStartupEvent object at 0x023CE330>'   (Opsiclientd.pyo|405)
[5] [Mar 22 10:19:41] [ opsiclientd                   ] Session 'HSzMB1wtOiBS6vHl7mh3ro5r6s3TanFu' from ip '127.0.0.1', application 'opsi jsonrpc module version 4.0.1' expired after 120 seconds   (Session.pyo|184)
[6] [Mar 22 10:19:41] [ opsiclientd                   ] Session timer <_Timer(Thread-20, started daemon 2636)> canceled   (Session.pyo|120)
[5] [Mar 22 10:19:41] [ opsiclientd                   ] Session 'HSzMB1wtOiBS6vHl7mh3ro5r6s3TanFu' from ip '127.0.0.1', application 'opsi jsonrpc module version 4.0.1' deleted   (Session.pyo|207)
[6] [Mar 22 10:27:55] [ control pipe                  ] Creating pipe \\.\pipe\opsiclientd   (ControlPipe.pyo|253)
[5] [Mar 22 10:27:55] [ event generator wait_for_gui  ] -----> Executing: getBlockLogin()   (JsonRpc.pyo|123)
[5] [Mar 22 10:27:55] [ opsiclientd                   ] rpc getBlockLogin: blockLogin is 'False'   (ControlPipe.pyo|428)
[6] [Mar 22 10:27:55] [ event generator wait_for_gui  ] Got result   (JsonRpc.pyo|131)
'
----


Die Log-Datei des '{opsi-login-blocker}s' befindet sich unter NT6 (Vista/Win7) als auch unter NT5 (Win2k/WinXP) in `c:\tmp\opsi_loginblocker.log`.

[[opsi-manual-clientagent-infopage]]
==== {opsiclientd} infopage

Da bei den Abläufen im '{opsiclientd}' vielfältige Komponenten zusammenwirken, welche zum Teil gleichzeitig aktiv sind, wird die Logdatei leicht unübersichtlich.

Daher verfügt der '{opsiclientd}' über eine eigene 'infopage' welche die Abläufe auf einer Zeitachse grafisch darstellt.
Diese 'infopage' kann mit dem Browser über die URL https://<adresse-des-clients>:4441/info.html aufgerufen werden.

.Info-Page des {opsiclientd} nach einer Push-Installation mit aktiviertem Produkt-Caching
image::../images/opsiclientd_infopage_event_on_demand.png["Abbildung: Info-Page des {opsiclientd} nach einer Push-Installation mit aktiviertem Produkt-Caching",width=400]

[[opsi-manual-clientagent-control]]
==== Fernsteuerung des {opsi-client-agent}

Der '{opsiclientd}' verfügt über eine Webservice-Schnittstelle.
Diese ermöglicht es, dem {opsi-client-agent} Anweisungen zu übermitteln und Vieles mehr.
Sie lassen sich momentan grob in drei Bereiche aufteilen:

* Nachrichten (Popup) versenden

* 'Push'-Installationen durch auslösen von Events (z.B. 'on_demand')

* Sonstige Wartungsarbeiten

Dies kann auch auf der Kommandozeile mittels Aufrufs einer 'hostControl_*'-Methode über '{opsi-admin}' geschehen.
Bei Verwendung der 'hostControl_*'-Methoden +
`opsi-admin -d method hostControl_xx *hostIds` kann der Parameter +*hostIds+

* entfallen, dann gilt der Aufruf für alle Clients

* einen Client enthalten (z.B. "myclient.uib.local")

* eine Liste von Clients enthalten ["<client1>", "<client2>", ...]
+
z.B. ["client1.uib.local", "client2.uib.local"]

* eine Wildcard enthalten, wobei +*+ als Platzhalter dient
+
z.B. "client.\*" oder "\*.uib.*"

Werden Rechner nicht erreicht (z.B. weil sie aus sind), wird für diese Rechner eine Fehlermeldung ausgegeben.

[[opsi-manual-clientagent-control-messages]]
===== Nachrichten per Popup senden

Über den '{opsi-configed}' lassen sich Nachrichten an einen oder mehrere Clients versenden.

////
 <<opsi-manual-configuration-tools-opsi-configed-client-editing-send-message>>
////

Auf der Kommandozeile lässt dich dies ebenfalls mittels '{opsi-admin}' durchführen:
[source,prompt]
----
opsi-admin -d method hostControl_showPopup message *hostid
----

Beispiel:
[source,prompt]
----
opsi-admin -d method hostControl_showPopup "Ein Text..." "myclient.uib.local"
----

[[opsi-manual-clientagent-control-fire-event]]
===== 'Push'-Installationen: Event 'on demand' auslösen

Vom '{opsi-server}' aus kann der Client aufgefordert werden, die gesetzten '{product-actions}' auszuführen.

Das Auslösen des Events kann vom '{opsi-configed}' aus erfolgen.
////
und ist Kapitel  'on_demand' Ereignis auslösen (Push-Installation) auf Seite 30 beschrieben.
////

Auf der Kommandozeile lässt sich dies ebenfalls mittels '{opsi-admin}' durchführen:
[source,prompt]
----
opsi-admin -d method hostControl_fireEvent event *hostIds
----

Beispiel:
[source,prompt]
----
opsi-admin -d method hostControl_fireEvent "on_demand" "myclient.uib.local"
----

[[opsi-manual-clientagent-control-misc]]
===== Sonstige Wartungsarbeiten (shutdown, reboot, ...)

Über den Webservice des '{opsiclientd}' ist es möglich, steuernd auf den '{opsi-client-agent}' einzuwirken.
Dazu muss man sich an diesem Webservice authentifizieren.
Dies geschieht entweder mittels des lokalen Administrator-Accounts (ein leeres Passwort ist unzulässig)
oder mittels der '{opsi-host-id}' (FQDN / vollständiger Host-Name inkl. DNS-Domain) als Benutzername und des '{opsi-host-key}s' als Passwort.

Vom '{opsi-configed}' aus geht dies über das Menü 'OpsiClient' oder aus dem Kontextmenü des 'Client'-Tabs.

.Webservice des {opsiclientd}
image::../images/opsiclientd-control-server-web-interface.png["Abbildung: Webservice des {opsiclientd}",width=400]

Auch auf der Kommandozeile gibt es hierfür Entsprechungen:

shutdown:
[source,prompt]
----
opsi-admin -d method hostControl_shutdown *hostIds
----

reboot:
[source,prompt]
----
opsi-admin -d method hostControl_reboot *hostIds
----

[[opsi-manual-clientagent-loginblock]]
=== Sperrung des Anwender Logins mittels {opsi-login-blocker}

Um zu verhindern, dass sich ein Anwender schon vor dem Abschluss der Installation am System anmeldet, kann zusätzlich der {opsi-login-blocker} installiert werden.
Dieser gibt den Zugriff auf den Login erst frei, wenn der Installations-Prozess beendet ist.

Ob der '{opsi-login-blocker}' währen der '{opsi-client-agent}'-Installation installiert bzw. aktiviert wird,
kann über das '{product-property}' +loginblockerstart+ konfiguriert werden.

[[opsi-manual-clientagent-loginblock-nt5]]
==== {opsi-login-blocker} unter NT5 (Win2k/WinXP)
Der {opsi-login-blocker} (`opsigina.dll`) ist als 'GINA' realisiert.
Die 'opsigina' wartet bis zum Abschluss der '{product-actions}' oder dem Timeout (standard-Wert: 120 Sekunden) bei nicht erreichbarem '{opsiclientd}'.
Danach wird die Kontrolle an die nächste 'GINA' übergeben (in der Regel an die msgina.dll).
'GINA' steht hierbei für „Graphical Identification and Authentication“ und stellt die seitens Microsofts offiziell unterstützte Möglichkeit dar,
in den Login-Prozess von Windows einzugreifen.
Gelegentlich ist es der Fall, dass bereits andere Softwareprodukte (z.B. Client für Novell-Netzwerke) eine 'GINA' auf dem System installiert haben
und empfindlich auf Eingriffe reagieren.
Generell sind mehrere ,nacheinander aufgerufene 'GINAs' ('GINA-chaining') durchaus möglich.
Auch die 'opsigina.dll' des {opsi-login-blocker} ist für das genannte 'GINA-chaining' vorbereitet.
Sollte der beschriebene Fall bei Ihren Clients eintreten, informieren Sie sich bitte auf dem freien Supportforum (https://forum.opsi.org)
nach bestehenden Anpassungsmöglichkeiten oder kontaktieren Sie die Firma 'uib'.

[[opsi-manual-clientagent-loginblock-nt6]]
==== {opsi-login-blocker} unter NT6 (Vista/Win7)
Der '{opsi-login-blocker}' für NT6 (Vista/Win7) ist als 'credential provider filter' realisiert ('OpsiLoginBlocker.dll').
Er blockiert alle 'credential provider' bis zum Abschluss der '{product-actions}' oder dem Timeout (Standard-Wert: 120 Sekunden) bei nicht erreichbarem '{opsiclientd}'.

[[opsi-manual-clientagent-subsequent-installation]]
=== Nachträgliche Installation des opsi-client-agents
Die Anleitung zur nachträglichen Installation des '{opsi-client-agent}s' finden Sie im Handbuch 'opsi-getting-started' im Kapitel 'Erste Schritte'.

[[opsi-manual-clientagent-image-installation]]
==== Installation des opsi-client-agent in einem Master-Image oder als Exe
### has to be written ###




