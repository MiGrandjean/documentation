//// 
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; Until we found a better license:
; All rights reserved.
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Date:      21.07.2011
:Revision:  4.0.1

// Include common opsi terms
include::../common/opsi_terms.asciidoc[]


opsi-winst Manual
===================

[[opsi-winst-introduction]]
== Présentation

Le programme open source '{opsi-winst}' sert dans le contexte de OPSI – serveur d'intégration de pc (cf. www.opsi.org) – comme rôle central pour initier et effectuer l'installation automatique du logiciel. Il peut également être utilisé seul comme un outil pour les programmes d'installation pour n'importe quel logiciel. 

'{opsi-winst}' est fondamentalement un interprète pour un particulier, assez simple, langage de script qui peut être utilisé pour exprimer tous les éléments pertinents d'une installation de logiciel. 

Une installation du logiciel qui est décrit par un script '{opsi-winst}' et exécuté par l'exécution du script a plusieurs avantages par rapport aux installations qui sont gérées par un tas de commandes shell (par exemple copie etc):

'{opsi-winst}' montre dans le fichier journal très soigneusement toutes les opérations du processus d'installation. L'équipe de support peut vérifier les fichiers journal, et peut facilement détecter quand des erreurs sont survenues ou d'autres circonstances problématiques.

* Les actions de copie peut être configuré avec une grande variété d'options si les fichiers existants doivent être écrasés

* Surtout, il peut être configuré que les fichiers sont copiés selon leur version interne.

* Il y a différents modes pour écrire dans le registre Windows (écraser les valeurs existantes/ écrire seulement quand aucune valeur existe/ ajouter une valeur à une valeur existante).

* Le registre de Windows peut être patché pour tous les utilisateurs existant sur un poste de travail (y compris l'utilisateur par défaut, qui est utilisé comme prototype pour d'autres utilisateurs).

* Il y a une syntaxe sophistiquée pour un patch intégré de fichiers de configuration XML.


[[opsi-winst-cliparams]]
== Parametres de la ligne de commande

'{opsi-winst}' peut être démarré avec différents ensembles de paramètres dépendant du contexte et du but de l'utilisation. 

Il y a les suivants schémas syntaxique:

(1) montrer l'utilisation (aide):

`opsi-winst /?` +
`opsi-winst /h`[elp]

(2 ) Exécuter un script 

`opsi-winst` <fichier de script> +
      [`/logfile` <fichier journal> ] +
      [`/batch` | `/histolist` <Chemin du fichier de config de opsi-winst>] +
      [`/usercontext` <[domaine\]nom d'utilisateur> ] +
      [`/parameter` <chaîne de paramètres>]

(3) Exécuter une liste de scripts (séparées par des virgules) un par un:

`opsi-winst` `/scriptfile` <fichier de script> [;<fichier de script>]* [ `/logfile` <fichier journal> ] +
      [`/batch` | `/silent` ] +
      [`/usercontext` <[domaine\]nom d'utilisateur> ] +
      [`/parameter` <chaîne de paramètres>] +

4) Lire la configuration du PC à partir du service OPSI et agir en conséquence, depuis '{opsi-winst}' 4.3

`opsi-winst /opsiservice` <URL du service OPSI> +
     [`/clientid` <nom du client>] +
     [`/username` <nom d'utilisateur>] +
     [`/password` <mot de passe>] +
     [`/logfile` <fichier journal>] +
     [`/usercontext` <[domaine\]nom d'utilisateur> ] +
     [`/parameter` <chaîne de paramètres>]
   
Quelques explications:

* Le nom par defaut du fichier de log est `c:\tmp\instlog.txt`

* La chaîne de paramètres, qui se caractérise par l'option `/parameter`, est accessible pour chaque script wInst appelé (via la fonction de chaîne `ParamStr`).

* Lorsqu'il est appelé avec l'option `/usercontext` wInst peut faire des configurations pour un utilisateur connecté précisé (en particulier dans un Windows Terminal Server ou d'un contexte de profil itinérant).


Explications pour (2) et (3) :

* Si l'option `/batch` est utilisé, alors wInst montre seulement sa "batch surface" n'offrant aucune dialogues utilisateur. Par l'option `/silent` même la "batch surface" est supprimée. Sans l'aide de l'option `/batch` nous entrons dans le mode interactif où le fichier de script et le fichier journal peuvent être choisis de manière interactive (principalement pour des fins de test). 

* Le paramètre `winstconfigfilepath` qui est désigné par `/histofile` se réfère à un fichier au format ini qui contient (en mode interactif) les dernières noms de fichier de script utilisé. La surface de dialogue présente une zone de liste qui affiche ces noms de fichiers pour choisir le fichier suivant à interpréter. Si `winstconfigfilepath` se termine par "\" il est supposé être un nom de répertoire et `WINST.INI` sert de nom de fichier.

Explications pour (4):

* La valeur par défaut pour `clientid` est le nom d'ordinateur complet

Le mode non interactif est implicite.
     
[[opsi-winst-logpath]]
=== Chemins des fichiers journaux

Par défaut les fichiers journaux sont écrits dans le répertoire `c:\tmp` qui  wInst essaie de créer. Si wInst n'a pas accès à ce répertoire, il utilise le répertoire temporaire de l'utilisateur. 

Le nom du fichier journal par défaut est `instlog.txt`. Le nom du fichier journal et l'emplacement seront écrasées par l'option spécifiques en ligne de commande. 

Dans le cas, que wInst exécute un script dans le mode `/batch` et avec un contexte utilisateur (et de travail) spécifié, le chemin d'enregistrement par défaut est `opsi/tmp` dans le répertoire ApplicationData de l'utilisateur. Ce sera écrasé par un chemin de journal donné explicitement.

En plus, wInst utilise le répertoire de journalisation pour la sauvegarde de certains fichiers temporaires.

[[opsi-winst-configuration-options]]
== Configurations supplémentaires 

[[opsi-winst-central-logging]]
=== Journalisation centrale des messages d'erreur

Si vous le souhaitez, wInst écrit les données d'erreur dans un second fichier sur un lecteur réseau ou les envoie à un démon syslog.

La fonction peut être configuré dans le registre Windows:

Dans HKEY_LOCAL_MACHINE, nous avons, dans une installation standard, la clé  \SOFTWARE\opsi.org.  Nous pouvons créer une sous-clé syslogd avec une variable remoteerrorlogging. Sa valeur détermine si, et si oui par quelle méthode, une journalisation centrale doit avoir lieu.

En outre, dans +
'HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\syslogd' +
nous devons observer trois variables:

* Si remoteerrorlogging a la valeur 0, aucun log supplémentaires centrale a lieu (par défaut).

////
* Si remoteerrorlogging a la valeur 1, wInst essaie d'ouvrir un $pcname$.err dans configshare, sous-répertoire pcpatch\pclog, et écrire les données. 
////

* Si remoteerrorlogging a la valeur 2, les rapports d'erreur sont envoyés à syslog démon. Le nom d'hôte du démon est lu dans la variable sysloghost (défaut localhost) , le numéro du canal syslog peut être configuré à partir de la valeur de la variable syslogfacility (par défaut 18, qui est local2).

Le tableau suivant montre les valeurs possibles:

[source,ini]
----
ID_SYSLOG_FACILITY_KERNEL     = 0;  // messages du kernel 
ID_SYSLOG_FACILITY_USER       = 1;  // messages du niveau utilisateur
ID_SYSLOG_FACILITY_MAIL       = 2;  // système de messagerie
ID_SYSLOG_FACILITY_SYS_DAEMON = 3;  // démons système
ID_SYSLOG_FACILITY_SECURITY1  = 4;  // sécurité / messages d'autorisation (1)
ID_SYSLOG_FACILITY_INTERNAL   = 5;  // messages générés en interne par syslogd
ID_SYSLOG_FACILITY_LPR        = 6;  // imprimante système
ID_SYSLOG_FACILITY_NNTP       = 7;  // sous-système de nouvelles du réseau
ID_SYSLOG_FACILITY_UUCP       = 8;  // UUCP sous-système
ID_SYSLOG_FACILITY_CLOCK1     = 9;  // démon horloge (1)
ID_SYSLOG_FACILITY_SECURITY2  = 10; // sécurité / messages d'autorisation (2)
ID_SYSLOG_FACILITY_FTP        = 11; // démon FTP
ID_SYSLOG_FACILITY_NTP        = 12; // sous-système NTP
ID_SYSLOG_FACILITY_AUDIT      = 13; // journal d'audit
ID_SYSLOG_FACILITY_ALERT      = 14; // journal d'alerte
ID_SYSLOG_FACILITY_CLOCK2     = 15; // démon horloge (2)
ID_SYSLOG_FACILITY_LOCAL0     = 16; // utilisation locale 0  (local0)
ID_SYSLOG_FACILITY_LOCAL1     = 17; // utilisation locale 1  (local1)
ID_SYSLOG_FACILITY_LOCAL2     = 18; // utilisation locale 2  (local2)
ID_SYSLOG_FACILITY_LOCAL3     = 19; // utilisation locale 3  (local3)
ID_SYSLOG_FACILITY_LOCAL4     = 20; // utilisation locale 4  (local4)
ID_SYSLOG_FACILITY_LOCAL5     = 21; // utilisation locale 5  (local5)
ID_SYSLOG_FACILITY_LOCAL6     = 22; // utilisation locale 6  (local6)
ID_SYSLOG_FACILITY_LOCAL7     = 23; // utilisation locale 7  (local7)
----

[[opsi-winst-skins]]
=== Thèmes {opsi-winst}

Depuis la version 3.6  wInst a un thème adaptable. Ses éléments sont situés dans un sous-répertoire winstskin du répertoire wInst en exécution. Le fichier de définition que vous pouvez éditer est skin.ini. 

[[opsi-winst-script]]
== Le script '{opsi-winst}'

En principe:  wInst est un interprète pour un particulier, facile à utiliser, langage de script qui est adapté pour les besoins des installations de logiciels. Un script devrait être une description intégrée, et un moyen de contrôle, pour l'installation d'un logiciel.

La section suivante esquisses de la structure d'un script wInst. Le but est d'identifier les signets d'un script: de quelle manière nous devons étudier la question pour comprendre son traitement.

Tous les éléments sont décrits plus en détail dans la section plus loin. Le but sera alors de montrer comment les scripts peuvent être modifiés ou développés.

[[opsi-winst-script-first-example]]
=== Un Exemple

Les scripts wInst sont à peu près issus des fichiers .INI. Ils sont composés de sections, qui sont marquées par un titre (le nom de section), qui est écrite entre parenthèses []. 

Schématiquement un script wInst ressemble à celui (ici avec une vérification de quel système d'exploitation est installé):

[source,winst]
----
[Actions]
Message "Installation de Mozilla"
SetLogLevel=6

;which Windows-Version?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "pas une version d'OS supporté"
  endif
endif
  

[sub_install_win7]
Files_copy_win7
WinBatch_Setup

[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP

[Files_copy_win7]
copy "%scriptpath%\files_win7\*.*" "c:\temp\installation"

[Files_copy_winxp]
copy "%scriptpath%\files_winxp\*.*" "c:\temp\installation"

[WinBatch_Setup]
c:\temp\installation\setup.exe

[WinBatch_SetupXP]
c:\temp\installation\install.exe
-----

Comment pouvons-nous lire les sections de ce script?

[[opsi-winst-kinds-of-sections]]
=== Sous-programmes primaires et secondaires d'un script wInst

Le script dans son ensemble constitue un programme, une instruction pour une procédure d'installation. Ainsi chacune de ses sections peut être vu comme un sous-programme (ou "procedure" ou "method").  Le script est une collection de sous-programmes.

Le lecteur humain ainsi qu'un logiciel interprète, doivent savoir à partir de quel élément de cette collection doit commencer la lecture.

Exécution d'un script wInst commence sur les sections [Initial] et [Actions] (dans cet ordre). Toutes les autres sections sont appelés comme sous-programmes de ces deux sections. Ce processus n'est récursif que pour les sous-sections: Sub-sections ont la même syntaxe que les sections Initial et Actions et peuvent contenir des appels à des sous-routines supplémentaires.

Cela donne la raison de faire la distinction entre les sous-programmes primaire et secondaire:

Les sections de contrôle primaire ou générale comprennent 

* la section optionnel *Initial* (par convention, le début du script),

* la section *Actions* (doit suivre la section *Initial*), et 

* *Sub* sections (de 0 à n sous-programmes appelés par la section *Actions* qui sont des extensions syntaxiques et logiques de la section d'appel).

La logique procédurale du script est déterminé par la séquence d'appels dans ces sections. 

Les sections secondaires ou spécifiques peuvent être appelés depuis n'importe quelle section primaire, mais ont une syntaxe différente. La syntaxe est dérivé des exigences fonctionnelles et des conditions de la bibliothèque et des conventions pour les fins spécifiques. Par conséquent, aucune autre section peut être appelé à partir d'une section secondaire.

En ce moment il y a les types suivants de sections secondaires:

* Files sections, 
* WinBatch sections,
* DosBatch/DosInAnIcon/ShellInAnIcon sections,
* Registry sections
* Patches sections,
* PatchHosts sections,
* PatchTextFile sections,
* XMLPatch sections,
* LinkFolder sections,
* opsiServiceCall sections,
* ExecPython sections,
* ExecWith sections,
* LDAPsearch sections.

Sens et syntaxe des types de sections différentes sont traitées dans les chapitres
<<opsi-winst-prim-section>>
et
<<opsi-winst-secsections>>.

[[opsi-winst-stringvalues]]
=== Expressions de chaîne dans un script wInst

Les valeurs textuels (valeurs de chaîne) dans les sections primaires peuvent être donnés de façon différente:

* La valeur peut être directement cités, surtout par écrit en marques de citation (entre double). Exemples: +
'"Installation de Mozilla"' +
'"n:\home\nom d'utilisateur"'

* La valeur peut être donnée par une variable chaîne ou une constante chaîne, qui "contient" la valeur: +
La variable '$MsVersion$' peut se porter "6.1"  –  si elle a été affectée avant avec cette valeur.

* Une fonction récupère ou calcule une valeur par une procédure interne. Par exemple:
`EnvVar ("Username")` +
récupère une valeur de l'environnement système, dans ce cas, la valeur de la variable d'environnement 'Username'.  Les fonctions peuvent avoir n'importe quel nombre de paramètres, y compris le zéro: +
'GetMsVersionInfo' +
Sur un système Win7, cet appel de fonction donne la valeur "6.1" (non pas comme une variable, cette valeur doit être produite à chaque appel à nouveau). 

* Une valeur peut être construit par une expression adjuvant, où les valeurs de chaîne et d'expressions partielles sont concaténés - théoriquement "plus" peut être vu comme une fonction de deux paramètres: +
'$Home$ + "\mail"'


(Plus sur ce sujet dans la section <<opsi-winst-string>>)

Il n'ya pas de façon analogue d'utiliser des expressions de chaîne dans les sections secondaires. Ils y suivent une syntaxe de domaine spécifique. Par exemple pour les commandes de copie, similaire à la commande de copie en ligne de Windows. Jusqu'à ce moment, il n'ya pas de syntaxe d'échappement mis en œuvre pour le transport de la logique de section primaire vers une section secondaire.

La seule façon pour le transport de valeurs de chaîne dans les sections secondaires est l'utilisation des noms des variables et des constantes comme conteneur de valeur dans ces sections. Jetons un coup d'œil aux variables et aux constantes d'un script de wInst:

[[opsi-winst-var-const]]
== Définition et utilisation de variables et constantes dans un script wInst 

[[opsi-winst-var-const-general]]
=== Général

Dans un script wInst, variables et constantes apparaissent comme "mots", qui sont interprétés par wInst et "contiennent" des valeurs. "Mots"  sont des séquences de caractères comprenant des lettres, des chiffres et certains caractères spéciaux (en particulier ".", "-", "_", "$", "%"), mais pas des blancs, pas de crochets, parenthèses, ou les signes opérateur ("+") . 

Les variables et constantes wInst ne sont pas sensibles à la casse.

Il existe les types suivants de variables ou de constantes:

* Constantes texte global, constantes courtes, +
contiennent des valeurs qui sont présents par le programme wInst et ne peuvent être changé dans un script. Avant d'interpréter le script, wInst remplace chaque occurrence du nom de constante avec sa valeur dans l'ensemble du script (substitution textuelle). +
Un exemple permettra de clarifier cela: +
La constante `%ScriptPath%` est le nom prédéfini de l'endroit où wInst, trouve et de lit le script qu'il exécute. Cet emplacement peut être, par exemple,  `p:\product`. Puis nous devons écrire +
`"%ScriptPath%"` +
dans le script lorsque l'on veut faire obtenir la valeur 
+`"p:\product"`. +
- respecter les guillemets qui incluent le délimiteur de la constante.

* Variables de texte ou chaîne, variables courtes, +
ont une apparence très semblable à toutes les variables (chaîne) dans un langage de programmation commune. Ils doivent être déclarés par une déclaration  `DefVar` avant qu'ils puissent être utilisés. Dans les sections primaires, les valeurs peuvent être assignées à des variables (une ou plusieurs fois). Ils peuvent être utilisés comme éléments dans les expressions composées (comme l'addition de chaînes) ou comme arguments de fonction.  +
Mais ils se comportent comme une constante dans une section secondaire, ils apparaissent comme un élément non-syntaxiques étrangers. Leur valeur est fixé et insérée par substitution textuelle pour leurs noms (quand une section est appelée, alors la substitution textuelle pour les constantes réelles a lieu avant de commencer l'exécution de l'ensemble du script).

* Variables de liste de chaînes +
sont renseignés par une déclaration `DefStringList`. Dans les sections primaires peuvent être utilisés à des fins multiples, par exemple collecte des chaînes, manipulation des chaînes, building sections. 

En détail:

[[opsi-winst-global-const]]
=== Constantes Global Text

Les scripts doivent travailler dans un des contextes différents, sans modification manuelle. Les contextes peuvent être caractérisées par des valeurs système comme la version de l'OS ou certains chemins. wInst  introduit ces valeurs comme des constantes dans le script. 

[[opsi-winst-global-const-usage]]
==== Utilisation

La caractéristique fondamentale d'une constante texte est la manière avec laquelle les valeurs qu'elle représente entrent dans le processus d'interprétation du script:

Le nom de la constante, qui est une simple séquence de caractères, est remplacé par sa valeur fixe, dans le script entier avant commencer l'exécution du script.

Le remplacement ne tient pas compte de tout contexte syntaxique dans lequel le nom éventuellement se produit (exactement comme avec des variables dans les sections secondaires).

[[opsi-winst-global-const-exmple]]
==== Exemple
wInst met en œuvre des constantes %ScriptPath%  pour l'emplacement du script interprété momentanément et %System% pour le nom du répertoire système de Windows. La sous-section suivante (Fichiers) définit une commande qui copie tous les fichiers du répertoire de script dans le répertoire système de Windows:
[source,winst]
----
[files_do_my_copying]
copy "%ScriptPath%\system\*.*" "%System%" 
----

En ce moment les constantes suivantes sont fournie:

[[opsi-winst-global-const-list]]
[[opsi-winst-global-const-list-system1]]
==== System paths

[[opsi-winst-global-const-list-system-base]]
===== Répertoires du système de base

`%ProgramFilesDir%`:	'c:\program files'

`%ProgramFiles32Dir%`:	'c:\Program Files (x86)'

`%ProgramFiles64Dir%`:	'c:\program files'

`%ProgramFilesSysnativeDir%` :	'c:\program files'

`%Systemroot%` :  	'c:\windows'

`%System%` :  	 	'c:\windows\system32'

`%Systemdrive%` :       	'c:'

`%ProfileDir%` :	        'c:\Documents and Settings'

[[opsi-winst-global-const-list-commondir]]
===== Répertoires communs (AllUsers)

`%AllUsersProfileDir%` ou `%CommonProfileDir%` : 'c:\Documents and Settings\All Users'

`%CommonStartMenuPath%` ou `%CommonStartmenuDir%` : 'c:\Documents and Settings\All Users\Startmenu'

`%CommonAppdataDir%` : 'c:\Documents and Settings\All Users\Application Data'

`%CommonDesktopDir%`

`%CommonStartupDir%`

`%CommonProgramsDir%`

[[opsi-winst-global-const-list-currentuser]]
===== Répertoires utilisateur courant (connecté ou contexte de l'utilisateur)

`%AppdataDir%` ou `%CurrentAppdataDir%` : 'c:\Documents and Settings\%USERNAME%\Application Data'

`%CurrentStartmenuDir%` 

`%CurrentDesktopDir%`

`%CurrentStartupDir%`

`%CurrentProgramsDir%`

`%CurrentSendToDir%`

[[opsi-winst-global-const-list-allntuser]]
===== Répertoire constantes /AllNtUserProfiles

Dans les sections 'Files' qui sont appelés avec l'option `/AllNtUserProfiles` il y a une pseudo variable  +
`%UserProfileDir%` +
Lorsque la section est exécutée pour chaque utilisateur qui existe sur un poste de travail cette variable représente le nom du répertoire du profil de l'utilisateur venons de traiter. 

[[opsi-winst-global-const-list-winst]]
==== Chemins '{opsi-winst}'

`%ScriptPath%` ou `%ScriptDir%` : représente le chemin du script wInst actuelle (sans dosseret de fermeture). En utilisant cette variable, nous pouvons construire chemin et les noms de fichier dans les scripts qui sont relatives à l'emplacement du script. Donc, tout peut être copié, appelé de son nouveau lieu, et tous fonctionne comme avant.

`%ScriptDrive%` : Il conduit où le script wInst exécuté est situé (y compris le côlon).

`%WinstDir%` : L'emplacement de wInst actuellement executé (sans dosseret de fermeture).

`%WinstVersion%` : Version de l'actuelle winst.

`%Logfile%` : Le nom du fichier de log utilisé par winst.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "Testing constants: "+"%"+"winstversion" +"%"
	set $ConstTest$ = "%WinstVersion%"
	set $InterestingFile$ = "%winstdir%\winst.exe"
	if not (FileExists($InterestingFile$))
		set $InterestingFile$ = "%winstdir%\winst32.exe"
	endif
	set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
	set $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----
	
résultats dans le journal suivante:
[source,winst]
----
comment: Testing: 
message Testing constants: %winstversion%

Set  $ConstTest$ = "4.10.8.3"
  The value of the variable "$ConstTest$" is now: "4.10.8.3"

Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable "$InterestingFile$" is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]

Set  $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
    retrieving strings from $INST_Resultlist$ [switch to loglevel 7 for debugging]
  The value of the variable "$CompValue$" is now: "4.10.8.3"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed

Else
EndIf
----

[[opsi-winst-global-const-list-network]]
==== Information réseau

`%Host%` :	(Obsolète) La valeur de la variable d'environnement hôte (Traditionnellement, signifiant le nom du serveur OPSI, ne pas confondre avec  %HostID%  signifiant le nom du réseau du client).

`%PCName%`:	La valeur de la variable d'environnement +PCName+, quand existante. Sinon, la valeur de la variable d'environnement +computername+. (Doit être le nom NetBIOS de l'ordinateur) 

`%IPName%` : Le nom DNS de l'ordinateur. Habituellement identique au nom netbios et donc avec `%PCName%` outre que les noms NetBIOS, utilisé en majuscules. 

`%Username%` :	Nom de l'utilisateur connecté.

[[opsi-winst-global-const-list-service]]
==== Les données, pour et à partir, du service opsi

`%HostID%` :	Doit être le nom de domaine entièrement qualifié du client opsi car il est fourni par la ligne de commande ou autrement. 

`%opsiserviceURL%` : L'URL du service opsi (normalement https://).

`%opsiServer%` : Le nom du serveur dérivé de `%opsiserviceURL%`.

`%opsiserviceUser%` : L'ID utilisateur pour lequel il y a une connexion au service opsi.

`%opsiservicePassword%` : Le mot de passe d'utilisateur utilisé pour la connexion au service opsi. Le mot de passe est éliminée lors de la connexion par la fonction de journalisation standard de wInst.

`%installingProdName%`: 	Le 'productid' du produit qui est réellement installée via l'appel par le service opsi. Vide si le script n'est pas lancé par le service opsi.

`%installingProdVersion%`:	Une chaîne combinées de +<productversion>-<packageversion>+ pour le produit qui est actuellement installée via l'appel par le service opsi. Vide si le script n'est pas lancé par le service opsi.

`%installingProduct%` :	(Obsolète) Le nom (productId) du produit pour lequel le service a appelé le script exécuté. Dans le cas où le script n'est pas exécuté via le service la chaîne est vide.

[[opsi-winst-strvar]]
=== Variables chaîne (ou texte)

[[opsi-winst-strvar-decl]]
==== Déclaration

Les variables chaîne doivent être déclarés avant qu'ils ne puissent être utilisées. La syntaxe de la déclaration est

`DefVar` <nom de la variable>

exemple:
[source,winst]
----
DefVar $MsVersion$
----

Explication:

* Les noms de variables ne sont pas nécessairement commencé ou terminé par un signe dollar, mais cela est recommandé comme une convention pour comprendre leur fonctionnement dans les sections secondaires.

* Les variables peuvent être déclaré que dans les sections primaires (Initial section,  Actions section and sub sections).

*La déclaration ne devrait pas dépendre d'une condition. Ne doit pas être placée dans une branche d'une instruction if – else. Sinon, il pourrait arriver que la déclaration DefVar n'est pas exécuté pour une variable, mais une évaluation de la variable est essayé dans certains clause if (produisant une erreur de syntaxe).
Les variables sont initialisées avec une chaîne vide (""). 

Recommandation:

* La première lettre et la dernière du nom doit être '+$+'

* Définissez toutes les variables au début du script

[[opsi-winst-strvar-set]]
==== Affectation de valeur

Comme il est approprié pour une variable, il peut prendre en une seule valeur la réponse à une série de valeurs alors que le script progresse. Les valeurs sont affectées par des déclarations avec la syntaxe

`Set` <nom de la variable> `=` <Valeur>

<Valeur> désigne toute expression (valeur de chaîne). 

Exemples (Par Exemples voir <<opsi-winst-string>>):

[source,winst]
----
Set $OS$ = GetOS
Set $NTVersion$ = "nicht bestimmt"

if $OS$ = "Windows_NT"
  Set $NTVersion$ = GetNTVersion
endif

DefVar $Home$
Set $Home$ = "n:\home\user name"
DefVar $MailLocation$
Set $MailLocation$ = $Home$ + "\mail"
----

[[opsi-winst-strvar-usage]]
==== Utilisation de variables dans les expressions de chaîne

Dans les sections primaires d'un script wInst, une variable "détient" une valeur. Quand elle est déclaré, est initialisé avec la chaîne vide "".  Lorsqu'une nouvelle valeur est assignée à lui via la commande `set`, il représente cette valeur. 

In a primary section a variable can replace any String expression resp. can be  a component of a String expression, e.g. 
[source,winst]
----
Set $MailLocation$ = $Home$ + "\mail"
----

Dans une section primaire le nom de la variable désigne un objet qui représente une chaîne, Si nous ajoutons la variable, nous entendons que la chaîne sous-jacente doit être ajouté en quelque sorte.

Cette chaîne de représentation est contextuel dans une section secondaire. Juste le nom de la variable se trouve maintenant pour la chaîne. 

[[opsi-winst-strvar-in-sections]]
==== Sections secondaire contre primaires

Quand une section secondaire est chargé, et wInst commence son interprétation, la séquence de caractères d'un nom de variable est directement remplacée par la valeur de la variable.

Exemple: +
Une commande `copy` dans une section fichiers doit copier un fichier dans +
"+n:\home\user name\mail\backup+" +
copiés.

Nous avons mis `$MailLocation$` dans le répertoire au-dessus:
[source,winst]
----
DefVar $Home$
DefVar $MailLocation$
Set $Home$ = "n:\home\user name"
Set $MailLocation$ = $Home$ + "\mail"
----

$MailLocation$ maintenant contient +
"+n:\home\user name\mail+"

Dans une section primaire, nous pouvons désormais exprimer le répertoire +
´"n:\home\user name\mail\backup"´ +
avec +
´$MailLocation$ + "\backup"´


Le même répertoire doit être désignée dans une section secondaire: +
`"$MailLocation$\backup"`

Une différence fondamentale entre la pensée de variables dans les sections primaires par rapport au secondaires, c'est que, dans une section primaire, nous pouvons former une expression d'assignation, comme +
`$MailLocation$ = $MailLocation$ + "\backup"`

Comme d'habitude, cela signifie que `$MailLocation$` a tout d'abord une valeur initiale et prend une nouvelle valeur en ajoutant quelques chaîne à la valeur initiale. La référence de la variable est dynamique, et peut avoir des antécédents. 

Dans une section secondaire telle expression ne serait rien (et éventuellement erronée), depuis `$MailLocation$` ne peut être que remplacée par une chaîne de caractères fixes (à toutes les occurrences quasiment au même moment).

[[opsi-winst-lstvar]]
=== Variables liste de chaînes

Les variables pour les listes de chaîne doivent être affecté dans une déclaration DefStringList, par exemple:
[source,winst]
----
DefStringList SMBMounts
----

Une liste de chaîne peut servir par exemple comme conteneur pour la sortie capturé d'un programme shell. Les chaînes collectées peuvent être manipulés dans un grand nombre de façons. Dans le détail ce sera traitée dans la section sur le traitement des listes de chaînes (voir la section <<opsi-winst-stringlist>>).

CAUTION: Si (imbriquées) les sous-sections seront confiés à des fichiers externes, les sections dites secondaires sont généralement placés dans le fichier, à partir de laquelle ils sont appelés. Selon la complexité de la syntaxe, ils peuvent avoir besoin *supplémentaires* également être logés dans le fichier principal.


[[opsi-winst-prim-section]]
== Syntaxe et signification des sections primaires d'une script wInst 

Comme présenté brièvement dans le chapitre 4 la section Actions d'une script peut être considéré comme une méthode principale du script wInst et décrit la séquence de traitement global. Il peut appeler des sous-routines - les sous-sections - qui peuvent ensuite appeler récursivement les sous-sections elles-mêmes.

Les sections suivantes expliquent la syntaxe et l'utilisation des sections primaires d'un script wInst.

[[opsi-winst-prim-section-kinds]]
=== Sections primaires

Il y a trois sortes de sections primaires dans un script

* Une section `Initial` (peut être omise),

* Une section `Action`, 

* n'importe quel nombre de sections `Sub`

Les sections `Initial` et `Action` sont syntaxiquement équivalents (mais Initial doit garder la première place). Par convention,  dans la section Initial sont faits certains paramétrages de l'exécution du script (par exemple le niveau de journalisation). La section Action peut être considéré comme le programme principal dans un scripts wInst. Il contient la séquence d'actions qui sont contrôlées par le script.

Les sous-sections sont ainsi syntaxiquement équivalents. Mais ils sont appelés depuis la section Action. Ensuite, ils peuvent appeler eux-mêmes des sous-sections. 

Une sous-section est déterminée par la création d'un nom qui commence par "Sub", par exemple `Sub_InstallBrowser`. En écrivant son nom dans la section Action nous produisons un appel à la sous-section. Le sens de cet appel est défini par le contenu de la section dans le script qui commence par le nom entre crochets, dans l'exemple  `[Sub_InstallBrowser]`

NOTE: Les sous-sections du second ordre et supérieur ne peuvent accueillir des sections internes. Au lieu de cela, leurs appels de procédure doit se référer aux sections définies dans le fichier script principal ou définies comme des sections externes (voir <<opsi-winst-commands-subcall>>).

CAUTION: Si (imbriqués) les sous-sections seront confiés à des fichiers externes, les sections appelées doivent être dans ce fichier d'où ils sont appelés. Selon la complexité du script ils peuvent parfois être placé *aussi* dans le fichier principal.

[[opsi-winst-params]]
=== Paramétrage de wInst

Entrées typiques d'une section Initial définissent certains attributs d'exécution de wInst. L'exemple suivant montre comment les réponses d'erreur peuvent être configuré:

[[opsi-winst-params-example]]
==== Exemple
[source,winst]
----
[Initial]
SetLogLevel=5
ExitOnError=false
ScriptErrorMessages=on
TraceMode=off
----
Cela signifie que: 

* le niveau de journalisation est réglé à 5

* quand une erreur survient winst vais essayer de continuer l'exécution du script

* Si une erreur de syntaxe de script survient, il doit être communiquée (ce sera dans une fenêtre spéciale)

* nous ne voulons pas activer le mode trace pour l'exécution du script (ce qui voudrait dire que nous avons une demande après chaque étape du programme, si nous voulons continuer).

Les valeurs ci-dessus sont les valeurs par défaut, wInst va les assumer si ces déclarations sont manquants.

Pour les détails de la syntaxe et de la signification: 

[[opsi-winst-params-loglevel]]
==== Spécification du niveau de journalisation

CAUTION: L'ancienne fonction `LogLevel=` est obsolète depuis la version 4.10.3 de wInst. Pour des raisons de compatibilité descendante Loglevels sera augmenté de 4 avant qu'ils ne soient utilisés.

Il y a deux variantes syntaxiques pour spécifier le niveau de journalisation:

SetLogLevel = <nombre> 
SetLogLevel = <expression de chaîne> 
À savoir le nombre peut être donnée comme une valeur entière ou comme une expression chaîne (voir section 6.3). Dans le second cas, wInst tente d'évaluer l'expression de chaîne comme un nombre.
Il existe dix niveaux de 0 à 9. 

Il existe deux variantes similaires pour spécifier le niveau de log:

`SetLogLevel =` <nombre> 

`SetLogLevel =` <expression de chaîne>

À savoir le nombre peut être donnée comme une valeur entière ou comme une expression chaîne (voir section 6.3). Dans le second cas, wInst tente d'évaluer l'expression de chaîne comme un nombre.

Il existe dix niveaux de 0 à 9. 
****
                0 = rien (absolument rien)
                1 = essentielles ("informations essentielles")
                2 = critiques (des erreurs inattendues qui peuvent entraîner une interruption du programme)
                3 = erreur (Les erreurs qui n'arrêteront pas  l'exécution du programme)
                4 = avertissement (vous devriez jeter un oeil à ce)
                5 = notice (Important statements to the program flow)
                6 = info (Infos supplémentaires)
                7 = débogage (messages de débogage importants)
                8 = débogage2 (beaucoup plus d'informations de débogage et de données)
                9 = confidentielles (mots de passe et autres données de sécurité pertinentes)

****

[[opsi-winst-params-required-winst]]
==== Version nécessaire '{opsi-winst}'

la déclaration 

`requiredWinstVersion`   <RELATIONS SYMBOLE>   <nombre chaîne>

par exemple:
[source,winst]
----
requiredWinstVersion >= "4.3"
----

permet à winst de vérifier si l'état de la version désirée est donnée. Sinon un message d'erreur windows apparait. 

Cette fonctionnalité existe depuis la version 4.3 de wInst. Pour une version antérieure, la déclaration est inconnue, et la déclaration elle-même est une erreur de syntaxe qui sera indiquée par la fenêtre erreur de syntaxe (voir la section suivante). Par conséquent, la déclaration peut être utilisée indépendamment de la version de wInst actuellement utilisée tant que la version requise est au moins la version 4.3.

[[opsi-winst-params-errors]]
==== Réaction sur ​​les erreurs

Il y a deux sortes d'erreurs qui sont traités de différentes manières:

. déclarations illégales qui ne peuvent pas être interprétées par wInst (erreurs syntaxiques),

. faute de déclarations qui ne peuvent pas être exécutées à cause de raisons externes objectives (erreurs d'exécution).

En principe, les erreurs syntaxiques sont indiquées dans une fenêtre pop-up pour la correction immédiate, les erreurs d'exécution sont enregistrées dans un fichier journal pour être analysés plus tard.

Le comportement de wInst quand il reconnaît une erreur de syntaxe est défini par la déclaration de configuration

* `ScriptErrorMessages =` <valeur booléenne> +
Si la valeur est vraie  (défaut), les erreurs de syntaxe déclenchent une fenêtre popup avec quelques informations sur l'erreur. Ce genre d'erreurs ne sont pas enregistrées dans le fichier journal. Le fichier journal doit conserver des informations sur l'exécution réelle d'un script de syntaxe correcte. +
La valeur booléenne peut être true (vrai) ou false (faux). Les délimiteurs  `on` ou `off` peuvent être utilisés aussi bien.

Il y a deux options de configuration pour des erreurs d'exécution.

* `ExitOnError =` <valeur booléenne> +
Cette déclaration définit si l'exécution du script prend fin quand une erreur survient. Si la valeur est `true` ou `yes` le programme va arrêter l'exécution, sinon les erreurs sont simplement enregistré (défaut).

* `TraceMode =` <valeur booléenne> +
En TraceMode (défaut  `false`) chaque entrée de fichier journal, sera en plus affiché dans la fenêtre de message, avec un bouton OK.

[[opsi-winst-params-stayontop]]
==== Restant au-dessus 

*  `StayOnTop =` <valeur booléenne>

Avec StayOnTop = true (ou  = on) nous demandons, que  - en mode batch -  la fenêtre de wInst soit sur ​​le dessus des fenêtres qui se partagent l'écran. Cela signifie qu'il devrait être visible dans le "premier plan" tant qu'aucune autre fenêtre aie le même statut. 
 
CAUTION: Selon le manuel du système la valeur ne peut pas être modifié pendant l'exécution du programme.  Mais il semble que nous pouvons donner une nouvelle valeur pour une fois. 

`StayOnTop` il est `false` par défaut afin d'éviter que certains autres processus génère un message d'erreur qui peut éventuellement ne pas être vu si wInst reste au-dessus.

[[opsi-winst-string]]
=== Expressions de chaîne, Valeurs de chaîne, et Fonctions de chaîne

Une expression de chaîne peut être

* une valeur de chaîne élémentaires
* une valeur de chaîne imbriquées
* une variable chaîne
* la concaténation d'autres expressions de type chaîne
* un appel de fonction d'une valeur de chaîne

[[opsi-winst-string-elementary]]
==== Valeur de chaîne élémentaires
Une valeur de chaîne élémentaires est une séquence de caractères qui est enfermé dans des guillemets double ou simple, formellement:

'"<séquence de caractères>"'

ou

''<séquence de caractères>''

Exemple:
[source,winst]
----
DefVar $ExampleString$
Set $ExampleString$ = "mon texte"
----

[[opsi-winst-string-nested]]
==== Chaînes dans des chaînes (valeur de chaîne imbriquées)

Si la séquence de caractères contient elle-même des guillemets, nous devons utiliser les autres types de guillemets pour l'entourer:
[source,winst]
----
DefVar $citation$
Set $citation$ = 'il a dit "Oui"'
----

Si la séquence de caractères contient les deux types de guillemets, nous devons utiliser l'expression spéciale suivante: +
`EscapeString:` <séquence de caractères> +
Par exemple nous pouvons écrire: +
[source,winst]
----
DefVar $Meta_citation$
Set $Meta_citation$ = EscapeString: Set $citation$ = 'il a dit "Oui"'
----
Alors la variable `$Meta_citation$` va exactement contenir la séquence complète de caractères qui suit la colonne après "EscapeString" (y compris le vide). `$Meta_citation$` contiendra la déclaration complète: +Set $citation$ = `'il a dit "Oui"'`+ 

[[opsi-winst-string-concat]]
==== Concaténation de chaînes 

Une concaténation de chaîne est écrite en utilisant le signe plus ("+") 

<expression de chaîne> `+` <expression de chaîne>

Exemple:
[source,winst]
----
DefVar $String1$
DefVar $String2$
DefVar $String3$
DefVar $String4$
Set $String1$ = "mon texte"
Set $String2$ = "et"
Set $String3$ = "ton texte"
Set $String4$ =  $String1$ + " " + $String2$ + " " + $String3$
----

$String4$ a alors la valeur "mon texte et ton texte".

[[opsi-winst-string-expressions]]
==== Variables chaîne

Une variables chaîne dans une section primaire "contient" une valeur de chaîne. Dans une expression de chaîne, il peut toujours remplacer une chaîne élémentaire. Pour savoir comment définir et configurer les variables de chaîne voir la section <<opsi-winst-strvar>>.

Les sections suivantes présentent une variété de fonctions de chaînes. 

[[opsi-winst-string-functions-os]]
==== Fonctions de chaîne qui renvoient le type de système d'exploitation

* GetOS +
La fonction indique le type de système d'exploitation en marche. Elle retourne l'une des valeurs suivantes: +
"Windows_16" +
"Windows_95" (y compris Windows 98 et ME) +
"Windows_NT" (y compris Windows 2000 et XP) +
"Linux" +

* GetNtVersion +
Un système d'exploitation Windows NT est caractérisé par un numéro de type et de sous-type Windows. GetNtVersion  retourne le nom de sous-type précis. Les valeurs possibles sont +
"NT3" +
"NT4" +
"Win2k" (Windows 5.0) +
"WinXP" (Windows 5.1) +
"Windows Vista" (Windows 6) +
Si le système d'exploitation NT est plus que la version 6 ou il y a une version pas explicitement connue, la fonction retourne "Win NT" et le numéro de version complet (5.2, ... , 6.0 ..) . Par exemple pour Windows Server 2003 R2 Enterprise Edition, nous obtenons +
"Win NT 5.2" +
Si le système d'exploitation n'est pas Windows NT la fonction retourne la valeur d'erreur +
"No OS of Windows NT type"

* GetMsVersionInfo +
pour les systèmes de type Windows NT renvoie les informations de version de Microsoft comme indiqué par l'API, par exemple un ordinateur Windows XP produit le résultat + 
"5.1"

.Versions de Windows
[options="header"]
|=======================
|GetMsVersionInfo|Versions de Windows
|5.0    |Windows 2000
|5.1    |Windows XP (Home, Prof)
|5.2    |XP 64 Bit, 2003, Home Server, 2003 R2
|6.0    |Vista, 2008
|6.1    |Windows 7, 2008 R2
|=======================
voir aussi `GetMsVersionMap`

*  `GetSystemType` +
vérifie l'installation de Windows OS, si on peut supposer que le système est de 64 bits. Dans ce cas, la valeur est '64 Bit System' autrement 'x86 System'.

[[opsi-winst-string-functions-env]]
==== Fonctions de chaîne pour la récupération de l'environnement ou de données en ligne de commande


La fonction lit et retourne la valeur momentanée d'une variable d'environnement système. 

Par exemple, nous pouvons récupérer l'utilisateur qui est connecté avec EnvVar ("Username").
ParamStr
La fonction passe la chaîne de paramètres de la ligne de commande de winst à savoir le paramètre de ligne de commande qui est indiqué par /parameter. S'il n'ya pas de paramètre  ParamStr renvoie la chaîne vide.
GetLastExitCode
retourne le code de sortie (aussi appelé ErroLevel) du dernièr appel WinBatch.
GetUserSID(<nom d'utilisateur Windows>)
retourne le SID pour un utilisateur donné (éventuellement avec le préfixe de domaine sous la forme 
DOMAINE\UTILISATEUR).

*  `EnvVar (` <string>`)` +
La fonction lit et retourne la valeur momentanée d'une variable d'environnement système. Par exemple, nous pouvons récupérer l'utilisateur qui est connecté avec `EnvVar ("Username")`.

*  `ParamStr` +
La fonction passe la chaîne de paramètres de la ligne de commande de wInst à savoir le paramètre de ligne de commande qui est indiqué par /parameter. S'il n'ya pas de paramètre  ParamStr renvoie la chaîne vide.

*  `GetLastExitCode` +
retourne le code de sortie (aussi appelé ErroLevel) du dernièr appel WinBatch.

*  `GetUserSID(`<Windows Username>`)` +
retourne le SID pour un utilisateur donné (éventuellement avec le préfixe de domaine sous la forme 
DOMAINE\UTILISATEUR).

* `GetUsercontext` +
renvoie la chaîne qui a été donné à wInst par le paramètre optionnel `/usercontext`. Si ce paramètre n'a pas été utilisé la chaîne retournée est vide.

[[opsi-winst-string-functions-reg]]
==== Lire des valeurs du registre Windows et transformer les valeurs en format Registre

*  `GetRegistryStringValue (`<chaîne>`)` +
essaie d'interpréter la valeur chaîne passée comme une expression de format +
'[KEY] X' +
Ensuite, la fonction tente d'ouvrir la clé de registre `KEY`, et, au cas où il réussit, à lire et retourner la valeur de chaîne qui appartient au nom de la variable de registre `X` . 

Exemple
[source,winst]
----
GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] Shell")
----

généralement donne  "Explorer.exe", la valeur par défaut du programme shell de Windows.

S'il n'y a pas de clé de registre `KEY` ou la variable `X` n'existe pas la fonction produit un message d'avertissement dans le fichier journal et retourne la chaîne vide.

Par exemple:
Si nous avons fait une 'standard entry' avec la valeur +standard entry+ à la clé +HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0+, nous l'obtiendrons avec
[source,winst]
----
Set  $CompValue$ = GetRegistryStringValue32 ("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0]")
----

le journal suivant:
[source,winst]
----
Registry started with redirection (32 Bit)
Registry key [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0]  opened
Key closed
The value of the variable "$CompValue$" is now: "standard entry"
----


*  `GetRegistryStringValue32(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValue64(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValueSysNative(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>


*  `RegString(`<chaîne>`)` +
est utile pour transformer les noms de chemin dans le format qui est utilisé dans le Registre Windows. La barre oblique inverse est dupliqué. Par exemple, +
[source,winst]
----
RegString ("c:\windows\system\") 
----
donne +
'"c:\\windows\\system\\"'

[[opsi-winst-string-functions-ini]]
==== Lecture des valeurs de propriété

Pour des raisons historiques, Il y a trois fonctions pour la lecture des valeurs des fichiers de configuration qui ont le format de fichier ini. Depuis opsi 3.0 les propriétés de produits spécifiques sont récupérées à partir du démon de configuration de OPSI (qui peut les récupérer à partir d'un fichier de configuration ou de tout autre back-end conteneur de données).

En détail: +
Format de fichier Ini signifie que le fichier est un fichier texte et est composé de "sections" chacune contenant des paires de valeurs clés:
[source,winst]
----
[section1]
Varname1=Valeur1
Varname2=Valeur2
...
[section2]
...
----

La fonction la plus générale lit la valeur appartenant à une certaine clé dans une certaine section de certaines fichier INI. Tout paramètre peut être donnée comme une expression chaîne arbitraire:

*  `GetValueFromInifile (`<FICHIER>, <SECTION>, <CLE>, <VALEUR PAR DEFAUT>`)` +
La fonction tente d'ouvrir le fichier ini `FICHIER`, récupérer la `SECTION` demandée et recherche la valeur spécifiée appartenant à la `CLE` que de la fonction retournera. Si aucune de ces opérations échouent `VALEUR PAR DEFAUT` est retourné.

La deuxième fonction emprunte sa syntaxe du format de fichier INI même, et peut parfois être plus facile à utiliser. Mais depuis cette syntaxe compliquée tourne dans des circonstances plus général, elle est obsolète. La syntaxe lit:

*  `GetIni (` <expression de chaîne> [ <séquence de caractères> ] <séquence de caractères> `)` +
(Obsolète) L'<expression de chaîne> est interprété comme nom de fichier, la premiere <séquence de caractères> comme nom de la section, la seconde comme nom de clé.  

[[opsi-winst-string-functions-prodprop]]
==== Lecture des Propriétés du produit

*  `GetProductProperty (` <Nom de la propriété>, <Valeur par défaut>`)` +
quand $PropertyName$ et $DefaultValue$ sont des expressions de chaîne. 
Si wInst est connecté au service de configuration OPSI la propriété produit est récupéré du service. 
Si wInst n'est pas connecté au service ou pour d'autres raisons, l'appel échoue, le donné +<Valeur par défaut>+ sera retourné.

Les propriétés du produit peuvent être utilisé pour configurer des variantes de l'installation.

Par exemple l'installation OPSI du viewer réseau UltraVNC peut être configuré en utilisant les options 

* viewer = <yes> | <no>

* policy = <factory_default> | 

Les branches de script d'installation, selon les valeurs choisies pour ces options, peuvent être récupérées par 
[source,winst]
----
GetProductProperty("viewer", "yes")
GetProductProperty("policy", "factory_default")
----


*  `IniVar(`<Nom de la propriété>`)` +
(obsolète: use GetProductProperty)

[[opsi-winst-string-functions-hosts]]
==== Récupération de données à partir de etc/hosts

*  `GetHostsName(`<chaîne>`)` +
retourne le nom d'hôte pour une adresse IP donnée car elle est déclarée dans le fichier hosts local. Si le système d'exploitation est "Windows_NT" (en fonction de la variable d'environnement de l'OS)  "%systemroot%\system32\drivers\etc\"  est supposé l'emplacement du fichier hôte, autrement  "C:\Windows\".

*  `GetHostsAddr(`<chaîne>`)` +
indique l'adresse IP à un hôte donné ou à un nom d'alias.

[[opsi-winst-string-functions-handling]]
==== Traitement des chaîne

*  `ExtractFilePath(`<chaîne>`)` +
interprète la valeur chaîne passée comme nom de fichier ou chemin et retourne la partie chemin (la chaîne jusqu'à la dernière "\", y compris).

*  `StringSplit (`VALEUR CHAÎNE1, VALEUR CHAÎNE2, INDEX`)` +
(obsolète: utilisez `splitString` / `takestring`)

*  `takeString(`<index>,<liste>`)` +
revient d'une liste de chaînes <liste> la chaîne avec l'indice <index>. +
Souvent utilisé en combinaison avec `splitstring`:
`takeString(`<index>, `splitString(`<chaîne1>, <chaîne2>`)` +
(voir aussi <<opsi-winst-stringlist>>). +
Le résultat est produit en coupant <chaîne1> où chaque tranche est délimité par une occurrence de <chaîne2>, puis en prenant la tranche avec l'index <index> (où le décompte commence avec 0).

Exemple:
[source,winst]
----
takeString(3, splitString ("\\server\share\directory",  "\"))
----

retourne '"share"', +
la chaîne donnée est découpé au "\" et retourne la liste de chaînes: +
Index 0 - "" (chaîne vide), car il n'y a rien avant le premier "\" +
Index 1 - "" (chaîne vide), car il n'y a rien avant le deuxième "\" +
Index 2 - "server" +
Index 3 - "share" +
Index 4 - "directory"

`takestring` compte vers le bas, si l'indice est négatif, à commencer par le nombre d'éléments. Par conséquent,
[source,winst]
----
takestring(-1, $list1$)
----

désigne le dernier élément de la liste de chaîne $list1$.

*  `SubstringBefore(`<chaîne1>, <chaîne2>`)` +
(obsolète: utilisez `splitString` / `takestring`)
donne la séquence de caractères de chaîne1 jusqu'au début de la chaîne2. +
Exemple:
[source,winst]
----
SubstringBefore ("C:\programme\staroffice\program\soffice.exe", "\program\soffice.exe")
----
retourne '"C:\programme\staroffice"'.

*  `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne de <liste> qui contient <chaîne de recherche>. +
Retourne une chaîne vide si aucune chaîne correspondant est trouvé.

*  `Trim(`<chaîne>`)` +
coupe les blancs entourant <chaîne>.

*  `HexStrToDecStr(`<chaîne>`)` +
Renvoie la représentation décimale de la chaîne d'entrée si cela a été la représentation hexadécimale d'un entier. Les caractères en tête comme '0x' ou '$' seront ignorés. En cas d'erreur de conversion, la fonction retourne une chaîne vide.

*  `DecStrToHexStr(`<chaîne>`)`+
Renvoie la représentation hexadécimale de la chaîne d'entrée si cela a été la représentation décimale d'un entier. En cas d'erreur de conversion, la fonction retourne.

*  `base64EncodeStr(`<chaîne>`)` +
renvoie la valeur codée en base64 de <chaîne>.

*  `base64DecodeStr(`<chaîne>`)` +
renvoie la valeur décodées en base64 de <chaîne>.

==== Autres fonctions de chaîne

*  `RandomStr` + 
renvoie une chaîne aléatoire de longueur 10, où les lettres en majuscule, les lettres minuscules et les chiffres sont mélangés (pour créer des mots de passe). Plus exactement: 2 caractères minuscules, 2 caractères majuscules, 2 caractères spéciaux et 4 chiffres. Les caractères possibles spéciales sont: +
'!','$','(',')','*','+','/',';','=','?','[',']','{','}','ß','~','§','°'

*  `CompareDotSeparatedNumbers(`<chaîne1>, <chaîne2>`)` +
compare deux chaînes de la forme <nombre>.<nombre>[.<nombre>[.<nombre>]] +
Il retourne "0" si les chaînes sont égales, "1" si <chaîne1> est plus élevé et "-1" si <chaîne1> est inférieur à <chaîne2>.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedNumbers"
	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.31.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

entraîne le journal suivant:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedNumbers

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is equal to 1.2.3.4.5

Else
EndIf

Set  $string1$ = "1.2.31.4.5"
  The value of the variable "$string1$" is now: "1.2.31.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.31.4.5 is higher then 1.2.13.4.5

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is lower then 1.2.13.4.5

Else
EndIf
----

*  `CompareDotSeparatedStrings (`<chaîne1>, <chaîne2>`)` +
compare deux chaînes de la forme <chaîne>.<chaîne>[.<chaîne>[.<chaîne>]] +
Il retourne "0" si les chaînes sont égales, "1" si <chaîne1> est plus élevé et "-1" si <chaîne1> est inférieure à <chaîne2>. La fonction n'est pas sensible à la casse.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.A.B.C.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.cb.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.ab.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.13.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

entraîne le journal suivant:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedStrings

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.A.B.C.3"
  The value of the variable "$string2$" is now: "1.A.B.C.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.A.B.C.3

Else
EndIf

Set  $string1$ = "1.a.cb.c.3"
  The value of the variable "$string1$" is now: "1.a.cb.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.cb.c.3 is higher then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.ab.c.3"
  The value of the variable "$string1$" is now: "1.a.ab.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.ab.c.3 is lower then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.2.13.4.5"
  The value of the variable "$string1$" is now: "1.2.13.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.13.4.5 is lower then 1.2.3.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is higher then 1.2.13.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf
----

[[opsi-winst-string-functions-license]]
==== (Chaîne-) Fonctions de gestion des licences

*  `DemandLicenseKey(`poolId [, productId [,windowsSoftwareId]]`)` +
demande au service OPSI via la fonction getAndAssignSoftwareLicenseKey pour une réservation d'une licence pour le client. +
Le pool à partir duquel les licences sont prises peut être explicitement donné par son ID ou est identifié par un ID du produit associé ou de l'ID du Software Windows (possible, si ces associations sont définies dans la configuration des licences). +
'poolId', 'productId', 'windowsSoftwareId' sont des chaînes (expressions de type chaîne). +
Si aucun 'poolId' est explicitement donnée, le premier paramètre doit être une chaîne vide  "". La même procédure se fait avec d'autres Ids ne pas donné explicitement. +
La fonction retourne la clé de licence qui est tirée du pool.

Exemples:
[source,winst]
----
set $mykey$ = DemandLicenseKey ("pool_office2007")
set $mykey$ = DemandLicenseKey ("", "office2007")
set $mykey$ = DemandLicenseKey ("", "", "{3248F0A8-6813-11D6-A77B}")
----

*  `FreeLicenseKey (`poolId [, productId [,windowsSoftwareId]]]`)` +
demande au service OPSI via la fonction freeSoftwareLicenseKey de libérer la licence actuelle de réservation.
La syntaxe est analogue à la syntaxe pour `DemandLicenseKey`

Exemple:
[source,winst]
----
DefVar $opsiresult$
set $opsiresult$ = FreeLicenseKey ("pool_office2007")
----

'$opsiresult$' devient la chaîne vide, si aucune erreur s'est produite, et, si une erreur survient, le texte d'info de l'erreur.

[[opsi-winst-string-functions-serviceerrors]]
==== Récupération Infos erreur des appels de service

*  `getLastServiceErrorClass` +
Renvoie, comme son nom l'indique, le nom de classe de l'information d'erreur du dernier appel de service. Si le dernier appel de service n'a pas produit une erreur la fonction retourne la valeur "None".

*  `getLastServiceErrorMessage` +
Renvoie la chaîne du message de la dernière information  d'erreur "None". +
Depuis la chaîne du message a plus de chances d'être changée, il est recommandé de baser la logique de script sur le nom de la classe.

Exemple:
[source,winst]
----
if getLastServiceErrorClass = "None"
    comment "kein Fehler aufgetreten"
endif
----

[[opsi-winst-stringlist]]
=== Fonctions de liste de chaînes et Traitement de liste de chaînes

Une liste de chaîne (ou une valeur de liste de chaînes) est une séquence de valeurs de chaîne. Pour ce genre de valeurs nous avons la variable de type `String list`. Elles sont définies par la déclaration

`DefStringList` <Nom de la variable>

Une valeur de liste de chaînes peut être affecté à la variable de liste de chaînes:

`Set` <Nom de la variable> `=` <StringListValue>

Les valeurs d'une liste de chaînes peuvent être données seulement comme résultat des expressions de chaîne. Il y a plusieurs façons de créer ou de capturer des listes de chaînes, et de nombreuses options pour les traiter, souvent donnant une nouvelles liste de chaînes. Elles sont présentées dans les paragraphes suivants. 

Pour les exemples suivants, nous déclarons une variable de liste de chaînes '$list1$':

[source,winst]
----
DefStringList $list1$
----

Si nous nous référons des variables nommées  String0, StringVal, .. on entend que ceux-ci représentent toutes les expressions de chaîne.

Nous commençons avec un type particulier et plutôt utile de listes de chaînes: 'maps' – également appelés hachages ou tableaux associatifs – qui se composent d'une ligne de la forme 'CLÉ'='VALEUR'. En fait, chaque 'map' devrait établir une fonction qui associe une 'VALEUR' à une 'CLÉ', et toute les 'CLÉ' devrait avoir lieu maximum une fois tant que première partie d'une ligne (alors différentes 'CLÉ's peuvent être associées avec les mêmes 'VALEUR').

[[opsi-winst-stringlist-maps]]
==== Informations sur Maps

*  `getMSVersionMap` +
récupér les informations sur le système d'exploitation et les écrit hacher dans une liste de chaînes map. +
Il y a les clés suivants:
* major_version
* minor_version
* build_number
* platform_id
* csd_version
* service_pack_major
* service_pack_minor
* suite_mask
* product_type_nr
* 2003r2

Les résultats de 'suite_mask' et 'product_type_nr' sont des entiers qui peuvent être bâtie par une opérations 'or' des valeurs suivantes.

product_type_nr
****
    0x0000001 (VER_NT_WORKSTATION)
    0x0000002 (VER_NT_DOMAIN_CONTROLLER)
    0x0000003 (VER_NT_SERVER)
****

SuiteMask
****
    0x00000001 (VER_SUITE_SMALLBUSINESS)
    0x00000002 (VER_SUITE_ENTERPRISE)
    0x00000004 (VER_SUITE_BACKOFFICE)
    0x00000008 (VER_SUITE_COMMUNICATIONS)
    0x00000010 (VER_SUITE_TERMINAL)
    0x00000020 (VER_SUITE_SMALLBUSINESS_RESTRICTED)
    0x00000040 (VER_SUITE_EMBEDDEDNT)
    0x00000080 (VER_SUITE_DATACENTER)
    0x00000100 (VER_SUITE_SINGLEUSERTS)
    0x00000200 (VER_SUITE_PERSONAL)
    0x00000400 (VER_SUITE_SERVERAPPLIANCE)
****

Exemple: +
Le code
[source,winst]
----
DefStringList $INST_Resultlist$
DefStringList $INST_Resultlist2$

message "getMSVersionMap"
comment "get value by winst function"
set $INST_Resultlist$ = getMSVersionMap
----

entraîne le journal suivant:
[source,winst]
----
message getMSVersionMap
comment: get value by winst function

Set  $INST_Resultlist$ = getMSVersionMap
    retrieving strings from getMSVersionMap [switch to loglevel 7 for debugging]
        (string   0)major_version=5
        (string   1)minor_version=1
        (string   2)build_number=2600
        (string   3)platform_id=2
        (string   4)csd_version=Service Pack 3
        (string   5)service_pack_major=3
        (string   6)service_pack_minor=0
        (string   7)suite_mask=256
        (string   8)product_type_nr=1
        (string   9)2003r2=false
----

[NOTE]
==============================
Infos de base pour getMSVersionMap

* http://msdn.microsoft.com/en-us/library/ms724385%28VS.85%29.aspx
* http://msdn.microsoft.com/en-us/library/dd419805.aspx
* http://msdn.microsoft.com/en-us/library/ms724833%28VS.85%29.aspx

==============================

*  `getFileInfoMap(`<NOM DE FICHIER>`)` +
récupère les informations de version intégré dans le fichier  NOM DE FICHIER et il écrit dans une liste de chaînes map.

En ce moment, il existe les clés,

* Comments
* CompanyName
* FileDescription
* FileVersion
* InternalName
* LegalCopyright
* LegalTrademarks
* OriginalFilename
* PrivateBuild
* ProductName
* ProductVersion
* SpecialBuild
* Language name <index>
* Language ID <index>
* file version with dots
* file version
* product version

Utilisation: Si l'on définis et appelle
[source,winst]
----
DefStringList FileInfo
DefVar $InterestingFile$
Set $InterestingFile$ = "c:\program files\my program.exe"
set  FileInfo = getFileInfoMap($InterestingFile$)
----

nous obtenons la valeur associée à la clé "FileVersion" par l'appel 
[source,winst]
----
DefVar $result$
set $result$ = getValue("FileVersion", FileInfo)
----

(pour la fonction getValue voir la section <<opsi-winst-stringlist-getstring>>).

Exemple: +
Le code:
[source,winst]
----
set $InterestingFile$ = "%winstdir%\winst.exe"
if not (FileExists($InterestingFile$))
	set $InterestingFile$ = "%winstdir%\winst32.exe"
endif
set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
----

produit la sortie journal:
[source,winst]
----
Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]
        (string   0)Language name 0=Deutsch (Deutschland)
        (string   1)Language ID 0=1031
        (string   2)file version=1125942857039872
        (string   3)file version with dots=4.10.8.0
        (string   4)product version=1125942857039872
        (string   5)Comments=
        (string   6)CompanyName=uib gmbh (www.uib.de)
        (string   7)FileDescription=opsi.org
        (string   8)FileVersion=4.10.8.0
        (string   9)InternalName=
        (string  10)LegalCopyright=uib gmbh under GPL
        (string  11)LegalTrademarks=opsi
        (string  12)OriginalFilename=
        (string  13)PrivateBuild=
        (string  14)ProductName=opsi-winst
        (string  15)ProductVersion=4.0
        (string  16)SpecialBuild=
----

*  `getLocaleInfoMap` +
récupère les informations du système sur la localisation et l'écrit dans une liste de chaînes map.

En ce moment, il existe les clés:

* language_id_2chars (version de deux lettres du nom de la langue par défaut du système)
* language_id (version de trois lettres, y compris les sous-type de la langue)
* localized_name_of_language
* English_name_of_language
* abbreviated_language_name
* native_name_of_language
* country_code
* localized_name_of_country
* English_name_of_country
* abbreviated_country_name
* native_name_of_country
* default_language_id
* default_language_id_decimal
* default_country_code
* default_oem_code_page
* default_ansi_code_page
* default_mac_code_page
* system_default_language_id	Hexadecimal Windows locale Id
* system_default_posix		Language_Region (Posix Style)
* system_default_lang_region	Language-Region (BCP 47 Style)

La clé system_default donne des informations sur la langue de l'OS installé. Les autres clés donnent des informations sur la localisation de l'interface graphique.

Exemple: +
Le code:
[source,winst]
----
message "Locale Infos"
set  $INST_Resultlist$ = getLocaleInfoMap
----

produit par exemple le journal:
[source,winst]
----
message Locale Infos

Set  $INST_Resultlist$ = getLocaleInfoMap
    retrieving strings from getLocaleInfoMap [switch to loglevel 7 for debugging]
        (string   0)language_id_2chars=DE
        (string   1)language_id=DEU
        (string   2)localized_name_of_language=Deutsch (Deutschland)
        (string   3)English_name_of_language=German
        (string   4)abbreviated_language_name=DEU
        (string   5)native_name_of_language=Deutsch
        (string   6)country_code=49
        (string   7)localized_name_of_country=Deutschland
        (string   8)English_name_of_country=Germany
        (string   9)abbreviated_country_name=DEU
        (string  10)native_name_of_country=Deutschland
        (string  11)default_language_id=0407
        (string  12)default_language_id_decimal=1031
        (string  13)default_country_code=49
        (string  14)default_oem_code_page=850
        (string  15)default_ansi_code_page=1252
        (string  16)default_mac_code_page=10000
        (string  17)system_default_language_id=0407
        (string  18)system_default_posix=de_DE
        (string  19)system_default_lang_region=de-DE
----

Utilisation: Si l'on définis et appelle
[source,winst]
----
DefStringList $languageInfo$
set  $languageInfo$ = getLocaleInfoMap
----

nous obtenons la valeur associée à la clé "language_id_2chars" par l'appel 
[source,winst]
----
DefVar $result$
set $result$ = getValue("language_id_2chars", $languageInfo$)
----

(pour la fonction getValue voir la section <<opsi-winst-stringlist-getstring>>). Nous pouvons maintenant écrire des scripts en utilisant une construction comme
[source,winst]
----
if getValue("language_id_2chars", languageInfo) = "DE"
    ; installiere deutsche Version
else 
   if getValue("language_id_2chars", languageInfo) = "EN"
    ; installiere englische Version
   endif
endif 
----

[NOTE]
==============================

Infos de base pour getLocaleInfoMap:

* http://msdn.microsoft.com/en-us/library/cc233968.aspx
* http://msdn.microsoft.com/en-us/library/0h88fahh.aspx
* bcp 47 validator: +
http://schneegans.de/lv/?tags=de-de-1996&format=text

* http://www.iana.org/assignments/language-subtag-registry
* http://www.the-localization-tool.com/?p=698

==============================

*  `getLocaleInfo` +
(obsolète): utilisez `GetLocaleInfoMap` .

[[opsi-winst-stringlist-create-by-value]]
==== Produire des listes de chaînes à partir de chaînes

*  `createStringList (`chaîne0, chaîne1 ,... `)` +
forme une liste de chaînes à partir des valeurs des expressions chaîne énumérés. Par exemple, avec
[source,winst]
----
set $list1$ = createStringList ('a','b', 'c', 'd')
----

nous obtenons une liste des quatre premières lettres de l'alphabet. 

Les deux fonctions suivantes produisent une liste de chaînes en séparant des chaîne:

*  `splitString (`<chaîne1>, <chaîne2>`)` +
génère la liste partielle des chaînes de <chaîne1> (y compris les chaînes vides) before resp. between the occurences of <chaîne2>.  E.g., 
[source,winst]
----
set $list1$ = splitString ("\\server\share\directory",  "\")
----
définit la liste  +
'"", "", "server", "share", "directory"'

*  `splitStringOnWhiteSpace (`<chaîne>`)` +
coupes StringVal par le "blancs" dedans. Par exemple 
[source,winst]
----
set $list1$ = splitString ("Status   Lokal     Remote         Netzwerk")
----
produit la liste +
'"Status", "Lokal", "Remote", "Netzwerk"' +
peu importe combien d'espaces ou des tabulations constituent l'espace blanc entre les mots.

[[opsi-winst-stringlist-create-by-file]]
==== Chargement des lignes d'un fichier texte dans une liste de chaînes

*  `loadTextFile (`<nom de fichier>`)` +
lit le fichier <nom de fichier> et génère la liste de chaînes, qui contient toutes les lignes du fichier.


*  `loadUnicodeTextFile (`<nom de fichier>`)` +
lit le fichier texte unicode <nom de fichier> et génère la liste de chaînes, qui contient toutes les lignes du fichier. +
Par cet appel, les chaînes sont converties dans le code par défaut du système 8 bits.

*  `getSectionNames (`<nom de fichier>`)` +
interprète le fichier spécifié comme un fichier ini, regardant pour la liste toutes les lignes de la forme +
'[<SectionName>]' +
et renvoie les noms de section (sans parenthèses).

[[opsi-winst-stringlist-getstring]]
==== Valeurs de chaîne simple générés à partir des listes de chaînes
 
*  `composeString (`<liste de chaînes>, <liens de chaîne>`)` +
Grâce à cette fonction, les éléments d'une liste chaîne peuvent être collés les uns aux autres, médiée par un "colle de chaîne". +
Par exemple si '$list1$' représente la liste 'a', 'b', 'c', 'd', 'e' +
avec 
[source,winst]
----
$line$ = composeString ($list1$, " | ")
----
nous attribuons la valeur  '"a | b | c | d | e".' à '$line$'.

*  `takeString(`<index>,<liste>`)` +
Par exemple si  $list1$ représente la liste des cinq premières lettres de l'alphabet, avec +
[source,winst]
----
takeString (2, $list1$)
----
on obtient la chaîne "c" (puisque le comptage de liste commence par 0). +
Les valeurs négatives de l'indice vont vers le bas de la valeur de comptage de liste. Par exemple, 
[source,winst]
----
takeString (-1, $list1$)
----
retourne le dernièr élément de la liste, qui est  "e".

*  `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne de la liste qui contient la <chaîne de recherche>. +
Retourne une chaîne vide si aucune chaîne correspondant n'a été trouvé.

*  `getValue (`<clé>, <liste>`)` +
Cette fonction tente d'interpréter une liste de chaînes comme liste de lignes de la forme 
'clé=valeur' +
Il examine la première ligne, où la chaîne <clé> est suivi par le signe égal, et renvoie le reste de la ligne ('valeur', la chaîne qui commence après le signe égal). S'il n'y a pas de ligne de raccord, elle retourne la chaîne 'NULL'. +
La fonction est requise pour l'utilisation des fonctions `getLocaleInfoMap` et `getFileVersionMap` (voir la Section <<opsi-winst-stringlist-maps>>).

*  `count (`<liste>`)` +
renvoie le nombre d'éléments de la liste de chaînes <liste> en tant que chaîne. +
par exemple pour $list1$ composé comme +
'a', 'b', 'c', 'd', 'e' +
`count ($list1$)` a la valeur "5".

[[opsi-winst-stringlist-create-by-section]]
==== Produire des listes de chaîne à partir des sections winst

*  `retrieveSection (`nom de la section`)` +
donne les lignes de la section spécifiée comme liste de chaînes.

*  `getOutStreamFromSection (`nom de la section`)` +
invoque la section et – à ce moment mis en œuvre uniquement pour les appels `DosInAnIcon` (`ShellInAnIcon`),`ExecWith` et `ExecPython` – capture la sortie standard et des erreurs de la commande invoquée pour les écrire dans une liste de chaînes. Par exemple: +
[source,winst]
----
set $list$ = getOutStreamFromSection ('DosInAnIcon_netuse')

[DosInAnIcon_netuse]
net use
----
`$list1$` contient, parmi les quelques trucs environnantes, la liste de toutes les partages montée d'un PC. 


*  `getReturnListFromSection (`nom de la section`)` +
Pour certains types de section - à ce moment mis en œuvre uniquement pour les sections `XMLPatch` et `opsiServiceCall` -  il y a une déclaration spécifique `return` qui donne un résultat de l'exécution de la section (supposé être de type liste de chaîne).  +
Par exemple nous pouvons utiliser l'instruction
[source,winst]
----
set list1 = getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----
pour obtenir une liste de noeud spécifique du fichier XML `mimetypes.rdf`. (Plus d'infos pour les sections XMLPatch dans <<opsi-winst-xmlpatch>> du manuel). +
Ou la liste des clients OPSI est produite par la référence à un appel de service OPSI: +
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")

[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

[[opsi-winst-stringlist-transform]]
==== Transformer les listes de chaînes

*  `getSubList (`<index de démarrage>, <index de fin>, <liste> `)` +
retourne une liste partielle d'une liste donnée. +
Par exemple, si 'liste' représente la liste des lettres 'a', 'b', 'c', 'd', 'e', par la déclaration:
[source,winst]
----
set $list1$ = getSubList(1 : 3, $list$)
----
on obtient la liste partielle 'b', 'c', 'd' . L'index de démarrage ainsi que l'index de fin doivent être interprétées comme l'indice du premièr et du dernièr éléments de la liste incluse. Le comptage commence par 0. +
L'index de début par défaut est 0, l'indice de fin par défaut est l'indice du dernier élément de la liste. +
Par conséquent, (pour la list1 définie ci-dessus) la commande +
[source,winst]
----
set $list1$ = getSubList(1 : , $list$)
----
donne la liste 'b', 'c', 'd', 'e'. 
[source,winst]
----
set $list1$ = getSubList(:, $list$)
----
produit une copie de la liste originale. +
Il est possible de compter à rebours afin de déterminer le dernier indice: 
[source,winst]
----
set $list1$ = getSubList(1 : -1, $list$)
----
définit la liste des éléments à commencer par le premièr et se terminant du deuxième au dernier élément de la liste –  dans l'exemple ci-dessus on obtient à nouveau la liste 'b', 'c', 'd'.

*  `getListContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne à partir de <liste> qui contient la <chaîne de recherche>. Retourne une chaîne vide si la <chaîne de recherche> n'est pas trouvée.

*  `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
Retourne la première chaîne de <liste> qui contient la <chaîne de recherche>. + Retourne une chaîne vide si la <chaîne de recherche> n'est pas trouvée.

*  `addtolist(`<liste>,<chaîne>`)` +
Ajoute <chaîne> à la liste <liste>.

*  `addlisttolist(`<liste1>,<liste2>`)` +
Ajoute la liste <liste2> à la liste <liste1>.

*  `reverse (`<liste>`)` +
Produit la liste inversée, +
si  $list$ est 'a', 'b', 'c', 'd', 'e', avec +
[source,winst]
----
set $list1$ = reverse ($list$)
----
nous obtenons la $list1$ 'e', 'd', 'c', 'b', 'a'.

[[opsi-winst-stringlist-iteration]]
==== Itération à travers les listes de chaînes

Une utilisation importante de listes de chaînes est basé sur la possibilité que le script s'exécute à travers tous les éléments d'une liste exécutant quelques opérations sur chaque élément de la chaîne.

La syntaxe pour définir cette répétition est:

*  `for` %s% `in` <liste> `do` <une déclaration | une sous-section>

Cette expression définit localement une variable de chaîne %s% qui prend une à une les valeurs des éléments de la liste.
<une déclaration> peut être n'importe quelle instruction unique qui peut exister dans une section primaire ou (et plus intéressant) il peut être un appel à une sous-section. L'indice d'itération définis localement %s% existe dans l'ensemble du contexte de la déclaration, en particulier dans la sous-section si la déclaration est un appel à la sous-section. 

CAUTION: Le mécanisme de remplacement pour %s% fonctionne toujours comme ça pour les constantes:  Le nom de la variable est remplacée par les valeurs des éléments. Si l'on parcour une liste 'a','b','c' et l'indice d'itération est nommé %s%, nous obtenons pour %s% un à un  a, b, c  –   pas les valeurs de la chaîne. Pour reproduire la liste originale des éléments nous devons enfermer %s% entre guillemets.

Exemple: Que $list1$ soit la liste  'a', 'b', 'c', 'd', 'e', et $line$ une variable chaîne. La déclaration  
[source,winst]
----
for %s% in $list1$ do   set $line$ = $line$ + "%s%"
----
parcourt les éléments de la liste interne exécutant
[source,winst]
----
$line$ = $line$ + "a"
$line$ = $line$ + "b"
$line$ = $line$ + "c"
$line$ = $line$ + "d"
$line$ = $line$ + "e"
----
A la fin la ligne a la valeur 'abcde' . Si nous avons omis les guillemets autour de %s% nous obtiendrions une erreur de syntaxe pour chaque étape d'itération.

Remarque: La variable note n'est valable que dans la procédure appelée directement. Si elle est nécessaire dans les sous-programmes de celui-ci sa valeur doit être transféré à une variable globale.

[[opsi-winst-special-commands]]
=== Commandes spéciales

*  `Killtask` <processus>
tente d'arrêter tous les processus qui exécutent le programme nommé par l'expression de chaîne. +
Par exemple
[source,winst]
----
killtask "winword.exe"
----

[[opsi-winst-commands-information]]
=== Commandes d'information sur l'utilisateur et l'interaction utilisateur

*   `Message` <expression chaîne> +
bzw. +
`Message` = <séquence de caractères> +
lets  wInst  display the value of the String expression resp. the  sequence of chars in the batch window in the top information line. Le texte est maintenu aussi longtemps qu'aucune nouveau `message` est fixé. +
Exemple:
[source,winst]
----
Message "Installation von "+$productid$
----

*  `ShowMessageFile` <nom de fichier> +
interprète l'expression de chaîne comme nom de fichier texte, essaie de lire le texte et de l'afficher dans une fenêtre d'informations utilisateur. L'exécution s'arrête jusqu'à ce que l'utilisateur confirme la lecture.  Par exemple par une commande comme 
[source,winst]
----
ShowMessageFile "p:\login\day.msg"
----
on peut réaliser un "Message du jour".

*  `ShowBitMap` [<nom de l'image>] [<inscription>] +
place l'image dénotée par <nom de l'image> (dans le format BMP, JPEG ou PNG, taille 160x160 pixel) et montre l'inscription.  
<nom de l'image> et <inscription> sont des expressions de chaîne. +
Exemple: +
[source,winst]
----
ShowBitmap "%scriptpath%\" + $ProductId$ + ".png"  "$ProductId$"
----

*  `comment` <chaîne> ou `comment` = <const chaîne> +
writes the value of the String expression resp. the sequence of  characters into the log file.

* `LogError` <chaîne> ou `LogError` = <const chaîne> +
écrit des messages d'erreur supplémentaire dans le fichier journal et incrémente le compteur d'erreurs d'un.

* `LogWarning` <chaîne> ou `LogWarning` = <const chaîne> +
écrit des messages d'avertissement supplémentaire dans le fichier journal et incrémente le compteur d'avertissement d'un.

*  `Pause` <chaîne> ou `Pause` = <const chaîne> +
afficher le texte donné comme une expression chaîne ou comme une séquence de caractères dans une fenêtre d'information en attente jusqu'à ce que l'utilisateur confirme la poursuite. 

*  `Stop` <chaîne> ou `stop` = <const chaîne> +
arrêt l'exécution du programme si l'utilisateur le confirme. The String expression resp. the (possibly empty) sequence of chars explain to the user what is supposed to be stopped.

*   `sleepSeconds` <entier> +
Met en pause l'exécution du programme pour <entier> secondes.

*   `markTime` +
établit un horodatage pour l'heure du système actuel et l'enregistre. 

*  `diffTime` +
enregistre le temps écoulé depuis le dernier `marktime`.

[[opsi-winst-commands-if-else]]
=== Instructions conditionnelles (déclarations if)

Dans les sections primaires, l'exécution d'une instruction ou d'une séquence d'instructions peut être subordonnée à certaines conditions.

Exemple
[source,winst]
----
;Quelle version de Windows?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----

[[opsi-winst-commands-if-else-syntax]]
==== Syntaxe générale

La syntaxe de l'instruction `if` complète est: +
`if` <condition> +
  <séquence d'instructions> +
`else` +
  <séquence d'instructions> +
`endif`

La partie `else` peut être omise.

Les déclarations `if` peuvent être imbriquées. A savoir, dans la séquence d'instructions qui dépendent d'une clause if (peu importe si if est à l'intérieur d'un if ou d'une partie else) une autre déclaration if peut se produire. 

<condition> est une <expression booléenne> . Une expression booléenne (ou logique) peut être construite comme une (chaîne) comparaison des valeurs, par les opérateurs booléens, ou par certains appels de fonctions qui permettent d'évaluer à vrai ou faux. Jusqu'à présent, ces valeurs booléennes ne peuvent pas être explicitement représentée dans un script wInst).

[[opsi-winst-commands-if-else-bool-functions]]
==== Les expressions booléennes

La comparaison de chaînes (ce qui est une expression booléenne) a la forme +
+<expression de chaîne> <signe de comparaison> <expression de chaîne>+ +
où <signe de comparaison> est l'un des signes +
`<`  `<=`  `=`  `>=`  `>`

Les comparaisons de chaînes sont des cas indépendant dans wInst. 

L'inégalité doit être exprimée par un `NOT()` expression qui est présenté ci-dessous.

Il y a ainsi une expression de comparaison pour comparer des chaînes de chiffres (entier). Si aucun d'entre eux ne peuvent pas être convertie en chiffres, un erreur sera indiquée. +
Cette expression de comparaison de chiffres a la même forme que la comparaison des chaînes mais avec un préfixe INT du signe de comparaison: +
+<expression de chaîne> INT<signe de comparaison> <expression de chaîne>+ +
Ainsi, nous pouvons construire des expressions comme
[source,winst]
----
if $Nom1$ INT<= $Nom2$
----

ou
[source,winst]
----
if $chiffre1$ INT>= $chiffre2$
----

Les opérateurs booléens sont `AND`, `OR`, et `NOT()` (Peu importe la casse). Si  b1, b2 et b3 sont des expressions booléennes des expressions combinées +
b1 `AND` b2 +
b1 `OR` b2 +
`NOT(` b3 `)` +
sont des expressions booléennes ainsi dénotant respectivement la conjonction (`AND`), la disjonction (`OR`) et la négation (`NOT`).

Une expression booléenne peut être mis entre parenthèses (produisant une nouvelle expression booléenne avec la même valeur).

Les règles communes de priorité des opérateurs booléens ("and" avant "or") à cet instant ne sont pas appliqué.  Une expression avec plus d'un opérateur est interprétée de gauche à droite. Pour plus de clarté, dans une expression booléenne qui combine les opérateurs `AND` et `OR`  les parenthèses doivent être employés, par exemple nous devrions écrire explicitement
b1 `OR` (b2 `AND` b3) +
ou +
(b1 `OR` b2) `AND` b3 +
Le deuxième exemple décrit ce que serait exécuté s'il n'y avait pas de parenthèses - alors que l'interprétation commune irait comme l'autre ligne indique.

Les opérateurs booléens peuvent être conçus comme des fonctions de valeur Booléenne spéciaux (l'opérateur de négation le démontre très clairement).

Il y a quelques fonctions booléenne en plus mis en œuvre. Chaque appel d'une telle fonction constitue une expression booléenne ainsi:

*   `FileExists`(<nom de fichier>) +
Renvoie 'true' si le fichier ou le répertoire notée existe autrement 'false'.  

*  `FileExists32`(<nom de fichier>)	voir <<opsi-winst-64bit,Chapter 64 Bit support>>

*  `FileExists64`(<nom de fichier>)	voir <<opsi-winst-64bit,Chapter 64 Bit support>>

*  `FileExistsSysNative`(<nom de fichier>) voir <<opsi-winst-64bit,Chapter 64 Bit support>>

*  `LineExistsIn`(<ligne>, <nom de fichier>) +
Renvoie 'true' si le fichier texte désigné par <nom de fichier> contient une ligne tel que spécifié dans le premier paramètre, où chaque paramètre est une expression chaîne. Sinon (ou si le fichier n'existe pas) il renvoie 'false'.

*  `LineBeginning_ExistsIn`(<chaîne>, <nom de fichier>)  +
Renvoie 'true' si il y a une ligne qui commence par <chaîne> dans le fichier texte désigné par <nom de fichier> (chaque paramètre étant une expression chaîne). Sinon (ou si le fichier n'existe pas) il renvoie 'false'.

*  `XMLAddNamespace`(<nom de fichier XML>, <nom de l'élément XML>, <XMLnamespace>) +
insère une définition XML namespace dans le premier élément XML avec le nom donné (si non existant). Il restitue si une insertion a eu lieu. (La section patch XML de wInst a besoin de la définition de namespace.) +
The file must be formatted that an element tag has no line breaks in it.  
Pour un exemple, voir la section recettes <<opsi-winst-cookbook-xmlnamespace>>. 

*  `XMLRemoveNamespace`(<nom de fichier XML>, <nom de l'élément XML>, <XMLnamespace>)  +
supprime la définition XML namespace à partir de XML element. Il restitue si un retrait a eu lieu. Nous avons besoin de cela pour simuler que le fichier original reste inchangé. Pour un exemple, voir la section recettes <<opsi-winst-cookbook-xmlnamespace>>.

*  `HasMinimumSpace`(<Nom du disque>, <Capacité>) +
renvoie vrai si au moins une capacité reste sur le disque  <Nom du disque>.  <Capacité> ainsi que  <Nom du disque> syntaxiquement sont expressions de chaîne. La capacité peut être donné comme une chiffre sans spécification d'unité (ensuite interprété comme octets) ou avec les unité "kB", "MB", or "GB" (la casse est indépendante). +
Exemple:
[source,winst]
----
if not (HasMinimumSpace ("%SYSTEMDRIVE%", "500 MB"))
  LogError "Not enough space on %SystemDrive%, 500MB on drive %SystemDrive% needed"
  isFatalError
endif
----

*  `opsiLicenseManagementEnabled` +
Renvoie 'true' si le module de gestion des licences OPSI est activé.

[[opsi-winst-commands-subcall]]
=== Appels de Sous-programme

Les déclarations dans les sections primaires qui désignent des instructions déclaré ailleurs sont des appels de sous-programme.,

[source,winst]
----
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----
Dans cet exemple la déclaration:
[source,winst]
----
sub_install_winXP
----
the '[sub_install_winXP]', welche dann im Skript an anderer Stelle nachzulesen ist als
[source,winst]
----
[sub_install_winXP]
Files_Kopieren_XP
WinBatch_SetupXP
----

Par exemple, la déclaration 
sub_install_winXP
"appelle" la section intitulée [sub_install_winXP] qui est placé quelque part ailleurs dans le script. Par exemple nous pouvons avoir
[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP
Generally, there are three ways to place the referred instructions:
(1) The most common target of  a sub program call is some other internal section in the very script file where the calling statement is placed (as in the example).
(2) We may put the referred instructions into another file which serves as an external section.
(3) Any String list can be used as list of instructions for a sub program call.
We describe the syntax of sub program calls in detail:

Anweisungen in primären Sektionen, die auf einen Programmtext an anderer Stelle verweisen, sollen hier Unterprogramm- oder Prozeduraufrufe heißen.
[source,winst]
----
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----
So "ruft" in obigem Beispiel die Anweisung in der `Actions`-Sektion
[source,winst]
----
sub_install_winXP
----
die Sektion '[sub_install_winXP]', welche dann im Skript an anderer Stelle nachzulesen ist als
[source,winst]
----
[sub_install_winXP]
Files_Kopieren_XP
WinBatch_SetupXP
----

Weil es sich in diesem Beispiel um eine `Sub`-Sektion handelt, also immer noch um eine primäre Sektion, kann in ihr wiederum auf weitere Sektionen verwiesen werden, in diesem Fall auf die Sektionen '[Files_Kopieren_XP]' und '[WinBatch_Setup_XP]'.

Generell gibt es drei Wege um die genannten Anweisungen zu platzieren:

. Der gebräuchlichste Ort für den Aufruf eines `Sub`-Sektion ist eine weitere interne Sektion im Skript, wo die aufgerufene Befehle platziert werden (wie in dem Beispiel).

. Die bezeichneten Befehle können auch in einer andere Datei untergebracht werden, welche als externe Sektion läuft.

. Jede String-Liste kann als eine Befehlsliste für einen Sub-Programm Aufruf benutzt werden.

Zur Syntax der Sub-Programm Aufrufe im einzelnen:

[[opsi-winst-commands-subcall-components]]
==== Komponenten eines Unterprogrammaufrufs

Formal kann die Syntax wie folgt aufgerufen werden +
'<proc. type>(<proc. name> | <External proc. file> | <Stringlisten Funktion> )'

Diese Ausdrücke können durch einen oder mehrere Parameter ergänzt werden (ist vom Ablauftyp abhängig). 

Das bedeutet:  Ein Ablauf besteht aus drei Hauptbereichen.

Der erste Teil ist der Unterprogramm Typnamen. +
Beispiele für Typennamen sind `Sub` (Aufruf einer primären Sektion bzw. eines Unterprogramms des primären Typs) sowie `Files` und `WinBatch` (diese Aufrufe sind speziell für die zweite Sektion). +
Den kompletten Überblick über die existierenden `Sub`-Programmtypen sind am Anfang von  <<opsi-winst-commands-subcall,Kapitel "Aufrufe von Unterprogrammen">> genauer beschrieben.

Der zweite Teil bestimmt, wo und wie die Zeilen des Subprogramms gefunden werden. Dazu gibt es zwei Möglichkeiten:

. Das Sub-Programm ist eine Zeilenabfolge, die im sich ausführbaren Bereich des '{opsi-winst}' Skripts als interne Sektion befindet. Es wird ein eindeutiger Sektionsname (bestehend aus Buchstaben, Zahlen und einigen Sonderzeichen) hinzugefügt, um den Programmtyp näher zu beschreiben (ohne Leerzeichen). +
z.B. +
'sub_install_winXP' +
oder +
'files_copy_winXP' +
Sektionsnamen sind case insensitive wie jeder andere String. 

. Wenn der Programmtyp alleine steht, wird eine String-Liste oder ein String-Ausdruck erwartet. Wenn der folgende Ausdruck nicht als String-Listenausdruck aufgelöst werden kann (vgl. 3.) wird ein String-Ausdruck erwartet. Der String wird dann als Dateiname interpretiert. Der '{opsi-winst}' versucht die Datei als Textdatei zu öffnen und interpretiert die Zeilen als eine externe Sektion des beschriebenen Typs. +
Bsp.: +
`sub` '"p:\install\opsiutils\mainroutine.ins"' +
Es wird versucht die Zeile mainroutine.ins als Anweisung der Subsektion auszulesen. 

. Wenn der Ausdruck auf eine alleinstehenden spezifizierten Sektionstyp folgt, kann dieser als ein String-Listenausdruck aufgelöst werden. Die String-Listenkomponenten werden dann als ein Sektionsausdruck interpretiert. +
Dieser Mechanismus kann bspw. dazu verwendet werden, um eine Datei mit Unicode-Format zu laden und dann mit den üblichen Mechanismen zu bearbeiten:
[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----

Syntaktisch hat diese Zeile die drei Bestandteile: +
*  `registry`, die eigentliche Anweisung, die den Sektionstyp spezifiziert. +
*  `loadUnicodeTextFile (..)`, ein String-Listenausdruck, in dem näher beschrieben ist, wie man eine Zeile der `registry` Sektion bekommt. +
*  `/regedit`, Option als 2. Parameter (typspezifisch, s. das Folgende).

In diesem Beispiel gibt der Aufrufparameter ein Beispiel an für den dritten Teil eines Subsektionsaufrufs:

Der dritte Part eine Aufrufs umfasst spezielle Aufrufsoptionen. 
Referenzen für die Aufrufsoptionen beziehungsweise für eine genauere Beschreibung der Sektionsaufrufe finden sich in siehe <<opsi-winst-secsections,Kapitel "Sekundäre Sektionen">>.

[[opsi-winst-commands-reboot]]
=== Reboot-Steueranweisungen

Die Anweisung  `ExitWindows` dient zur Steuerung von Reboot, Shutdowns, u.ä. Vorgängen welche erst nach Beendigung des '{opsi-winst}' selbst durchgeführt werden. Die Benennung des Befehls und die Tatsache, das es `ExitWindows` nicht ohne Modifier gibt, ist historisch bedingt: Unter Windows 3.1 konnte man Windows beenden und zur DOS-Ebene zurück wechseln.

*  `ExitWindows /RebootWanted` + 
Abgekündigt: vermerkt eine Rebootanfrage eines Skriptes in der Registry, lässt aber das '{opsi-winst}' Skript weiterlaufen und weitere Skripte abarbeiten und rebootet erst, wenn alle Skripte durchgelaufen sind.
Eigentlich wird dieses Kommando jetzt als `ExitWindows /Reboot` behandelt (da ansonsten eine Installation fehlschlagen könnte, weil ein benötigtes Produkt nicht komplett installiert wurde).

*  `ExitWindows /Reboot` +
unterbricht eine Skriptfolge durch die Auslösung des Reboots nachdem der '{opsi-winst}' die Bearbeitung des laufenden Skripts beendet hat.

*  `ExitWindows /ImmediateReboot` +
unterbricht die normale Ausführung eines Skripts, an der Stelle, an der er aufgerufen wird. Nach dem der Befehl aufgerufen wurde, werden (außer if-Anweisungen) keine Anweisungen mehr ausgeführt und der Rechner rebootet. Dabei bleibt in der opsi-Umgebung der Actionrequest der das Skript aufgerufen hat bestehen.Dadurch wird gewährleistet, dass nach dem Neustart der '{opsi-winst}' wieder das Skript, dass abgebrochen wurde, startet. Das Skript sollte daher so konzipiert sein, dass die Ausführung nach dem Punkt der Unterbrechung fortgesetzt wird (andernfalls erhalten wir möglicherweise eine Endlosschleife...) vgl. das Beispiel in diesem Abschnitt.

*  `ExitWindows /ImmediateLogout` +
funktioniert ähnlich wie der Aufruf /ImmediateReboot, aber beinhaltet ein Beenden des '{opsi-winst}' (Beenden des Skriptes) statt einen Reboot.
Dies ist dann sinnvoll, wenn nachfolgend ein automatisches Login (eines anderen Users) folgen soll. Beachten Sie hierzu <<opsi-winst-cookbook-local-admin,Kapitel "Skript für Installationen im Kontext eines lokalen Administrators">>.

*  `ExitWindows /ShutdownWanted` +  
sorgt dafür, dass der PC nach Abschluss der Installation aller angefragten Produkte heruntergefahren wird. 

Wie man eine Markierung setzt, um sicherzustellen, dass das Skript nicht in eine Endlosschleife läuft, wenn `ExitWindows /ImmediateReboot` aufgerufen wird, demonstriert folgendes Codebeispiel:
[source,winst]
----
DefVar $Flag$
DefVar $WinstRegKey$
DefVar $RebootRegVar$

Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
Set $Flag$ = GetRegistryStringValue32("["+$WinstRegKey$+"] "+"RebootFlag")

if not ($Flag$ = "1")
  ;========================= 
  ; Anweisungen vor Reboot 

  Files_doSomething 

  ; Reboot initialisieren ...
  Set $Flag$ = "1"
  Registry_SaveRebootFlag
  ExitWindows /ImmediateReboot

else 
  ;========================= 
  ; Anweisungen nach Reboot

  ; Rebootflag zurücksetzen
  Set $Flag$ = "0"
  Registry_SaveRebootFlag

  ; die eigentlichen Anweisungen

  Files_doMore

endif


[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$Flag$"

[Files_doSomething]
; eine Sektion, die vor dem Reboot ausgeführt wird 

[Files_doMore]
; eine Sektion, die nach dem Reboot ausgeführt wird 
----

[[opsi-winst-commands-isfatalerror]]
=== Fehlgeschlagene Installation anzeigen

Passieren bei einer Installation Fehler, die zum Fehlschlagen der Installation führen, so sollte dies an den Server zurückgemeldet werden.

Um in einem '{opsi-winst}' Skript, eine Installation als gescheitert zu erklären, gibt es eine Ausdruck namens  +
`isFatalError` +
unterbricht die normale Ausführung eines Skripts, an der Stelle, an der er aufgerufen wird. Nach dem der Befehl aufgerufen wurde, werden (außer if-Anweisungen) keine Anweisungen mehr ausgeführt und als Skriptergebnis wird 'failed' zurückgeliefert. Wird dieser Befehl nicht aufgerufen, so ist das Skriptergebnis 'success'.

Es gibt *keinen* Automatismus innerhalb eines Winst-Skriptes, um zu einen 'failed' Ergebnis zu kommen. Sie müssen skriptgesteuert den Fehler selbst feststellen. Hierzu gibt Ihnen der '{opsi-winst}' einige Hilfsmittel.

Ein „fataler Fehler“ sollte zum Beispiel ausgelöst werden, wenn der Plattenplatz für die Installation nicht ausreicht:
[source,winst]
----
DefVar $SpaceNeeded$"
Set $SpaceNeeded$" = "200 MB"

if not(HasMinimumSpace ("%SYSTEMDRIVE%", $SpaceNeeded$"))
  LogError "Nicht genügend Platz. Erforderlich sind "+$SpaceNeeded$
  isFatalError
  ; beendet die Skriptausführung und setzt den Produktstaus auf failed
else
  ; die Installation wird gestartet 
  ; ...
endif
----

Fehler die von Funktionen des '{opsi-winst}' zurückgeliefert werden, werden in die Logdatei geschrieben und erhöhen den Fehlerzähler des {opsi-winst}. Dieser Fehlerzähler kann ausgewertet werden. So besteht auch die Möglichkeit, in einem kritischen Abschnitt eines Skripts festzustellen, ob Fehler bzw. wie viele Fehler aufgetreten sind (und abhängig hiervon ggf. isFatalError aufzurufen).

Dafür ist die Fehlerzählung zu Beginn des entsprechenden Abschnittes – z.B. vor einer Files-Sektion – mit +
`markErrorNumber` +
zu initialisieren. Die Zahl der Fehler, die ab dieser Stelle aufgetreten sind, kann dann mit dem Ausdruck +
`errorsOccuredSinceMark` + 
abgefragt werden. Z.B. kann man die Bedingung „es kam in diesem Abschnitt mindestens ein Fehler vor“ so formulieren: +
`if errorsOccuredSinceMark > 0` +
und, wenn es sinnvoll erscheint, daraufhin +
	`isFatalError` +
feststellen.

Sofern die Skriptanweisungen nicht direkt einen Fehler produzieren, jedoch aufgrund bestimmter Umstände eine Situation trotzdem als Fehlersituation gewertet werden soll, kann auch mittels der Anweisung `logError` eine Fehlermeldung generiert werden.
[source,winst]
---- 
markErrorNumber
; Fehler, die nach dieser Marke auftreten werden gezählt
; und werden als fatale Fehler gewertet

logError "test error"
; wir schreiben einen Kommentar "test error" in die Logdatei
; und die Fehleranzahl wird um eins erhöht
; für Testzwecke kann man diese Zeile auskommentieren 

if errorsOccuredSinceMark > 0
    ; die Skriptausführung wird so bald wie möglich beendet
    ; und setzt den Produktstatus auf "failed"

    isFatalError
    ; Kommentare können  noch geschrieben werden 

    comment "error occured"

else
    ; kein Fehler aufgetreten, gibt folgendes aus:

    comment "no error occured"
endif
----

[[opsi-winst-secsections]]
== Sekundäre Sektionen

Sekundäre Sektionen können ebenso wie die primäre Sektion aufgerufen werden, haben aber eine andere Syntax. Die Syntax der verschiedenen Sektionstypen ist jeweils aufgabenbezogen und lehnt sich möglichst eng an bekannte Kommandoformen für den jeweiligen Aufgabentyp an.

Sekundäre Sektionen sind spezifiziert für einen eingegrenzten Funktionsbereich. Dies bezieht sich auf das Objekt der Funktion z.B. das Dateisystem im Allgemeinen, die Windows Registry oder XML-Dateien. Einen spezielle Bedeutung haben die verschiedenen Varianten der Batch-Sektionen, die dazu dienen (beliebige) externe Programme oder Skripte aufzurufen. 

[[opsi-winst-files]]
=== Files-Sektionen

Files-Sektion dienen zum Dateihandling (Kopieren, Löschen). Anders als bei Ausführung der vergleichbaren Kommandozeilen-Befehle, werden die ausgeführten Operationen bei Bedarf genau protokolliert. Zusätzlich kann beim Kopieren von Bibliotheksdateien (z.B. dll-Dateien) auch die Dateiversion geprüft werden, so dass nicht neuere Versionen durch ältere Versionen überschrieben werden.

[[opsi-winst-files-example]]
==== Beispiele 

Eine Files-Sektion könnte etwa lauten:
[source,winst]
----
[Files_do_some_copying]
copy -sV "p:\install\instnsc\netscape\*.*" "C:\netscape"
copy -sV "p:\install\instnsc\windows\*.*" "%SYSTEMROOT%"
----

Mit diesen Anweisungen werden alle Dateien des Verzeichnisses 'p:\install\instnsc\netscape' in das Verzeichnis 'C:\netscape' kopiert, sowie alle Dateien von 'p:\install\instnsc\windows' in das Windows-Systemverzeichnis (welches das jeweils Gültige ist, steht automatisch in der {opsi-winst}-Konstante %SYSTEMROOT%).
Die Option `-s` bedeutet dabei, das alle Subdirectories mit erfasst werden, `-V` steht für das Einschalten der Versionskontrolle von Bibliotheksdateien.

[[opsi-winst-files-params]]
==== Aufrufparameter (Modifier)

In der Regel benötigt eine Files-Sektion beim Aufruf keinen Parameter. 

Es gibt jedoch eine spezielle Anwendung der Files-Sektion, bei der Zielpfad von Kopieraktionen automatisch bestimmt oder modifiziert wird, bei denen die  betreffende Files-Sektion mit dem Parameter

*  `/AllNTUserProfiles` bzw.
*  `/AllNTUserSendTo`

aufgerufen wird. +
Beide Varianten bedeuten: +
Die betreffende Files-Sektion wird je einmal für jeden NT-User ausgeführt. 
Bei Kopieraktionen in dieser Files-Sektion wird automatisch ein User-spezifisches Verzeichnis als Zielverzeichnis eingesetzt. 

Für alle anderen Aktionen steht eine Variable `%UserProfileDir%` zur Verfügung, mit der Verzeichnisnamen konstruiert werden können.

Das User-spezifische Verzeichnis ist im Fall von `/AllNTUserProfiles` das User-Profilverzeichnis. Im Fall von `/AllNTUserSendTo` wird der Pfad zum User-spezifischen SendTo-Ordner vorgegeben (der dazu dient, im Windows-Explorer Kontextmenü-Verknüpfungen vorzugeben).

Die genaue Regel, nach der Zielpfade für copy-Anweisungen automatisch gebildet werden, ist dreiteilig:

. Folgt auf die Angabe der zu kopierenden Quelldateien gar keine Zielverzeichnisangabe, so werden die Dateien direkt in das betreffende User-spezifische Verzeichnis kopiert. Der Befehl lautet einfach +
`copy` <Quelldatei> +
Dies ist gleichbedeutend mit +
`copy` <Quelldatei> '"%UserProfileDir%\"'

. Wenn außer den zu kopierenden Quelldateien ein Kopierziel 'targetdir' spezifiziert ist, dieses Ziel jedoch keinen absoluten Pfad (beginnend mit Laufwerksname oder mit "\") darstellt, dann wird die Zielangabe als Unterverzeichnisname des User-spezifischen Verzeichnisses interpretiert und der Zielverzeichnisname dementsprechend konstruiert. D.h. man schreibt +
`copy` <Quelldateien> 'targetdir' 
und das wird interpretiert wie: +
`copy` <Quelldatei> '"%UserProfileDir%\targetdir"'

. Enthält der copy-Befehl Quelldateien und einen absoluten Zielpfad targetdir, so wird dieser statische Zielpfad verwendet.

Weiterhin gibt es die Aufrufparameter:

*  `/32Bit`
*  `/64Bit`
*  `/SysNative`

Welche die 'file redirection' auf 64 Bit-Systemen beeinflussen.
siehe <<opsi-winst-64bit,Kapitel 64 Bit-Unterstützung>>
 
==== Kommandos

Innerhalb einer Files-Sektion sind die Anweisungen 

*  `Copy`

*  `Delete`

*  `SourcePath`

*  `CheckTargetPath`

definiert. 

Die Kommandos `Copy` und `Delete` entsprechen im Wesentlichen den Windows-Kommandozeilen-Befehlen xcopy bzw. del.

`SourcePath` sowie `CheckTargetPath` legen Quell- bzw. Zielpfad einer Kopieraktion fest, ähnlich wie sie etwa im Windows-Explorer durch Öffnen von Quell- und Zieldirectory in je einem Fenster realisiert werden kann. Der Zielpfad wird, sofern er nicht existiert, erzeugt.

Im Einzelnen: 

*  `Copy` [-svdunxwnr] <Quelldatei(maske)> <Zielpfad>
+ 
Die Quelldateien können dabei mittels Joker (”* ” in der Dateimaske) oder auch nur mit einer Pfadangabe bezeichnet werden. 
+
CAUTION: Zielpfad wird in jedem Fall als Directory-Name interpretiert. Umbenennen beim Kopieren ist nicht möglich: Ziel ist immer ein Pfad, nicht ein (neuer) Dateinamen. Existiert der Pfad nicht, wird er (auch mit geschachtelten Directories) erzeugt. 
+
Die einzelnen (in beliebiger Reihenfolge aufführbaren) Optionen der Copy-Anweisung bedeuten: 

**  `s` -> Mit Rekursion in Subdirectories.

**  `e` -> Leere (Empty) Subdirectories. +
Gibt es leere Subdirectories im Quellverzeichnis, werden sie im Zielverzeichnis ebenfalls leer ("empty") erzeugt.

**  `V` -> Mit Versionskontrolle +
Mit Versionskontrolle: +
Neuere Versionen von Windows-Bibliotheksdateien im Zielverzeichnis werden nicht durch ältere Versionen überschrieben (bei unklaren Verhältnissen wird in einem Log-Eintrag gewarnt).

**  `v` -> (nicht Verwenden) +
Mit Versionskontrolle: +
Veraltet; bitte nicht bei Betriebssystemversionen höher als Win2k verwenden, da hier nicht nur gegen das Zielverzeichnis, sondern auch gegen %SYSTEM% geprüft wird. Verwenden Sie stattdessen `-V`.

**  `d` -> Mit Datumskontrolle: +
Jüngere *.EXE-Dateien werden nicht durch ältere überschrieben. 

**  `u` -> Datei-Update: +
Es werden Dateien nur kopiert, sofern sie nicht mit gleichem oder jüngerem Datum im Zielpfad existieren. 

**  `x` -> x-tract +
Wenn eine Datei ein Zip-Archiv ist, wird es entpackt (x-tract). Vorsicht: Zip-Archive verbergen sich unter verschiedenen Dateinamen (z.B. sind Java jar-Dateien auch Zip-Archive), daher sollte man die Extract-Option nicht unbesehen auf alle Dateien anwenden. Achtung: Es werden keine Pfade entpackt.

**  `w` -> weak +
Dateien werden nur überschrieben, wenn sie keinen Schreibschutz haben (das Überschreiben ist "weak" (relativ schwach) im Vergleich zum Defaultverhalten, dem Ignorieren des Schreibschutzes).

**  `n` ->  no over write +
Dateien werden nicht überschrieben. 

**  `c` ->  continue +
Wenn eine Systemdatei in Benutzung ist, kann sie erst nur nach einem Reboot überschrieben werden. Das '{opsi-winst}' default-Verhalten ist dabei, dass ein Datei in Benutzung zum Überschreiben beim nächsten Reboot markiert wird UND die '{opsi-winst}' Reboot Markierung gesetzt wird. Das Setzen der Kopiermodifikation "-c" stellt den automatischen Reboot aus. Anstatt das normale Prozesse weiterlaufen (continues) wird das Kopieren nur vervollständigt, wenn ein Reboot auf eine andere Weise ausgelöst wird.

**  `r` -> read-only Attribute +
Nur wenn diese Option gesetzt ist, bleibt ein eventuell vorhandenes read-only-Attribut erhalten (im Gegensatz zu dem default-Verhalten, welches read-only Attribute ausschaltet).

*  `Delete` [-sfd[n]] <Pfad>

oder

*  `Delete` [-sfd[n]] <Datei(maske)>
+
Löschen einer Datei bzw. eines Verzeichnisses. Mögliche Optionen (die in beliebiger Reihenfolge aufgeführt sein können) sind:

**  `s` ->  subdirectories +
Steht für die Rekursion in Subdirectories, das heißt, der ganze Pfad bzw. alle der Dateimaske entsprechenden Dateien im Verzeichnisbaum ab der angegebenen Stelle werden gelöscht.
+
CAUTION: Der Befehl +
`delete -s c:\opsi` +
Bedeutet nicht lösche das Verzeichnis 'c:\opsi' rekursiv, sondern lösche ab 'c:\' rekursiv alle Dateien namens 'opsi' (und führt damit evtl. zum kompletten Durchsuchen der Festplatte). Zum rekursiven Löschen von 'c:\opsi' verwenden Sie das Kommando: +
`delete -s c:\opsi\` +
Durch den angehängen Backslash ist deutlich, dass Sie ein Verzeichnis meinen.

**  `f` ->  force +
Erzwingt ("force") das Löschen auch von read-only-Dateien.

**  `d [n]` ->  date +
Dateien werden nur gelöscht, sofern sie mindestens n Tage alt sind. Default für n ist 1.

*  `SourcePath` = <Quelldirectory> +
Festlegung des Verzeichnisses <Quelldirectory> als Vorgabe-Quelldirectory für in der betreffenden Sektion folgende Copy- sowie (!) Delete-Aktionen.

*  `CheckTargetPath` = <Zieldirectory> +
Festlegung des Verzeichnisses <Zieldirectory> als Vorgabe-Zieldirectory für Copy-Aktionen. Wenn <Zieldirectory> nicht existiert, wird der Pfad auch mehrstufig erzeugt. 

[[opsi-winst-patches]]
=== Patches-Sektionen

Eine Patches-Sektion dient der Modifikation (dem "Patchen") einer "*.INI-Datei", d.h. einer Datei, die Sektionen mit Einträgen der Form '<Variable> = <Wert>' besteht. Die Sektionen oder Abschnitte sind dabei gekennzeichnet durch Überschriften der Form '[Sektionsname]'. 

(Seitdem eine gepatchete INI-Datei auf die gleiche Weise wie die Sektionen vom '{opsi-winst}' Skript erstellt werden, muss man vorsichtig mit den Bezeichnungen umgehen, damit kein Durcheinander entsteht).

[[opsi-winst-patches-examples]]
==== Beispiele

[source,winst]
----
Patches_DUMMY.INI $HomeTestFiles$+"\dummy.ini"

[Patches_dummy.ini]
add [secdummy] dummy1=add1
; werden durch andere Funktionen ueberschrieben
add [secdummy] dummy2=add2
add [secdummy] dummy3=add3
add [secdummy] dummy4=add4
add [secdummy] dummy5=add5
add [secdummy] dummy6=add6
set [secdummy] dummy2=set1
addnew [secdummy] dummy1=addnew1
change [secdummy] dummy3=change1
del [secdummy] dummy4
Replace dummy6=add6 replace1=replace1
----

ergibt folgenden Log:
[source,winst]
----
Execution of Patches_DUMMY.INI
      FILE C:\tmp\testFiles\dummy.ini
      Info: This file does not exist and will be created 
  addEntry [secdummy] dummy1=add1
    addSection [secdummy]
      done
      done
  addEntry [secdummy] dummy2=add2
      done
  addEntry [secdummy] dummy3=add3
      done
  addEntry [secdummy] dummy4=add4
      done
  addEntry [secdummy] dummy5=add5
      done
  addEntry [secdummy] dummy6=add6
      done
  setEntry [secdummy] dummy2=set1
    Entry      dummy2=add2
    changed to dummy2=set1
  addNewEntry [secdummy] dummy1=addnew1
    appended entry
  changeEntry [secdummy] dummy3=change1
    entry      dummy3=add3
    changed to dummy3=change1
  delEntry [secdummy] dummy4
    in section secdummy deleted  dummy4=add4
  replaceEntrydummy6=add6 replace1=replace1
    replaced in line 7
  C:\tmp\testFiles\dummy.ini saved back
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_patches$ = "on"'

[[opsi-winst-patches-params]]
==== Aufrufparameter

Der Name der zu patchenden Datei wird als Parameter übergeben.

[[opsi-winst-patches-commands]]
==== Kommandos

In einer Patches-Sektion sind die Anweisungen 

*  `add`

*  `set`

*  `addnew`

*  `change`

*  `del`

*  `delsec`

*  `replace`

definiert. Eine Anweisung bezieht sich jeweils auf eine Sektion der zu patchenden Datei. Der Name dieser Sektion steht in Klammern `[]`.

Syntax und Funktion der Anweisungen im Einzelnen: 

*  `add [`<section name>`]` <variable1> `=` <value1> +
Fügt einen Eintrag der Form <Variable1> = <value1> in die Sektion <section name> ein, falls dort noch kein Eintrag von <Variable1> (auch mit anderem Wert) existiert. Im anderen Fall wird nichts geschrieben. Existiert die Sektion noch nicht, wird sie zuerst erzeugt.

*  `set [`<section name>`]`<variable1> `=` <value1> +
Setzt einen vorhandenen Eintrag <variable1> = <value X> in der Sektion <section name>, um auf <variable1> = <value1> zu kommen. Existieren mehrere Einträge von <variable1>, wird der Erste umgesetzt. Falls kein Eintrag mit <variable1> existiert, wird <variable1> = <value1> in der Sektion <section name> erzeugt; existiert die Sektion noch nicht, wird sie zuerst erzeugt. 

*  `addnew [`<section name>`]`<variable1> `=` <value1> +
Der Eintrag <variable1> = <value1> wird in der Sektion <section name> auf jeden Fall erzeugt, sofern er dort nicht bereits genau so existiert (gegebenenfalls zusätzlich zu anderen Einträgen von <variable1>). Existiert die Sektion noch nicht, wird sie zuerst erzeugt. 

*  `change [`<section name>`]`<variable1> `=` <value1> +
Ändert einen vorhandenen Eintrag von <variable1> in der Sektion <section name> auf <variable1> = <value1>.  Falls <variable1> nicht vorhanden ist, wird nichts geschrieben.

*  `del [`<section name>`]` <variable1> `=` <value1> +
bzw. +
`del [`<section name>`]` <variable1> +
In der Sektion <section name> wird gemäß dem ersten Syntaxschema der Eintrag <variable1> = <value1> entfernt. Nach dem zweiten Syntaxschema wird der erste Eintrag von <variable1> aus der angesprochenen Sektion gelöscht, unabhängig vom Wert des Eintrags.

*  `delsec [`<section name>`]` +
Die Sektion <section name> der .INI-Datei wird mitsamt ihren Einträgen gelöscht. 

*  `replace` <variable1>`=`<value1> <variable2>`=`<value2> +
In allen Sektionen der .INI-Datei wird der Eintrag <variable1>=<value1> durch <Variable2>=<value2> ersetzt. Zur Anwendung dieses Befehls dürfen Leerzeichen weder um die Gleichheitszeichen stehen noch in <value1> bzw. <value2> enthalten sein.

[[opsi-winst-patchhosts]]
=== PatchHosts-Sektionen

Eine PatchHosts-Sektion dient der Modifikation einer 'hosts'-Datei, das heißt einer Datei, deren Zeilen nach dem Schema +
'ipAdresse	  Hostname  Aliasname(n)   # Kommentar' +
aufgebaut sind. 

Dabei sind 'Aliasname(n)' und 'Kommentar' optional. Eine Zeile kann auch mit dem Symbol '#' beginnen und ist dann insgesamt ein Kommentar.

Die zu patchende Datei kann als Parameter des `PatchHosts`-Aufrufs angegeben sein. Fehlt der Parameter 'HOSTS', so wird in den Verzeichnissen (in dieser Reihenfolge) 'c:\nfs, c:\windows' sowie '%systemroot%\system32\drivers\etc' nach einer Datei mit dem Namen 'hosts' gesucht. 

Wird auf keine dieser Arten eine Datei mit dem Namen 'hosts' gefunden, bricht die Bearbeitung mit einem Fehler ab.

In einer PatchHosts-Sektion existieren die Anweisungen

*  `setAddr`

*  `setName`

*  `setAlias`

*  `delAlias`

*  `delHost`

*  `setComment`


Beispiel:
[source,winst]
----
PatchHosts_add $HomeTestFiles$+"\hosts"

[PatchHosts_add]
setAddr ServerNo1 111.111.111.111
setName 222.222.222.222 ServerNo2
setAlias ServerNo1 myServerNo1
setAlias 222.222.222.222 myServerNo2
setComment myServerNo2 Hallo Welt
----

ergibt folgenden Log:
[source,winst]
----
Execution of PatchHosts_add
    FILE C:\tmp\testFiles\hosts
  Set ipAddress 111.111.111.111 Hostname "ServerNo1"
  Set Hostname "ServerNo2" for ipAddress 222.222.222.222
  Alias "myServerNo1" set for entry "ServerNo1"
  Alias "myServerNo2" set for entry "222.222.222.222"
  SetComment of Host "myServerNo2" to "Hallo Welt"
  C:\tmp\testFiles\hosts saved back
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test' und dort den Bereich '$Flag_winst_patch_hosts$ = "on"'.

Die Anweisungen im einzelnen:

*  `setaddr`  <hostname> <ipaddresse> +
Setzt die IP-Adresse für den Host <hostname> auf <ipadresse>. 
Falls noch kein Eintrag für den Host <hostname> besteht, wird er neu eingetragen.

*  `setname` <ipaddresse> <hostname> +
Setzt den Namen des Hosts mit der angegeben IP-Adresse <ipadresse> auf <hostname>. Falls noch kein Eintrag mit der IP-Adresse <ipadresse> existiert, wird er neu erzeugt.

*  `setalias` <hostname> <alias> +
Fügt für den Host mit dem IP-Namen <hostname> einen ALIAS-Namen <alias> ein. 

*  `setalias` <IPadresse> <alias> +
Fügt für den Host mit der IP-Adresse <IPadresse> einen ALIAS-Namen <alias> ein.

*  `delalias` <hostname> <alias> +
Löscht aus dem Eintrag für den Host mit dem IP-Namen <hostname> den ALIAS-Namen <alias>. 

*  `delalias` <IPadresse> <alias> +
Löscht aus dem Eintrag für den Host mit der IP-Adresse <IPadresse> den ALIAS-Namen <alias>. 

*  `delhost` <hostname>
Löscht den Eintrag des Hosts mit dem IP- (oder Alias-) Namen <hostname>.

*  `delhost` <IPadresse> +
Löscht den Eintrag des Hosts mit der IP-Adresse <IPadresse>.

*  `setComment` <ident> <comment> +
Setzt für den Host mit dem IP-Namen, Alias-Namen oder Adresse <ident> den Kommentareintrag auf <comment>. 

[[opsi-winst-idapi]]
=== IdapiConfig-Sektionen

Eine IdapiConfig-Sektion waren dazu geeignet, in idapi*.cfg-Dateien, die von der Borland-Database-Engine verwendet werden, die benötigten Parameter einzufügen.

IdapConfig-Sektionen werden vom aktuellen '{opsi-winst}' nicht mehr unterstützt.

[[opsi-winst-patchtextfile]]
=== PatchTextFile-Sektionen

PatchTextFile-Sektionen dienen zum Patchen allgemeiner Textdateien. Es gibt aber auch Spezialanweisungen zum Patchen von Mozilla Konfigurationsdateien.

Wichtig für die Arbeit mit Textdateien ist das Überprüfen, ob eine bestimmte Zeile bereits in einer existierenden Datei vorhanden ist. Für diese Zweck gibt es die boolesche Funktionen `Line_ExistsIn` und `LineBeginning_ExistsIn` (vgl. <<opsi-winst-commands-if-else-bool-functions,Kapitel "Boolesche Ausdrücke">>) zur Verfügung.

[[opsi-winst-patchtextfile-params]]
==== Aufrufparameter

Der Name der zu patchenden Datei wird als Parameter übergeben.

[[opsi-winst-patchtextfile-commands]]
==== Kommandos

Zwei Anweisungen dienen speziell dem komfortablen Patchen von Mozilla-Präferenzdateien:

*  `Set_Mozilla_Pref` ("<preference type>", "<preference key>", "<preference value>") +
sorgt dafür, dass in die beim Sektionsaufruf spezifizierten Datei die Zeile <Präferenzvariable> nach <Wert> geschrieben wird. Die ASCII-alphabetische Anordnung der Datei wird beibehalten bzw. hergestellt. +
In den momentanen Mozilla Präferenzdateien gibt es folgende Ausdrücke +
'user_pref("<key>", "<value>") +
pref("<key>", "<value>") +
lock_pref("<key>", "<value>")' +
Jeder dieser Ausdrücke, sozusagen jede (javascript) Funktion, die auf diese Weise aufgerufen wird +
'functionname (String1, String2)' +
kann mit diesem Kommando gepatcht werden über das Setzen des entsprechenden Strings für <preference type> (das ist bspw. für 'functionname'). +
Wenn der Starteintrag '"functionname (String1)"' in dem bearbeitenden File existiert, kann er gepatcht werden (und bleibt an seinem Platz). Andernfalls wird einen neue Zeile eingefügt. +
Für den '{opsi-winst}' - ungewöhnlicherweise - sind alle Strings case sensitive.

*  `Set_Netscape_User_Pref` ("<Präferenzvariable>", "<Wert>")
ist die restriktivere, ältere Version des vorherigen Kommandos und sollte nicht mehr verwendet werden. +
Setzen der Zeile mit den vom User vergebenen Präferenzen für die Variable <Präferenzvariable> und des Wertes <value>.(Abgekündigt!)

*  `AddStringListElement_To_Mozilla_Pref` ("<Präferenztyp>", "<Präferenzvariable>", "<add value>") +
fügt ein Element zu einem Listeneintrag der Präferenzdatei hinzu. Das Element wird überprüft, wenn der Wert, der hinzugefügt werden soll, bereits in der Liste existiert (dann wird er nicht hinzugefügt). 

*  `AddStringListElement_To_Netscape_User_Pref` ("<Präferenzvariable>", "<Werteliste>") +
ist die restriktivere, ältere Version des vorherigen Kommandos und sollte nicht mehr verwendet werden. +
Es fügt einer Werteliste ein Element hinzu (soweit nicht schon enthalten). Angewendet werden kann die Anweisung zur Ergänzung der No-Proxy-Einträge in der prefs.js. (Abgekündigt!)

Alle übrigen Anweisungen von PatchTextFile-Sektionen sind nicht auf spezielle Dateiarten bzw. eine spezielle Syntax der Datei festgelegt:

Die drei Suchanweisungen

*  `FindLine` <Suchstring>
*  `FindLine_StartingWith` <Suchstring>
*  `FindLine_Containing` <Suchstring> 

durchsuchen die Datei ab der Position, auf der der Zeilenzeiger steht. Sofern sie eine passende Zeile finden, setzen sie den Zeilenzeiger auf die erste Zeile, die <Suchstring> gleicht / mit ihm beginnt / ihn enthält. 

Wird <Suchstring> nicht gefunden, so bleibt der Zeilenzeiger an der Ausgangsposition stehen. 

*  `GoToTop` + 
setzt den Zeilenzeiger vor die erste Zeile setzt (werden Zeilen gezählt muss man berücksichtigen, dass dieses Kommando den Zeilenzeiger über die Anfangszeile setzt). 
Der Zeilenzeiger kann vor und zurück bewegt werden mit der <Anzahl Zeilen>.

*  `AdvanceLine` [<Anzahl Zeilen>] +
bewegt den Zeilenzeiger um <Anzahl Zeilen> vor oder zurück.

*  `GoToBottom` +
setzt den Zeilenzeiger auf die letzte Zeile.

*  `DeleteTheLine` +
löscht die Zeile auf der der Zeilenzeiger steht, sofern sich dort eine Zeile befindet (wenn der Zeilenzeiger oben platziert ist, wird nichts gelöscht).

*  `AddLine_` <Zeile> oder `Add_Line_` <Zeile> +
<Zeile> wird am Schluss der Datei angehängt.

*  `InsertLine` <Zeile> oder `Insert_Line_` <Zeile> +
<Zeile> wird an der Stelle eingefügt, an der der Zeilenzeiger steht.

*  `AppendLine` <Zeile> oder `Append_Line`  <Zeile> +
<Zeile> wird nach der Zeile eingefügt, an der der Zeilenzeiger steht.

*  `Append_File`  <Dateiname> +
liest die Zeilen der Datei <Dateiname> ein und fügt sie an den Schluss der gerade bearbeiteten Datei an.

*  `Subtract_File`  <Dateiname> +
entfernt die Anfangszeilen der bearbeiteten Datei, so weit sie mit den Anfangszeilen der Datei <Dateiname> übereinstimmen.

*  `SaveToFile` <Dateiname> +
speichert die bearbeitete Datei als <Dateiname>.

*  `Sorted` +
bewirkt, dass die Zeilen alphabetisch (nach ASCII) geordnet sind.

[[opsi-winst-patchtextfile-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_patch_text_file$ = "on"'

[[opsi-winst-linkfolder]]
=== LinkFolder-Sektionen

Mit LinkFolder-Sektionen werden u.a. die Einträge im Startmenü, die Links auf dem Desktop u.ä. verwaltet. 

Zum Beispiel erzeugt folgende Sektion einen Folder (Ordner) namens „acrobat“ im Programme-Folder des allgemeinen Startmenüs (für alle Nutzer gemeinsam).
[source,winst]
----
[LinkFolder_Acrobat]
set_basefolder common_programs

set_subfolder "acrobat"
set_link 
  name: Acrobat Reader 
  target: C:\Programme\adobe\Acrobat\reader\acrord32.exe
  parameters: 
  working_dir: C:\Programme\adobe\Acrobat\reader
  icon_file: 
  icon_index:
end_link
----

In einer LinkFolder-Sektion muss zuerst bestimmt werden, in welchem virtuellen Systemfolder die nachfolgenden Anweisungen arbeiten sollen. Dafür existiert die Anweisung +
`set_basefolder` '<virtueller Systemfolder>' 

Virtuelle Systemfolder, die angesprochen werden können, sind:

'desktop, sendto, startmenu, startup, programs, desktopdirectory, common_startmenu, common_programs, common_startup, common_desktopdirectory'

Die Folder sind virtuell, weil erst durch das Betriebssystem(-Version) bestimmt wird, an welchem physikalischen Ort des Dateisystems sie real existieren. 
Im zweiten Schritt werden die Subfolder (bzw. Subfolder-Pfade), in denen Links angelegt werden, mit der Anweisung +
`set_subfolder` <Folderpath> +
bestimmt und zugleich geöffnet. Der Subfolder versteht sich absolut (mit Wurzel im gesetzten virtuellen Systemfolder). Wenn direkt im Systemfolder gearbeitet werden soll, wird dieser mit + 
`set_subfolder ""`
geöffnet.

Im dritten Schritt können die Links gesetzt werden. Der Befehl verwendet eine mehrzeilige Parameterliste. Sie startet mit +
`set_link` +
Abgeschlossen wird sie durch +
`end_link.`

Die Parameterliste insgesamt hat folgendes Format:

`set_link` + 
  `name:` [Linkname] +
  `target:` <Pfad und Name des Programms> +
  `parameters:` [Aufrufparameter des Programms] +
  `working_dir`: [Arbeitsverzeichnis für das Programm] +
  `icon_file:` [Pfad und Name der Icon-Datei] +
  `icon_index:` [Position des gewünschten Icons in der Icon-Datei] +
`end_link` 

Die Angabe eines 'target' ist erforderlich. Alle andere Einträge haben Defaultwerte und können leer sein oder entfallen:

*  'name' hat als Defaultwert den Programmnamen,
*  'parameters' ist, wenn nichts anderes angegeben ist, ein Leerstring,
*  'icon_file'  ist, wenn nichts anderes angegeben ist, 'target' und
*  'icon_index' ist per Default 0.

CAUTION: Wenn das referenzierte target auf einem, zum Zeitpunkt der Befehlsausführung nicht erreichbaren, Share liegt, werden alle Bestandteile des Pfades auf das Längenschema 8.3 gekürzt. +
Workaround: +
Manuelles Erzeugen einer korrekten Verknüpfung zu einem Zeitpunkt, in dem das Laufwerk verbunden ist. +
Kopieren der korrekten Link-Datei an einen zur Skriptlaufzeit existenten Ort, z.B. C:\Programme. +
Diese Datei ist dann das Link-'target'.

*  `delete_element` <Linkname> +
wird der angesprochene Link aus dem geöffneten Folder gelöscht.

*  `delete_subfolder` <Folderpath> +
löscht den bezeichneten Folder, wobei Folderpath als absolut bezüglich des gesetzten virtuellen Systemfolders zu verstehen ist.

[[opsi-winst-linkfolder-examples]]
==== Beispiele

[source,winst]
----
set $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
for $var$ in $list2$ do LinkFolder_Dummy

[LinkFolder_Dummy]
set_basefolder $var$
set_subfolder "Dummy"
set_link
	name: Dummy
	target: C:\Programme\PuTTY\putty.exe
	parameters:
	working_dir: C:\Programme\PuTTY
	icon_file:
	icon_index:
end_link
----

Ergibt folgenden Log:
[source,winst]
----
Set  $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
    retrieving strings from createStringList [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        
    retrieving strings from $list2$ [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        

~~~~~~ Looping through:  'common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory'
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTMENU folder
    Created "Dummy" in the COMMON STARTMENU folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON PROGRAMS folder
    Created "Dummy" in the COMMON PROGRAMS folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTUP folder
    Created "Dummy" in the COMMON STARTUP folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON DESKTOPDIRECTORY folder
    Created "Dummy" in the COMMON DESKTOPDIRECTORY folder
      ShellLink "Dummy" created

~~~~~~ End Loop
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_link_folder$ = "on"'.

[[opsi-winst-xmlpatch]]
=== XMLPatch-Sektionen

Immer häufiger werden Daten aller Art, insbesondere auch Konfigurationsdaten, als XML-Dokument gespeichert.

Der '{opsi-winst}' bietet XMLPatch-Sektionen an, um XML-Dokumente zu bearbeiten.

Ähnlich wie bei anderen Sektionen (Registry, Patches, LinkFolder) wird dazu zunächst mit bestimmten Befehlen an die Stelle navigiert, an der gearbeitet werden soll und dann dort Detailkommandos ausgeführt.

Das bedeutet, die Aktionen, die '{opsi-winst}' ausführen kann, gliedern sich in:

* *die Selektion* eines Sets von Elementen des XML-Dokuments, inklusive der Erzeugung nicht vorhandener Elemente,

* *Patch-Aktionen*, die für alle Elemente eines Sets ausgeführt werden sowie

* *die Ausgabe* von Namen und/Attributen der selektierten Elemente für die weitere Verarbeitung.

[[opsi-winst-xmlpatch-params]]
==== Aufrufparameter

Der Name der zu patchenden Datei wird als Parameter übergeben.

Beispiel: + 
`XMLPatch_mozilla_mimetypes $mozillaprofilepath$ + "\mimetypes.rdf"`

[[opsi-winst-xmlpatch-xmldoc]]
==== Struktur eines XML-Dokuments

Ein XML-Dokument beschreibt die Logik eines „Baums“ (tree), der sich ausgehend von einer „Wurzel“ (root) – passenderweise  document root genannt  –  in die "Äste" (branches) verzweigt. Jede Verzweigungsstelle, wie auch jedes „Astende“, wird als „Knoten“ bezeichnet (englisch node). Die nachgeordneten Knoten eines Knotens heißen auch Kinderknoten ihres Elternknotens.

In XML wird dieser Baum konstruiert durch Elemente. Der Anfang der Beschreibung eines Elements ist mit einem Tag gekennzeichnet (ähnlich wie in der Web-Auszeichnungssprache HTML), d.h. durch einen spezifischen Markierungstext, der durch „<“ und „>“ umrahmt ist. Das Ende der Beschreibung wird wieder durch ein Tag desselben Typnamens gekennzeichnet, jetzt aber durch „</“ und „>“ geklammert. Wenn es keine nachgeordneten Elemente gibt, kann die getrennte Endmarkierung entfallen, stattdessen wird das öffnende Tag mit „/>“ abgeschlossen.

Einen „V“-Baum – mit einer einzigen Verzweigung in zwei Teiläste – könnte man so skizzieren (Wurzel nach oben gedreht):      
~~~~
    |     Wurzelknoten
   / \    Knoten 1 auf Ebene 1  bzw.  Knoten 2 auf Ebene 1
  .   .   Implizit vorhandene Endknoten unterhalb von Ebene 1 
~~~~

Er würde in XML folgendermaßen dargestellt:
[source,xml]
----
<?xml version="1.0"?>
<Wurzelknoten>
    <Knoten_Ebene-1_Nummer-1>
    </Knoten_Ebene-1_Nummer-1>
    <Knoten_Ebene-1_Nummer-2>
    </Knoten_Ebene-1_Nummer-2>
</Wurzelknoten>
----

Die erste Zeile benennt nur die XML-Definition nach der sich das Dokument richtet. Die weiteren Zeilen beschreiben den Baum.

Die insoweit noch nicht komplizierte Struktur wird dadurch verwickelt, dass bis jetzt nur „Hauptknoten“ vorkommen. Ein Hauptknoten definiert ein „Element“ des Baums und ist durch ein Tag gekennzeichnet. Einem solchen Hauptknoten können – wie bei der Skizze schon angedeutet – „Unterknoten“ und sogar mehrere Arten davon zugeordnet sein. (Befände sich der Baum in der normalen Lage mit Wurzel nach unten, müssten die Unterknoten „Überknoten“  heißen.) Folgende Arten von Unterknoten sind zu berücksichtigen:

* Nachgeordnete Elemente, z.B. könnte der Knoten Nummer 1 sich in Subknoten A bis C verzweigen:
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-1>
    <Knoten_Ebene-2_A>
    </Knoten_Ebene-2_A>
    <Knoten_Ebene-2_B>
    </Knoten_Ebene-2_B>
    <Knoten_Ebene-2_C>
    </Knoten_Ebene-2_c>
</Knoten_Ebene-1_Nummer-1>
----

* Nur wenn es KEINE nachgeordneten Elemente gibt, kann das Element Text enthalten. Dann heißt es, dass dem Element ein Textknoten untergeordnet ist. Beispiel:
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-2>Hallo Welt
</Knoten_Ebene-1_Nummer-2>
----

* Der Zeilenumbruch, der zuvor nur Darstellungsmittel für die XML-Struktur war, zählt dabei jetzt auch als Teil des Textes! Wenn er nicht vorhanden sein soll, muss geschrieben werden
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-2>Hallo Welt</Knoten_Ebene-1_Nummer-2>
----

* Zum Element können außer dem Hauptknoten noch Attribute, sog. Attributknoten gehören. Es könnte z.B. Attribute „Farbe“ oder „Winkel“ geben, die den Knoten 1 in der Ebene 1 näher beschreiben.
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-1 Farbe="grün" Winkel="65">
</Knoten_Ebene-1_Nummer-1>
----
+
Eine derartige nähere Beschreibung eines Elements ist mit beiden anderen Arten von Unterknoten vereinbar.

Zur Auswahl einer bestimmten Menge von Elemente könnten im Prinzip alle denkbaren Informationen herangezogen werden, insbesondere

. die Elementebene (Schachtelungstiefe im Baum),

. der Name der Elemente, d.h. Name der entsprechenden Hauptknoten, in der Abfolge der durchlaufenen Ebenen (der „XML-Pfad“),

. die Anzahl, Namen und Werte der zusätzlich gesetzten Attribute,

. die Reihenfolge der Attribute,

. die Reihenfolge der Elemente,

. sonstige „Verwandtschaftsbeziehungen“ der Elemente und

. Text-(Knoten-)Inhalte von Elementen.

Im '{opsi-winst}' ist derzeit die Auswahl nach den Gesichtspunkten (1) bis (3) sowie (7) implementiert:

[[opsi-winst-xmlpatch-search-options]]
==== Optionen zur Bestimmung eines Sets von Elementen

Vor jeder weiteren Operation muss das Set von Elementen bzw. von Hauptknoten bestimmt werden, auf die sich die Operation beziehen soll. Das Set wird Schritt für Schritt ermittelt, indem ausgehend von der Dokumentenwurzel  Pfade gebildet werden, die jeweils über akzeptierte nachgeordnete Elemente laufen. Die letzten Elemente der Pfade bilden dann das ausgewählte Set.

Der '{opsi-winst}' Befehl hierfür lautet

*  `OpenNodeSet`

Für die Festlegung der akzeptierten Pfade existiert eine ausführliche und eine Kurzsyntax.

.Ausführliche Syntax

Die ausführliche Syntax für die Beschreibung eines Elemente-Sets bzw. einer Knoten-Menge ist in der folgenden Variante eines Beispiels zu sehen (vgl. Kochbuch, <<opsi-winst-cookbook-patchxml,Kapitel "XML-Datei patchen">>):
[source,winst]
----
openNodeSet
  documentroot
  all_childelements_with:
   elementname:"define"
  all_childelements_with:
    elementname:"handler"
    attribute: extension value="doc"
  all_childelements_with:
    elementname:"application"
end
----

.Kurzsyntax

Das gleiche Nodeset beschreibt folgende Kurzsyntax (muss in einer Zeile des Skripts untergebracht werden):
[source,winst]
----
openNodeSet 'define /handler value="doc"/application /'
----

In dieser Syntax separieren die Schrägstriche die Schritte innerhalb der Baumstruktur, welche in einer Syntax angegeben werden, die ausführlicher als eine eigene Beschreibung ist.

.Selektion nach Text-Inhalten (nur ausführliche Syntax)

Die ausführliche Syntax erlaubt auch die Selektion nach Text-Inhalten eines Tags:
[source,winst]
----
openNodeSet

  documentroot
  all_childelements_with:
  all_childelements_with:
    elementname:"description"
    attribute:“type“ value=“browser“
    attribute:“name“ value=“mozilla“
  all_childelements_with:
    elementname:"linkurl"
    text:"http://www.mozilla.org"
end
----

.Parametrisierung der Suchstrategie

Bei den bislang aufgeführten Beschreibungen eines Elemente-Sets bleiben allerdings eine ganze Reihe von Fragen offen.

* Soll ein Element akzeptiert werden, wenn der Elementname und die aufgeführten Attribute passen, aber weitere Attribute existieren? 

* Soll die Beschreibung im Ergebnis eindeutig sein, d.h. genau ein Element liefern? Und wenn doch die Beschreibung des Pfades auf mehrere Elemente passt, muss dann möglicherweise von einer nicht korrekten Konfigurationsdatei ausgegangen werden? 

* Soll umgekehrt auf jeden Fall ein passendes Element erzeugt werden, wenn keines existiert?

Zur Regelung dieser Fragen kann die OpenNodeSet-Anweisung parametrisiert werden. Bei den nachfolgend genannten Parametern überdecken „stärkere“ Einstellungen „schwächere“, z.B. ersetzt eine Fehlermeldung eine ansonsten geforderte Warnung. Die angegebenen booleschen Werte sind die Default-Werte:
[source,winst]
----
  - error_when_no_node_existing false
  - warning_when_no_node_existing true
  - error_when_nodecount_greater_1 false
  - warning_when_nodecount_greater_1 false
  - create_when_node_not_existing false
  - attributes_strict false
----

Bei Verwendung der Kurzsyntax der OpenNodeSet-Anweisung muss die Parametrisierung vorausgehen und gilt für alle Ebenen des XML-Baumes. In der ausführlichen Syntax kann sie auch direkt nach der OpenNodeSet-Anweisung erfolgen oder für jede Ebene neu gesetzt werden. Sinnvoll kann letzteres vor allem für die Einstellung der Option „create when node not existing“ (Erstellung von Knoten, wenn es keine gibt) sein.

[[opsi-winst-xmlpatch-actions]]
==== Patch-Aktionen

Auf der mit OpenNodeSet geöffneten bzw. erzeugten Knotenmenge arbeiten nachfolgende Patch-Anweisungen. Es existieren solche:

* zum Setzen und Löschen von Attributen,

* zum Entfernen von Elementen und

* zum Setzen von Text.


*  `SetAttribute` "Attributname" value="Attributwert" +
setzt in jedem Element des aktuellen Knoten- bzw. Elementsets das Attribut auf den genannten Wert. Wenn das Attribut nicht vorhanden ist wird es erzeugt. +
Beispiel: +
`SetAttribute "name" value="OpenOffice Writer"`

*  `AddAttribute` "Attributname" value="Attributwert" +
setzt das Attribut dagegen nur auf Attributwert, wenn es vorher nicht existiert, ein vorhandenes Attribut behält seinen Wert. Z.B. würde die Anweisung +
`AddAttribute "name" value="OpenOffice Writer"` +
eine vorher vorhandene Festlegung auf ein anderes Programm nicht überschreiben.

*  `DeleteAttribute` "Attributname" +
wird das betreffende Attribut von jedem Element der aktuellen Knotenmenge entfernt.

*  `DeleteElement` "Elementname" +
entfernt das Element, dessen Hauptknoten den (Tag-) Namen "Elementname" hat, samt Unterknoten aus der aktuellen Knoten- oder Elementmenge. 

Schließlich existieren zwei Anweisungen zum Setzen bzw. Hinzufügen von Textinhalten eines Elements. 
Die beiden Anweisungen lauten 

*  `SetText` "Text"

und

*  `AddText` "Text"

Z.B. wird, wenn das betreffende Element in der geöffneten Elementmenge liegt, durch die Anweisung +
`SetText "rtf"` +
aus + 
'<fileExtensions>doc<fileExtensions>' +
das Element +
'<fileExtensions>rtf<fileExtensions>'

Mit +
`SetText ""` +
wird der Text komplett entfernt.

`AddText "rtf"` +
setzt analog wie bei anderen Add-Anweisungen den Text, sofern kein Text vorhanden ist -  existierender Text bleibt unberührt.

[[opsi-winst-xmlpatch-return]]
==== Rückgaben an das aufrufende Programm

Eine XMLPatch-Sektion kann angewiesen werden, String-Listen an das rufende Programm zurückzugeben. 

Dazu muss sie in einer primären Sektion mit der String-Listen-Anweisung `getReturnListFromSection` aufgerufen werden. Die Anweisung kann in einem String-Listen-Ausdruck verwendet werden, z.B. das Ergebnis einer String-Listen-Variable zugewiesen werden. So kann in der XMLPatch_mime-Sektion stehen:
[source,winst]
----
DefStringList $list1$
set $list1$=getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----

Eine Return-Anweisung in der XMLPatch-Sektion regelt, welche Zeilen die XMLPatch-Sektion als Inhalt der String-Liste ermittelt:

*  `return elements`+ 
Bewirkt, dass die ausgewählten Elemente komplett (Elementname und Attribute) ausgegeben werden.

*  `return attributes` + 
Erzeugt eine Liste der Attribute.

*  `return elementnames` + 
Listet die Elementnamen. 

*  `return attributenames`
Produziert eine Liste der Attributnamen.

*  `return text` +
Listet die textlichen Inhalte der selektierten Elemente.

*  `return counting` +
Liefert eine Listenstruktur mit summarischen Informationen: In Zeile 0 steht die Anzahl aller ausgewählten Elemente, in Zeile 1 die Zahl aller Attribute. 

[[opsi-winst-xmlpatch-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_xml$ = "on"'


[[opsi-winst-progman]]
=== ProgmanGroups-Sektionen

Dieser Sektionstyp ist abgekündigt.

[[opsi-winst-winbatch]]
=== WinBatch-Sektionen

In einer WinBatch-Sektion kann jedes Windows-Programm als Anweisung verwendet werden. Wie auch aus dem Windows Explorer heraus können Daten-Dateien, die mit einem Programm verknüpft sind, direkt aufgerufen werden. 

Z.B kann mit folgender WinBatch-Sektion ein Setup-Programm gestartet werden:
[source,winst]
----
[winbatch_install]
%scriptpath%\setup.exe
----

[[opsi-winst-winbatch-params]]
==== Aufrufparameter (Modifier)

Durch die Parameter des WinBatch-Aufrufs wird festgelegt, wie sich '{opsi-winst}' gegenüber den in der WinBatch-Sektion gestarteten Programmen verhält.

*  `/WaitOnClose` +
Default +
{opsi-winst} wartet die Selbstbeendigung des angestoßenen Prozesses ab. Dieses Verhalten kann mit dem Parameter auch explizit definiert werden. 

*  `/LetThemGo` +
Verschiebt den aufgerufenen Prozess in den Hintergrund und wartet *nicht* auf dessen Beendigung;
d.h. das sofort die nächste Zeile der WinBatch-Sektion bzw. die nächste Zeile des übergeordneten Programms abgearbeitet werden.

*  `/WaitSeconds` [AnzahlSekunden] +
Die Parametrisierung /WaitSeconds [AnzahlSekunden] modifiziert das Verhalten dahingehend, dass '{opsi-winst}' jeweils erst nach [AnzahlSekunden] die Skriptbearbeitung fortsetzt. Die angegebene Zeit stoppt '{opsi-winst}' auf jeden Fall. In der Default-Einstellung wird zusätzlich auf das Ende der angestoßenen Prozesse gewartet. Ist letzteres nicht gewünscht, so kann der Parameter mit dem Parameter /LetThemGo kombiniert werden.

*  `/WaitForWindowAppearing` [Fenstertitel] +
bzw. +
`/WaitForWindowVanish` [Fenstertitel] +
Abgekündigt. Verwenden Sie `/WaitForProcessEnding` +
Im 1. Fall wartet '{opsi-winst}' solange, bis ein Prozess, der sich durch ein mit [Fenstertitel] benanntes Fenster kenntlich macht, gestartet ist. Im 2. Fall wartet '{opsi-winst}' bis ein, mit [Fenstertitel] benanntes, Fenster auf dem Desktop erst einmal erscheint und dann auch wieder geschlossen wird. Auf diese Weise kann unter geeigneten Umständen geprüft werden, ob sekundäre, indirekt gestartete Prozesse sich beendet haben.
+
CAUTION: Diese Befehle erkennen nur Fenster von 32 Bit-Programmen.

 
*  `/WaitForProcessEnding` <program name> +
Wartet darauf, das sich der Prozess mit dem Namen <program name> beendet. +
Kann und sollte mit `/TimeOutSeconds` kombiniert werden.

*  `/TimeOutSeconds` <seconds> +
Bricht eine Wartebedingung nach Ablauf von <seconds> ab, auch wenn die Wartebedingung noch nicht erfüllt ist. +
Beispiel: 
+
[source,winst]
----
Winbatch_uninstall /WaitForProcessEnding "uninstall.exe" /TimeOutSeconds 20
[Winbatch_uninstall]
%ScriptPath%\uninstall_starter.exe
----

*  `getLastExitCode` +
Die String-Funktion getLastExitCode gibt den ExitCode des letzten Prozessaufrufs der vorausgehenden WinBatch Sektion aus.

[[opsi-winst-winbatch-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_winbatch$ = "on"'

[[opsi-winst-dosbatch]]
=== DOSBatch/DosInAnIcon (ShellBatch/ShellInAnIcon) Sektionen

DOSBatch-Sektionen (auch ShellBatch genannt) sollen in erster Linie dazu dienen, vorhandene Kommandozeilenroutinen für bestimmte Zwecke zu nutzen. '{opsi-winst}' wartet auf die Beendigung des DOS-Batch, bevor die nächste Sektion des Skripts abgearbeitet wird. 

Eine DosBatch-Sektion wird bei der Abarbeitung des Skripts in eine temporäre Batch-Datei '_winst.bat' umgewandelt. Da die Datei in 'c:\tmp' angelegt wird, muss dieses Verzeichnis existieren und zugänglich sein. Die Batch-Datei wird dann in einem Kommando-Fenster mit cmd.exe als Kommando-Interpreter ausgeführt. Dies erklärt warum in einer DosBatch Sektion alle Windows Shell Kommandos verwendet werden können. 

Gegenüber dem Aufruf einer cmd-Datei per Winbatch-Sektion bietet die DosBatch Sektionen drei Vorteile:

* In der Sektion vorhandene '{opsi-winst}' Variablen oder Konstanten werden vor der Ausführung durch Ihren Inhalt ersetzt und können so unkompliziert verwendet werden.

* Die Ausgaben des Aufrufs werden in der Logdatei abgespeichert.

* Die Ausgaben des Aufrufs können einer String-Liste übergeben und weiterverarbeitet werden.

Der Sektionstyp DOSInAnIcon oder ShellInAnIcon ist identisch mit der betreffenden DOSBatch Syntax und ausführenden Methoden. Allerdings wird das aufgerufenen Fenster minimiert dargestellt.

CAUTION: Verwenden Sie keine Kommandos, die auf Eingaben warten.

[[opsi-winst-dosbatch-params]]
==== Aufrufparameter

Parameter des Aufrufs der DosBatch-Sektion in der Actions-Sektion werden unmittelbar als Parameter der Batch-Datei interpretiert. 

Zum Beispiel bewirken die Anweisungen in Actions-Sektionen bzw. der Sektion
DosBatch_1 :
[source,winst]
----
[Actions]
DosBatch_1 today we say "Hello World" 

[DosBatch_1]
@echo off
echo %1 %2 %3 %4
pause
----

die Ausführung des Dos-Batch-Befehls echo mit Parametern "Hello" und "World".

[[opsi-winst-dosbatch-catchout]]
==== Einfangen der Ausgaben

Sollen die Ausgaben, die von Befehlen einer DosBatch-Sektion kommen, aufgefangen werden, so geschieht dies mittels `getOutStreamFromSection ()` aus der Haupt-Sektion des {opsi-winst}-Skripts (siehe <<opsi-winst-stringlist-getstring,Kapitel "(Wieder-) Gewinnen von Einzelstrings aus String-Listen">>). 

Sollen die zurückgegebenen Strings weiterverarbeitet werden, so wird dringend geraten, vor den Befehlszeilen ein '@'-Zeichen zu verwenden bzw. die Kommandos mit '@echo off' zu beginnen. Dies unterdrückt die Ausgabe der Befehlszeile selbst, die je nach System anders formatiert sein kann. 

[[opsi-winst-dosbatch-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_dos$ = "on"'

[[opsi-winst-registry]]
=== Registry-Sektionen

Diese Funktion ist nur unter Windows verfügbar.

Registry-Sektionen dienen dem Erzeugen und Patchen von Einträgen in der Windows-Registrierdatenbank, wobei die Eintragungen mit dem {opsi-winst}-üblichen Detaillierungsgrad protokolliert werden. 

[[opsi-winst-registry-examples]]
==== Beispiele

Man kann eine Registry-Variable setzen indem man die Sektion mit Registry_TestPatch aufruft, wo sie dann wie folgt angegeben ist
[source,winst]
----
[Registry_TestPatch]
openkey [HKEY_Current_User\Environment\Test]
set "Testvar1"  = "c:\rutils;%Systemroot%\hey" 
set "Testvar2" = REG_DWORD:0001
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_subregistry$ = "on"'

[[opsi-winst-registry-params]]
==== Aufrufparameter

* Die Standardform der Registry-Sektionen ist unparametrisiert. Dies genügt, weil auf dem Windows-PC nur eine einzige Registrierdatenbank gibt und somit das globale Ziel der Bearbeitung feststeht.

*  `/AllNTUserDats` +
Es gibt jedoch die Möglichkeit, dass die Patches einer Registry-Sektion automatisch für "alle NT User", entsprechend den verschiedenen User-Zweigen der Registry, vorgenommen werden. Das entsprechende Verfahren bei der Abarbeitung der Sektion wird mit dem Parameter `/AllNTUserDats` aufgerufen.

Außerdem kontrollieren Parameter mit welchen syntaktische Varianten Registry-Sektionen angefordert werden kann:

*  `/regedit` +
Wird das Registry-Kommando mit dem Parameter `/regedit` verwendet, so kann der Export eines Registry-Teilzweiges mit dem Programm, der mit dem gewöhnlichen Windows-Registry-Editor regedit erstellt wurde, direkt als Eingabedatei für Registry dienen (vgl. Abschnitt  <<opsi-winst-registry-regedit,"Registry-Sektionen im Regedit-Format">>).

*  `/addReg` +
Eine weitere Variante des Registry-Aufrufs dient dazu, die Patch-Anweisungen für die Registry zu verarbeiten, die im inf-Datei-Standard erstellt sind. Zur Kennzeichnung dient der Parameter /addReg (in Anlehnung an die entsprechende Abschnittsbezeichnung in einer inf-Datei)(vgl. Abschnitt <<opsi-winst-registry-addreg,"Registry-Sektionen im AddReg-Format">>).

Diese nicht '{opsi-winst}' spezifischen syntaktischen Varianten sind im Handbuch nicht beschrieben, da sie normalerweise automatisch generiert werden.

Weiterhin gibt es die Aufrufparameter,

*  `/32Bit` +
*  `/64Bit` +
*  `/SysNative` +

welche auf 64 Bit-Systemen das Schreiben in den 32 Bit- bzw. 64 Bit-Zweig der Registry beeinflusst (siehe <<opsi-winst-64bit,Kapitel 64 Bit-Unterstützung>>).

[[opsi-winst-registry-commands]]
==== Kommandos

Die Syntax der Defaultform einer Registry-Sektion ist an der Kommandosyntax anderer Patchoperationen des '{opsi-winst}' orientiert.

Es existieren die Anweisungen:

*  `OpenKey`

*  `Set`

*  `Add`

*  `Supp`

*  `GetMultiSZFromFile`

*  `SaveValueToFile`

*  `DeleteVar`

*  `DeleteKey`

*  `ReconstructFrom`

*  `Flushkey`


Im Detail:

*  `OpenKey` <Registryschlüssel> +
Öffnet den bezeichneten Schlüssel in der Registry zum Lesen (und wenn der eingeloggte User über die erforderlichen Rechte verfügt zum Schreiben); existiert der Schlüssel noch nicht, wird er erzeugt.

Registry-Schlüssel sind ja hierarchisch organisierte Einträge Registrierungsdatenbank. Die hierarchische Organisation drückt sich in der mehrstufigen Benennung aus: Für die oberste (Root-) Ebene können standardmäßig insbesondere die "high keys" 'HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS' und 'HKEY_CURRENT_CONFIG' verwendet werden. Gebräuchliche Abkürzungen sind 'HKCR, HKCU, HKLM' und 'HKU'.

In der '{opsi-winst}' Syntax bei den Registry-Pfaden werden die weiteren folgenden Ebenen jeweils durch einen Backslash getrennt.

Alle anderen Kommandos arbeiten mit einem geöffneten Registry-Key.

*  `Set` <Varname> = <Value> +
setzt die durch <Varname> bezeichnete Registry-Variable auf den Wert <Value>, wobei es sich sowohl bei <Varname> als auch bei <Value> um Strings handelt, die in Anführungszeichen eingeschlossen sind. Existiert die Variable noch nicht, wird sie erzeugt. Es gibt auch den Leerstring als Variablenname; dieser entspricht dem "(Standard)"-Eintrag im  Registry-Schlüssel.

Soll eine Registry-Variable erzeugt oder gesetzt werden, die nicht den Defaulttyp "Registry-String" (REG_SZ), muss die erweiterte Form der Set-Anweisung verwendet werden:

*  `Set` <Varname> = <Registrytyp>:<Value> + 
Setzt die durch <Varname> bezeichnete Registry-Variable auf den Wert <Value> des Typs <Registrytyp>. Es werden folgende Registry-Typen interpretiert:

'REG_SZ'::: (String)

'REG_EXPAND_SZ'::: (ein String, der vom System zu expandierende Teilstrings wie %Systemroot% enthält)

'REG_DWORD'::: (ganzzahlige Werte)

'REG_BINARY'::: (binäre Werte, in zweistelligen Hexadezimalen, d.h. 00 01 02 .. 0F  10 .., notiert)

'REG_MULTI_SZ'::: (Arrays von String-Werten, die in {opsi-winst}-Syntax durch das Zeichen "|" getrennt werden;
+
Beispiel für REG_MULTI_SZ:
[source,winst]
----
set "myVariable" = REG_MULTI_SZ:"A|BC|de"
----

Wenn ein Multi-String zunächst zusammengestellt werden soll, kann dies zeilenweise in einer Datei geschehen, die man dann mit Hilfe der Anweisung GetMultiSZFromFile (s.u.) einliest. 

*  `Add` <Varname> = <Value>
+
bzw.
+
`Add` <Varname> = <Registrytyp> <Value> +
arbeitet analog zu Set mit dem Unterschied, dass nur Variablen hinzugefügt, Einträge für bestehende Variablen nicht verändert werden.

*  `Supp` <Varname> <Listenzeichen> <Supplement> +
Dieses Kommando liest den String-Wert der Variablen <varname>, einer Liste aus Werten, die separiert werden durch <Listenzeichen> und den String <supplement> zu dieser Liste (wenn sie noch nicht enthalten sind), aus. Wenn  <supplement> die <separator> enthält, können mit diesen Listenzeichen die Einträge in einzelne Strings unterteilt werden und die Prozedur wird für jeden Teilstring angewendet.
+
Eine typische Verwendung ist der Eintrag zu einer Pfadvariablen, die in der Registry definiert ist. 
+
Supp behält den ursprünglichen Stringtyp (REG_EXPAND_SZ bzw. REG_SZ) bei.
+
Beispiel:
+
Der allgemeine Systempfad wird festgelegt durch den Eintrag der Variable Path im Registrierschlüssel
+
'KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environmen'
+
Wenn dieser Schlüssel mit OpenKey geöffnet ist, kann mit der Anweisung
+
`supp "Path" ; "C:\utils;%JAVABIN%"`
+
der Pfad ergänzt werden, um die Einträge '"C:\utils"' sowie '"%JAVABIN%"'.
+
(Weil der Registry-Eintrag für den Systempfad den Datentyp REG_EXPAND_SZ hat, expandiert Windows %JAVABIN% automatisch zum entsprechenden Verzeichnisnamen, falls %JAVABIN% ebenfalls als Variable definiert ist).
+
Unter Win2k ist das Phänomen zu beobachten, dass sich der path-Eintrag nur per Skript auslesen (und dann patchen) lässt, wenn vor dem Lesen ein Wert gesetzt wird.
+
Der alten Wert von Path wird aus der Umgebungsvariable auslesen, wieder in die Registry zurückgeschrieben und dann ist es möglich mit der Registry-Variablen zu arbeiten.
+
[source,winst]
----
[Actions] 
DefVar $Path$ 
set $Path$ = EnvVar ("Path") 
Registry_PathPatch 

[Registry_PathPatch] 
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\control\Session Manager\Environment] 
set "Path"="$Path$" 
supp "Path"; "c:\orawin\bin"
----
+
CAUTION: Nach dem Patchen des Registry-Path enthält die Umgebungsvariable Path den veränderten Wert erst nach einem Reboot.

*  `GetMultiSZFromFile` <Dateiname> +
Liest eine Datei zeilenweise in einen Multistring ein.

*  `SaveValueToFile` <varname> <filename> +
Exportiert die genannten Werte (String oder MultiSZ) in die Datei <filename> 

*  `DeleteVar` <Varname> +
Löscht den Eintrag mit Bezeichnung <Varname> aus dem geöffneten Schlüssel.

*  `DeleteKey` <Registryschlüssel> +
Löscht den Registry-Key rekursiv samt aller Unterschlüssel und den enthaltenen Registry-Variablen und -Werten. Zur Syntax, in der der Registrierschlüssel angegeben wird, vgl. OpenKey. 
+
Beispiel:
+
[source,winst]
----
[Registry_KeyLoeschen]
deletekey [HKCU\Environment\subkey1]
----

*  `ReconstructFrom` <Dateiname> +
(abgekündigt)

*  `FlushKey` +
Sorgt dafür, dass die Einträge des Schlüssels nicht mehr nur im Speicher gehalten, sondern auf die Platte gespeichert werden (geschieht automatisch beim Schließen eines Keys, insbesondere beim Verlassen einer Registry-Sektion).

[[opsi-winst-registry-allntuser]]
==== Registry-Sektionen, die `alle NTUser.dat` patchen

Wird eine Registry-Sektion mit dem Parameter `/AllNTUserdats` aufgerufen, so werden ihre Anweisungen für alle auf dem NT-System angelegten User ausgeführt.

Dazu werden zunächst die Dateien NTUser.dat für alle auf dem System eingerichteten User-Accounts durchgegangen (in denen die Registry-Einstellungen aus 'HKEY_Users' abgelegt sind). Sie werden temporär in einen Hilfszweig der Registry geladen und dort entsprechenden der Anweisungen der Sektion bearbeitet. Weil dies für den zum Zeitpunkt der Programmausführung angemeldeten User nicht funktioniert, werden die Anweisungen der Sektion zusätzlich für 'HKEY_Current_User' ausgeführt. Als Ergebnis verändert sich die gespeicherte NTUser.dat.

Dieser Mechanismus funktioniert nicht für einen angemeldeten User, da seine NTUser.dat in Benutzung ist und der Versuch die Datei zu laden einen Fehler produziert. Damit aber auch für den angemeldeten User Änderungen durchgeführt werden, werden die Registry Kommandos ebenfalls auf den Bereich 'HKEY_Current_User' angewendet ('HKEY_Users' ist der Zweig für den angemeldeten Benutzer).

Auch künftig erst angelegte Accounts werden mit erfasst, da auch die NTUser.dat aus dem Profilverzeichnis des 'Default Users' bearbeitet wird.

Die Syntax der Sektion ist die einer Standard-Registry-Sektion. Allerdings werden alle Schlüsselnamen relativ interpretiert. D.h. *der Hauptkey ist wegzulassen*: Im folgenden Beispiel werden faktisch die Registry-Einträge für die Variable 'FileTransferEnabled' unter 'HKEY_Users\XX\Software...' neu hergestellt, sukzessive für alle User auf der Maschine:
[source,winst]
----
[Registry_AllUsers]
openkey [Software\ORL\WinVNC3]
set "FileTransferEnabled"=reg_dword:0x00000000
----

[[opsi-winst-registry-regedit]]
==== Registry-Sektionen im Regedit-Format

Bei Aufruf von Registry mit dem Parameter `/regedit` wird der Inhalt der Registry-Sektion in dem Exportformat erwartet, dass das Standard-Windows-Programm regedit erzeugt. 

Die von regedit generierten Exportdateien haben – von der Kopfzeile abgesehen - den Aufbau von Ini-Dateien haben. Beispiel:
[source,ini]
----
REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org]

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\general]
"bootmode"="BKSTD"
"windomain"=""
"opsiconf"=dword:00000001

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\shareinfo]
"user"="pcpatch"
"pcpatchpass"=""
"depoturl"="\\\\bonifax\\opt_pcbin\\install"
"configurl"="\\\\bonifax\\opt_pcbin\\pcpatch"
"utilsurl"="\\\\bonifax\\opt_pcbin\\utils"
"utilsdrive"="p:"
"configdrive"="p:"
"depotdrive"="p:"
----

Die Sektionen bezeichnen hier Registry-Schlüssel, die geöffnet werden sollen. Die einzelnen Zeilen stehen für die gewünschten Setzungen von Variablen (entsprechend dem Set-Befehl in {opsi-winst}-Registry-Sektionen).

Diese Anweisungen können aber nun nicht als Sektion innerhalb eine '{opsi-winst}' Skripts untergebracht werden. Daher kann die Registry Sektion mit dem Parameter `/regedit` nur als ausgelagerte Sektion oder über die Funktion loadTextFile geladen werden:
[source,winst]
----
registry "%scriptpath%/opsiorgkey.reg" /regedit
----

Zu beachten ist noch, dass regedit ab Windows XP nicht mehr das Regedit4-Format produziert, sondern ein Format, dass durch die erste Zeile +
'"Windows Registry Editor Version 5.00"' +
gekennzeichnet ist.

Windows sieht hier zusätzliche Wertetypen vor. Gravierender ist, dass die Exportdatei ursprünglich in Unicode erzeugt wird. Um sie mit den 8 Bit-Mitteln der Standardumgebung des '{opsi-winst}' zu verarbeiten, muss der Zeichensatz konvertiert werden. Die Konvertierung kann z.B. mit einem geeigneten Editor durchgeführt werden. Eine andere Möglichkeit besteht darin, die Konvertierung on the fly vom '{opsi-winst}' durchführen zu lassen. Dazu lässt sich die String-Listenfunktion `loadUnicodeTextFile` verwenden. Wenn z.B. printerconnections.reg ein Unicode-Export ist, wäre regedit in folgender Form aufzurufen:
[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----

Auch eine Registry-Patch im regedit-Format kann „für alle NT-User“ ausgeführt werden, sinngemäß in der gleichen Weise wie oben für das gewöhnliche winst-Registry-Patch-Format beschrieben. D.h. der Root-Schlüssel 'HKCU' muss aus den Angaben entfernt werden und dann wird aus + '[HKEY_CURRENT_USER\Software\ORL]' -> '[Software\ORL].'

[[opsi-winst-registry-addreg]]
==== Registry-Sektionen im AddReg-Format

Die Syntax einer Registry-Sektion, die mit dem Parameter `/addReg` aufgerufen wird, folgt der Syntax von '[AddReg]'-Sektionen in inf-Dateien, wie sie z.B. von Treiberinstallationen verwendet wird.

Beispiel:
[source,ini]
----
[Registry_ForAcroread]
HKCR,".fdf","",0,"AcroExch.FDFDoc"
HKCR,".pdf","",0,"AcroExch.Document"HKCR,"PDF.PdfCtrl.1","",0,"Acr"
----

[[opsi-winst-opsiservicecall]]
=== OpsiServiceCall Sektion

Mit dieser Sektion ist es möglich Informationen abzufragen – oder Daten zu bestimmen – mit Hilfe des opsi Service. Es gibt drei Optionen, mit denen man die Verbindung zum opsi Service definieren kann:

* Per Voreinstellung wird vorausgesetzt, dass das Skript in der Standard opsi Installationsumgebung ausgeführt werden kann. D.h. es besteht eine Verbindung zum opsi Service, die genutzt wird.

* Es wird eine URL für den gewünschten Service und ebenso der benötigte Benutzername und das Passwort als Sektionsparameter gesetzt. 

* Es kann ein interaktives Login für den Service gesetzt werden – mit einer voreingestellten Service URL und dem Benutzernamen, wenn das gewünscht wird.

Die abgerufenen Daten können als String-Liste zurückgegeben und dann für die Verwendung in Skripten benutzt werden.

[[opsi-winst-opsiservicecall-params]]
==== Aufrufparameter

Es gibt Optionen, mit denen man die Verbindung zu einem opsi Service angeben kann und Einstellungen, die für die Verbindung benötigt werden. 

Verbindungsparameter können mit Hilfe von

*  `/serviceurl` <url to the opsi web service>

*  `/username` <web service user name>

*  `/password` <web service user password>

gesetzt werden. Wenn diese Parameter definiert sind (oder zumindest einer der Parametern), wird versucht eine Verbindung zu der genannten Service URL herzustellen.

Wenn kein Parameter ausgewiesen ist, kann eine bestehende Verbindung wieder verwendet werden.

Mit der Option

*  `/interactive` +
kann man bestimmen, dass eine interaktive Verbindung benutzt werden soll. Das bedeutet, dass der Benutzer die Verbindungsdaten bestätigen muss und das Passwort eingibt. Diese Option kann damit nicht in Skripten verwendet werden, die voll automatisch ausgeführt werden sollen. 

Wenn keine Verbindungsparameter vorgegeben sind setzt der '{opsi-winst}' vorraus, dass die bestehende Verbindung wieder benutzt werden soll.

Wenn keine Verbindungsparameter angegeben und auch die Option „interactive“ nicht ausgewählt wird (weder bei diesem Skript noch zuvor), wird vorausgesetzt das der '{opsi-winst}' mit dem Standard opsi Bootprozess arbeitet und sich darüber mit dem opsi Service verbindet. Theoretisch gibt es eine Verbindung zu einem zweiten opsi Service, die als Verbindung zu dem Standard opsi Service mit der Option

*  `/preloginservice` + 
neu gestartet werden kann.

[[opsi-winst-opsiservicecall-syntax]]
==== Sektionsformat

Ein `opsiServiceCall`, welcher eine existierende Verbindung zu einem opsi Service benutzt, wird bestimmt durch den Methodennamen und eine Parameterliste.

Beide werden in dem Sektionsabschnitt definiert und haben folgendes Format:
[source,winst]
----
"method":<method name>
"params":[
	<params>
	]
----

Dabei sind <params> kein, ein oder auch mehrere durch Komma getrennte Strings.
Welche Parameter benötigt werden, hängt von der aufgerufenen Methode ab.

Beispiel:
[source,winst]
----
[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

Die Sektion erstellt eine Liste der PC-Namen (IDs) von allen lokalen opsi Benutzern. Wenn es für andere Zwecke als Test und Dokumentation genutzt werden soll, kann die Sektion als ein Teil eines String-Listen Ausdrucks (vgl. das folgende Beispiel) verwendet werden.
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")
----
Die Verwendung von GetReturnListFromSection ist dokumentiert in dem Kapitel zur String-Listenverarbeitung dieses Handbuchs (siehe <<opsi-winst-stringlist-create-by-section,Kapitel "String-Listen-Erzeugung mit Hilfe von Sektionsaufrufen">>).

Ein Hash, der eine Namensliste mit Wertepaaren enthält, wird durch den folgenden opsi Service aufgerufen (beinhaltet keine leere Parameterliste):
[source,winst]
----
[opsiservicecall_hostHash]
"method": "getHost_hash"
"params": [
	"pcbon8.uib.local"
	]
----

CAUTION: Die opsiservicecall Sektionen sind für opsi 3.x Methoden entwickelt worden und für die opsi 4.x Methoden häufig nicht verwendbar. So sind '*_getIdents' Aufrufe zwar möglich, '*_getObjects' Aufrufe aber nicht.

[[opsi-winst-opsiservicecall-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_opsiServiceCall$ = "on"'

[[opsi-winst-execpython]]
=== ExecPython Sektionen

Die ExecPython Sektionen basieren auf Shell-Sektionen (ähnlich wie DosInAnIcon). Während diese den Inhalt der Sektion dem Interpreter cmd.exe übergeben, wird der Inhalt einer ExecPython Sektion dem Python Interpreter übergeben (welcher auf dem System installiert sein muss).

Beispiel

Das folgende Beispiel demonstriert einen execPython Aufruf mit einer Parameterliste zu dem 'print' Python-Kommando. 

Der Aufruf könnte wie folgt aussehen
[source,winst]
----
execpython_hello -a "option a" -b "option b" "there we are"

[execpython_hello]
import sys
print "we are working in path: ", a
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"


print "hello"
----

Die Ausgabe des Druck-(print) Kommandos wird gesammelt und in einen Logdatei geschrieben. So kann man die folgende Logdatei bekommen
[source,winst]
----
output:
 --------------
-a
option a
-b
option b
there we are
       hello
----

Anzumerken ist hierbei, dass der loglevel auf '1' gesetzt werden muss, damit die Ausgabe wirklich den Weg in die Logdatei findet.

[[opsi-winst-execpython-combine]]
==== Verflechten eines Python Skripts mit einem '{opsi-winst}' Skript

Aktuell ist die execPython Sektion dem '{opsi-winst}' Skript über vier Kategorien von gemeinsam genutzten Daten integriert:

* Eine Parameterliste geht zum Python Skript über.

* Alles was vom Python Skript gedruckt wird, wird in die '{opsi-winst}' log-Datei geschrieben.

* Der '{opsi-winst}' Skript Mechanismus für die Einführung von Konstanten und Variablen in Sektionen arbeitet erwartungsgemäß für die execPython Sektion.

* Die Ausgabe einer execPython Sektion kann umgewandelt werden in eine String-Liste und dann vom laufenden '{opsi-winst}' Skript weiter verwendet werden.

Ein Beispiel für die ersten beiden Wege der Verflechtung des Python Skripts mit dem '{opsi-winst}' Skript werden im Anschluss beschrieben. Es wurde erweitert, damit einige der Werte von '{opsi-winst}' Konstanten oder Variablen aufgerufen werden können.
[source,winst]
----
[execpython_hello]
import sys
a = "%scriptpath%"
print "we are working in path: ", a
print "my host ID is ", "%hostID%"
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"

print "the current loglevel is ", "$loglevel$" 
print "hello"
----

Allerdings muss die '$loglevel$' Variable vor dem Aufruf der ExecPython Sektionn gesetzt werden:
[source,winst]
----
DefVar $LogLevel$
set $loglevel$ = getLoglevel
----

Damit wir am Ende in der Lage sind, die Ergebnisse der Ausgabe weiter zu verarbeiten, wird eine String-List Variable erstellt, die über die execPython Sektion folgendermaßen aufgerufen werden kann:
[source,winst]
----
DefStringList pythonresult
Set pythonResult = GetOutStreamFromSection('execpython_hello -a "opt a“')
----

[[opsi-winst-execpython-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_compare_to_python$ = "on"'

[[opsi-winst-execwith]]
=== ExecWith Sektionen

'ExecWith' Sektionen sind verallgemeinerte 'DosBatch' bzw. 'ExecPython' Sektionen: Welches Programm den Inhalt der Sektionen ausführt wird durch einen Parameter beim Sektionsaufruf bestimmt.

Wenn der Aufruf so lautet: +
`execPython_hello -a "hello" -b "world"`
+
so sind
+
`-a "hello" -b "world"`
+
Parameter, die vom Phythonskript akzeptiert werden. Mit dem ExecWith Aufruf sieht der gleiche Ausdruck wie folgt aus:
+
`execWith_hello "python" PASS -a "hello" -b "world" WINST /EscapeStrings`

Die Option `/EscapeStrings` wird automatisch in der ExecPython Sektion benutzt und bedeutet, dass Backslahes und Konstanten in String-Variablen dupliziert werden, bevor sie das aufgerufene Programm interpretiert.

==== Aufrufsyntax

Generell haben wir die Aufrufsyntax:

`ExecWith`'_SECTION PROGRAM PROGRAMPARAS' `pass` 'PASSPARAS' `winst` 'WINSTOPTS'

Jeder der Ausdrücke 'PROGRAM, PROGRAMPARAS, PASSPARAS, WINSTOPTS' sind frei wählbare -Ausdrücke oder eine String-Konstante (ohne Anführungszeichen). 

Die Schlüsselwörter `PASS` und `WINST` dürfen fehlen, wenn der entsprechende Part nicht existiert.

Es gibt zwei weitere '{opsi-winst}' Optionen zu beachten:

*  `/EscapeStrings`

*  `/LetThemGo`

Wie bei ExecPython Sektionen wird die Ausgabe einer ExecWith Sektion in einer String-Liste über die Funktion `getOutStreamFromSection` erfasst.

Die erste Option erklärt, dass die Backslahes in '{opsi-winst}' Variablen und Konstanten sind - ähnlich wie in der Programmiersprache 'C'. Die zweite Option hat den Effekt (wie für `winBatch` Aufrufe), dass das aufgerufene Programm in einem neuen Thread seine Arbeit beginnt, während der '{opsi-winst}' mit dem Auslesen des Skripts fortfährt.

Mehr Beispiele

Der folgende Aufruf verweist auf eine Sektion, die ein 'autoit3'-Skript ist, dass auf zu öffnende Fenster wartet (dafür ist die Option `/letThemGo` zu benutzen), um sie dann in der aufgerufenen Reihenfolge zu schließen:
[source,winst]
----
ExecWith_close "%SCRIPTPATH%\autoit3.exe" WINST /letThemGo 
----

Ein einfacher Aufruf
[source,winst]
----
ExecWith_edit_me "notepad.exe"  WINST /letThemGo
----
öffnet einen Texteditor und zeigt die Sektionszeilen an (allerdings keine Zeilen die mit einem Komma starten, da der '{opsi-winst}' solche Zeilen als Kommentarzeile ausliest und sie eliminiert bevor sie ausgeführt werden).

[[opsi-winst-execwith-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_autoit3_test$ = "on"'.

[[opsi-winst-ldapsearch]]
=== LDAPsearch Sektion

Eine LDAPsearch Sektion beschreibt eine Suchanfrage an ein LDAP Verzeichnis, die ausgeführt wird und auch die Antwort empfängt (und wenn möglich im Cache speichert). 

Bevor wir zu den '{opsi-winst}' Kommandos übergehen, gibt es erst noch einige Erklärungen zum Syntax von LDAP selbst

[[opsi-winst-ldapsearch-general]]
==== LDAP – Protokoll, Service, Verzeichnis

LDAP bedeutet "Lightweight Directory Access Protocol" und ist, wie der Name besagt, ein festgelegter Weg der Kommunikation mit einem Datenverzeichnis.

Dieses Verzeichnis ist für gewöhnlich hierarchisch organisiert. Es ist eine hierarchische Datenbank oder ein Datenbaum.

Ein *LDAP Service* implementiert das Protokoll zum Lesen und Schreiben auf diesem Verzeichnis. Ein Verzeichnis, dass über einen LDAP Service angesteuert werden kann, nennt sich *LDAP directory*.

Für ein Beispiel werfen einen Blick auf einen Bereich eines LDAP Verzeichnisbaums mit Daten aus dem opsi LDAP-Backend (angezeigt im Open Source LDAP-Browser JXPlorer).

.Ansicht von verschiedenen Bereichen des opsi LDAP Baums
image::../images/ldap-in-jxplorer.png["opsi LDAP Baum",width=400]

Ein *LDAP search request* ist ein Suchabfrage an das LDAP Verzeichnis über einen LDAP Service. Als Antwort werden verschiedene Inhalte des Datenverzeichnisses zurückgegeben.

Grundsätzlich beschreiben Suchabfragen den Pfad im Verzeichnisbaum, der zu der gewünschten Information führt. Der Pfad ist der *distinguished name* (dn) zusammen gesetzt aus den Namen der Knoten ( "relative distinguished names") welche den Pfad bilden. Zum Beispiel:

'local/uib/opsi/generalConfigs/bonifax.uib.local'

Da jeder Knoten als eine Instanz einer strukturellen Objektklasse konzipiert ist, wird die Pfadbeschreibung in folgender Form ausgegeben: mit  Klassentyp (und beginnend mit dem letzten Pfadelement):

'cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local'

Der Pfad in einer Abfrage muss nicht notwendigerweise „komplett“ sein und auch nicht zu einem einzelnen Blatt (Teil) des Baumes führen. Im Gegenteil, unvollständige Pfade sind üblich. 

Aber auch wenn der Pfad zu einem einzelnen Blatt führt, kann dieses wiederum mehrere Werte enthalten. Jeder Knoten des Baumes hat eine oder mehrere Klassen als Attributtypen. Zu jeder Klasse können ein oder mehrere Werte zugehörig sein. 

Bei einem gegebenen Abfragepfad könnten wir uns interessieren für 

. für die Knoten – auch LDAP Objekte genannt – zu welchen der Pfad führt,

. für die Attribute, die zu den Knoten gehören,

. und die Werte, die sowohl zu den Objekten wie zu den Attributen gehören.

Offensichtlich ist der Umgang mit der Fülle der Informationen möglicher Antworten die vorrangige Herausforderung bei der Abwicklung von LDAP Abfragen.

Der folgende Abschnitt zeigt eine LDAP Abfrage über den Bereich des LDAP Baums, welcher in der obenstehenden Grafik abgebildet ist.

Beispiel einer LDAP Antwort

Eine '{opsi-winst}' Sektion `ldapsearch_generalConfigs` ist wie folgt definiert:
[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=generalConfigs,cn=opsi,dc=uib,dc=local
----

Der Sektionsaufruf gibt eine LDAP Antwort zurück, die folgendermaßen aussieht:
[source,ini]
----
Result: 0
  Object: cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	generalConfigs
  Attribute: objectClass
	organizationalRole
Result: 1
  Object: cn=pcbon4.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	pcbon4.uib.local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: opsiKeyValuePair
	test2=test
	test=a b c d
Result: 2
  Object: cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: cn
	bonifax.uib.local
  Attribute: opsiKeyValuePair
	opsiclientsideconfigcaching=FALSE
	pcptchlabel1=opsi.org
	pcptchlabel2=uib gmbh
	button_stopnetworking=
	pcptchbitmap1=winst1.bmp
	pcptchbitmap2=winst2.bmp
	debug=on
	secsuntilconnectiontimeout=280
	opsiclientd.global.log_level=
----

Es gibt nun verschiedene '{opsi-winst}' Optionen, um die Komplexität der Auswertung der Ergebnisse solcher Anfragen zu reduzieren und zu handhaben.

[[opsi-winst-ldapsearch-params]]
==== LDAPsearch Aufrufparameter

Für den Aufruf von LDAPSearch Sektionen sind zwei Typen von Optionen definiert.

* cache options
* output options

Die 'cache options' sind:

*  `/cache`

*  `/cached`

*  `/free`

* (no cache option)

Wenn keine cache Option spezifiziert wurde, wird die Antwort der LDAP Suche nicht für zukünftige Anwendung gespeichert.

Bei der `/cache` Option wird die Antwort für zukünftige Auswertungen gespeichert, die `/cached` Option verweist auf die letzte gespeicherte Antwort, welche wiederverwendet wird, statt eine neue Suche zu starten, die `/free` Option löscht die gecachten Antworten (dies ist vor allem bei Suchanfragen mit sehr langen Antworten sinnvoll).

Die output options sind: 

*  `/objects`

*  `/attributes`

*  `/values`

* (no output option)

Die Ausgabeoptionen bestimmen die String-Listen, die produziert werden, wenn eine LDAPsearch Sektion über getReturnlistFromSection aufgerufen wird:

* Wenn die Ausgabeoptionen nicht näher spezifiziert werden, wird die komplette LDAP Antwort aufgelistet.

* Die Optionen objects, attributes und values beschränken die Ausgabe entsprechend auf Zeilen zu Objekten, Attributen bzw. Werten in der LDAP Antwort.

Zu beachten ist, dass die ausgegebenen Listen von Attributen nur dann dem richtigen Objekt zu geordnet werden können, wenn die gesamte Ausgabe nur noch ein Objekt enthält. Ebenso sind Werte nur dann dem korrekten Attribut zuordnenbar, wenn nur noch ein Attribut in der Ausgabeliste vorkommt.

Daher wird so vorgegangen, dass eine ursprüngliche Suche immer weiter eingeengt wird bis nur noch ein Objekt bzw. Attribut zurückgegeben wird. Dies kann über entsprechende Count Aufrufe überprüft werden. 

Die Einengung der ursprünglichen Suche geht sehr schnell, wenn diese auf der gecachten Antwort durchgeführt wird.

[[opsi-winst-ldapsearch-narrow-search]]
==== Einengung der Suche

Ein Beispiel soll zeigen, wie die Suche soweit eingeschränkt werden kann, damit ein bestimmtes Ergebnis bei einer Suche im LDAP Verzeichnis erreicht werden kann.

Wir starten mit dem Aufruf von 'ldapsearch_generalConfigs' (wie oben beschrieben), fügen den cache Parameter hinzu,

`ldapsearch_generalconfigs /cache`

die Abfrage wird ausgeführt und die Antwort für zukünftige Nutzung gespeichert.

Dann gibt der Aufruf

`getReturnlistFromSection("ldapsearch_generalconfigs /cached /objects")`

folgende Liste aus
[source,ini]
----
cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=pcbon4.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----

Wenn wir die Auswahl im Baumverzeichnis mit
[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
----

einschränken und nochmal starten, enthält die Objektliste nur noch folgende Einträge
[source,ini]
----
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----

Die dazugehörige Attributliste enthält drei Elemente:
[source,ini]
----
objectclass
cn
opsikeyvaluepair
----

Um die zugehörigen Werte zu einem einzelnen Attribut zu bekommen, muss die Abfrage noch erweitert werden:
[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
attribute: opsiKeyValuePair
----

Das Ergebnis ist eine Attributliste, die nur ein Element enthält. Die Liste mit den zugehörigen Werten sieht wie folgt aus
[source,ini]
----
opsiclientsideconfigcaching=false
pcptchlabel1=opsi.org
pcptchlabel2=uib gmbh
button_stopnetworking=
pcptchbitmap1=winst1.bmp
pcptchbitmap2=winst2.bmp
debug=on
secsuntilconnectiontimeout=280
opsiclientd.global.log_level=6
----

Es gibt keine LDAP Mittel um diese Ergebnis noch weiter einzugrenzen!

(Aber die '{opsi-winst}' Funktion getValue (key, list) (vgl. <<opsi-winst-stringlist-getstring, Kapitel "(Wieder-) Gewinnen von Einzelstrings aus String-Listen">>) hilft in diesem Fall: z.B. getValue ("secsuntilconnectiontimeout", list) würde die gewünschte Zahl ausgeben).

Mit der Funktion `count` (list) kann überprüft werden, ob die Eingrenzung der Suchabfrage erfolgreich war. In den meisten Fällen ist gewünscht, dass das Ergebnis "1" ist.

[[opsi-winst-ldapsearch-syntax]]
==== LDAPsearch Sektion Syntax

Eine LDAPsearch Sektion beinhaltet die Spezifikationen:

*  `targethost:` +
Der Server, der das LDAP Verzeichnis verwaltet/gespeichert wird (service), muss benannt werden.

*  `targetport:` +
Wenn der Port eines LDAP Service nicht der voreingestellte Port von 389, muss er an dieser Stelle angegeben werden. Wenn die Spezifizierung nicht erfolgt, wird der Default-Port verwendet.

*  `dn:` +
Hier kann der charakteristische Name (distinguished name), der „Suchpfad“, für die Suchanfrage gegeben werden.

*  `typesonly:` +
Per Voreinstellung ist der Wert "false", was bedeutet das auch die Werte ermittelt werden.

*  `filter:` +
Der Filter für eine LDAP Suche hat eine spezielle LDAP Syntax, die nicht vom '{opsi-winst}' überprüft wird. Voreingestellt ist "(objectclass=*)".

*  `attributes:` +
Durch Kommas werden die Attributnamen in einer Liste getrennt. Die Default-Einstellung ist eine Liste, in der alle Attribute aufgeführt werden.

[[opsi-winst-ldapsearch-examples]]
==== Beispiele

Ein kurze und sehr realistische Beispiel soll am Ende dieses Abschnittes aufgeführt werden:

'$founditems$' ist eine StringList Variable und $opsiClient$ ist eine String-Variable. Der Aufruf von 'getReturnlistFromSection' liefert die Ergebnisse. Das nachfolgende Codefragment gibt das eindeutige Ergebnis für $opsiDescription$ zurück, wenn dieses existiert. Es vermeldet einen Fehler, wenn die Suche ein unerwartetes Ergebnis zurück gibt:
[source,winst]
----
set $opsiClient$ = "test.uib.local"
set $founditems$ = getReturnlistFromSection("ldapsearch_hosts /values")

DefVar $opsiDescription$
set $opsiDescription$ = ""
if count(founditems) = "1"
  set $opsiDescription$ = takeString(0, founditems)
else
  if count(founditems) = "0"
    comment "No result found")
  else
    logError "No unique result for LdAPsearch for client " + $opsiclient$ 
  endif
endif


[ldapsearch_hosts]  
targethost: opsiserver
targetport:               
dn: cn=$opsiclient$,cn=hosts,cn=opsi,dc=uib,dc=local
typesOnly: false
filter: (objectclass=*)
attributes: opsiDescription
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_ldap_search$ = "on"'.

[[opsi-winst-64bit]]
== 64 Bit-Unterstützung

Der '{opsi-winst}' ist ein 32 Bit-Programm. Damit sich auch 32 Bit-Programme auf 64 Bit-Systemen normal arbeiten können, gibt es für 32 Bit-Programme sowohl in der Registry als auch im Dateisystem Spezialbereiche auf die Zugriffe umgeleitet werden, die sonst in 64 Bit vorbehaltenen Bereichen landen würden.

So wird ein Zugriff auf 'c:\windows\system32' umgelenkt auf 'c:\windows\syswow64'.

Aber ein Zugriff auf 'c:\program files' wird *nicht* umgelenkt auf 'c:\program files (x86)'

So wird ein Registry Zugriff auf '[HKLM\software\opsi.org]' umgelenkt auf '[HKLM\software\wow6432node\opsi.org]'.

{opsi-winst} installiert daher als 32 Bit-Programm Skripte, die unter 32 Bit laufen, auch in 64 Bit-Systemen korrekt. 

Für die Installation von 64 Bit-Programmen liefern einige alte Konstanten wie '%ProgramFilesDir%'´ für 64 Bit-Programme die falschen Werte. Daher gibt es ab winst Version 4.10.8 folgende Neuerungen:

In der Regel kann (und sollte) nun explizit angegeben werden, wohin geschrieben und woher gelesen werden soll. Dazu gibt es drei Varianten:

32::	Explizit 32 Bit

64::	Explizit 64 Bit. Wenn es das nicht gibt, dann architekturspezifisch.

SysNative::	Entsprechend der Architektur auf dem das SKript läuft.

Entsprechend gibt es zusätzlichen Konstanten:


.Konstanten
[options="header"]
|=======================
|Konstante|32 Bit|64 Bit
|`%ProgramFilesDir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles32Dir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles64Dir%`|c:\program files|c:\program files
|`%ProgramFilesSysnativeDir%`|c:\program files|c:\program files
|=======================


`%ProgramFilesDir%`:: sollte in Zukunft besser gemieden werden.

`%ProgramFiles32Dir%`:: sollten Sie verwenden, wenn Sie explizit 32 Bit-Software installieren wollen.

`%ProgramFiles64Dir%`:: sollten Sie verwenden, wenn Sie explizit 64 Bit-Software installieren wollen.

`%ProgramFilesSysnativeDir%`:: sollten Sie verwenden, wenn Sie auf den Default der Architektur zugreifen wollen.

Für den Zugriff auf eigentlich 64 Bit-Software vorbehaltene Bereiche kennt der '{opsi-winst}' folgende zusätzlichen Befehle:

*  `GetRegistrystringvalue32`
*  `GetRegistrystringvalue64`
*  `GetRegistrystringvalueSysNative`
*  `FileExists32`
*  `FileExists64`
*  `FileExistsSysNative`

`Registry`-Sektionen schreiben in den 32 Bit-Bereich der Registry. Ebenfalls werden in `Files`-Sektionen Zugriffe auf 'c:\windows\system32' umgelenkt.

Für `Registry` und `Files` Sektionen gibt es daher nun die Aufrufparameter:

*  `/32Bit`
+
Das ist der Default. Schreibzugriffe werden in die 32 Bit-Registry bzw. das 32 Bit-Systemverzeichnis gelenkt.

*  `/64Bit` +
Schreibzugriffe werden in die 64 Bit-Registry bzw. das 64 Bit-Systemverzeichnis gelenkt. Gibt es diesen nicht, so wird der architekturspezifische Zweig verwendet.

*  `/SysNative` +
Schreibzugriffe werden in den architekturspezifischen Zweig der Registry bzw. des Systemverzeichnisses gelenkt.

Als weitere Möglichkeit für explizite 64 Bit-Operationen wird bei der Installation des opsi-client-agent die Datei 'c:\windows\system32\cmd.exe' nach 'c:\windows\cmd64.exe' kopiert. Durch den Aufruf von SKripten mit dieser 'cmd64.exe' im Rahmen von `ExecWith` Sektionen können beliebige 64 Bit-Operationen ausgeführt werden. 

Beispiele: +
File handling:
[source,winst]
----
if $INST_SystemType$ = "64 Bit System"
	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "64 Bit redirection"
	Files_copy_test_to_system32
	if FileExists("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 'cmd.exe' /C
	Files_copy_test_to_system32 /64Bit
	if FileExists64("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 '%SystemRoot%\cmd64.exe' /C
endif
----

Registry Handling:
[source,winst]
----
message "Write to 64 Bit Registry"
if ($INST_SystemType$ = "64 Bit System")
	set $ConstTest$ = ""
	set $regWriteValue$ = "64"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "%systemroot%\cmd64.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
else
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
endif

if ($INST_SystemType$ = "64 Bit System")
	set $regWriteValue$ = "64"
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
else
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
endif
----

[[opsi-winst-cookbook]]
== Kochbuch

In diesem Kapitel sind Skript-Beispiele zusammengestellt, wie durch den Einsatz verschiedener '{opsi-winst}' Funktionen gewisse Aufgaben, die sich in ähnlicher Weise immer wieder stellen, bewältigt werden können.

[[opsi-winst-cookbook-recursive-delete]]
=== Löschen einer Datei in allen Userverzeichnissen

Seit '{opsi-winst}' Version 4.2 gibt es für diese Aufgabe eine einfache Lösung: Wenn etwa die Datei alt.txt aus allen Userverzeichnissen gelöscht werden soll, so kann der folgende Files-Sektions-Aufruf verwendet werden:
[source,winst]
----
files_delete_Alt /allNtUserProfiles

[files_delete_Alt]
delete "%UserProfileDir%\alt.txt"
----

Für ältere '{opsi-winst}' Versionen sei hier noch ein Workaround dokumentiert, der hilfreiche Techniken enthält, die eventuell für andere Zwecke dienen können.
Folgende Zutaten werden benötigt:

* Eine DosInAnIcon-Sektion, in der ein dir-Befehl die Liste aller Verzeichnisnamen produziert.

* Eine Files-Sektion, die das Löschen der Datei alt.txt in einem bestimmten Verzeichnis anstößt.

* Eine String-Listen-Verarbeitung, die alles miteinander verknüpft.

Das Ganze kann z.B. so aussehen:
[source,winst]
----
; in der Actions-Sektion:

; Variable für den Dateinamen:
DefVar $loeschDatei$ = "alt.txt"

; Variablendeklaration für die String-Listen
DefStringList list0
DefStringList list1

; Einfangen der vom Dos-dir-Befehl produzierten Zeilen
Set list0 = getOutStreamFromSection ('dosbatch_profiledir')

; Aufruf einer Files-Sektion für jede Zeile
for $x$ in list0 do files_delete_x

; Und hier die beiden benötigten Spezialsektionen:
[dosbatch_profiledir]
dir "%ProfileDir%" /b

[files_delete_x]
delete "%ProfileDir%\$x$\$LoeschDatei$"
----

[[opsi-winst-cookbook-service-running]]
=== Überprüfen, ob ein spezieller Service läuft

Wenn wir überprüfen wollen, ob eine spezieller Service (beispielsweise der "opsiclientd") läuft und ihn, falls er nicht läuft, starten wollen, müssen wir folgendes Skript verwenden.

Um eine Liste der laufenden Services angezeigt zu bekommen, müssen wir das Kommando +
`net start` + 
in einer DosBatch Sektion starten und das Ergebnis in der $list0$ erfassen. Wir gleichen die Liste ab und iterieren die Elemente, um zu sehen, ob der spezielle Service beinhaltet ist. Wenn er nicht da ist, wird er gestartet.
[source,winst]
----
[Actions]
DefStringList $list0$
DefStringList $list1$
DefStringList $result$
Set $list0$=getOutStreamFromSection('DosBatch_netcall')
Set $list1$=getSublist(2:-3, $list0$)

DefVar $myservice$
DefVar $compareS$
DefVar $splitS$
DefVar $found$
Set $found$ ="false"
set $myservice$ = "opsiclientd"


comment "============================"
comment "search the list"
; for developping loglevel = 7
; setloglevel=7
; in normal use we dont want to log the looping
setloglevel = 5
for %s% in $list1$ do sub_find_myservice
setloglevel=7
comment "============================"

if $found$ = "false"
   set $result$ = getOutStreamFromSection ("dosinanicon_start_myservice")
endif


[sub_find_myservice]
set $splitS$ = takeString (1, splitStringOnWhiteSpace("%s%"))
Set $compareS$ = $splitS$ + takeString(1, splitString("%s%", $splitS$))
if $compareS$ = $myservice$
   set $found$ = "true"
endif


[dosinanicon_start_myservice]
net start "$myservice$"


[dosbatch_netcall]
@echo off
net start 
----

[[opsi-winst-cookbook-local-admin]]
=== Skript für Installationen im Kontext eines lokalen Administrators

In manchen Situationen kann es sinnvoll oder notwendig sein, ein '{opsi-winst}' Skript als lokal eingeloggter Benutzer auszuführen anstatt wie üblich im Kontext eines Systemdienstes. Beispielsweise kann es sein, dass Softwareinstallationen, die vom '{opsi-winst}' aus aufgerufen werden, zwingend einen Benutzerkontext benötigen oder dass bestimmte Dienste, die für den Installationsvorgang wichtig sind, erst nach dem Login zur Verfügung stehen. 

MSI-Installationen, die eine lokalen User benötigen lassen, sich häufig durch die Option 'ALLUSERS=2' dazu "überreden" auch ohne aus zukommen. Beispiel:
[source,winst]
----
[Actions]
DefVar $LOG_LOCATION$
Set $LOG_LOCATION$ = "c:\tmp\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb ALLUSERS=2 /l* $LOG_LOCATION$ /i %SCRIPTPATH%\files\myproduct.msi
----

Eine andere aufwendigere Möglichkeit dieses Problem zu lösen, ist einen administrativen User temporär anzulegen und diesen zur Installation des Programms zu verwenden.

Dazu gehen Sie wie folgt vor:

Legen im Verzeichnis 'install\produkid' ein Verzeichnis 'localsetup' an.
Verschieben Sie die gesamten Installationsdateien in dieses Verzeichnis.
Benennen Sie das Installationsscript von '<produktname>.ins' in 'local_<produktname>.ins' um.
Erzeugen Sie im Verzeichnis 'install\produktname' eine neue '<produktname>.ins' mit dem nachfolgenden Inhalt und passen Sie in diesem SKript in der Actions-Sektion die Variablen an (siehe unten). Der Rest des Skriptes bleibt unberührt.

Sorgen Sie dafür, dass das in 'local_<produktname>.ins' umbenannte Skript am Ende einen *Reboot* auslöst. 

Dazu sollte der letzte ausgeführte Befehl der Actions-Sektion folgende Zeile sein:

`ExitWindows /Reboot`

Am Anfang des 'local_<produktname>.ins' Skripts fügen Sie einen Aufruf ein um das Passwort des temporären lokalen Administrators im Autologin zu löschen:
[source,winst]
----
[Actions]
Registry_del_autologin
;....

[Registry_del_autologin]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"=""
set "DefaultPassword"=""
----
Das nachfolgende abgedruckte '{opsi-winst}' Skript-Template erzeugt temporär den gewünschten Benutzerkontext, führt in ihm eine Installation aus und beseitigt ihn schließlich wieder. Für die Verwendung sind die folgende Variablen zusetzen:

* der richtige Wert für die Variable `$Productname$`,
* der richtige Wert für die Variable `$ProductSize$` und
* `$LockKeyboard$` auf „true“, um das Keyboard zu sperren.

Das Skript führt im Einzelnen folgende Schritte aus:

* Anlegen eines lokalen Administrator opsiSetupAdmin;
* Sichern des bisherigen Autologon-Zustands;
* Eintragen des opsiSetupAdmin als Autologon-User;
* Installationsdateien auf den Client kopieren (wohin steht in `$localFilesPath$`), dort befindet sich das Installationsskript, das als lokaler Benutzer ausgeführt werden soll;
* RunOnce-Eintrag in der Registry anlegen, der den '{opsi-winst}' mit dem lokalen Skript als Argument aufruft;
* Neustart des Client (damit die Änderungen an der Registry Wirkung haben);
* '{opsi-winst}' startet und führt ExitWindows /ImmediateLogout aus: durch den Autologon meldet sich nun automatisch der Benutzer opsiSetupAdmin an, es wird der RunOnce-Befehl ausgeführt;
* nun läuft die Installation ganz normal, jedoch am Ende des Skripts muss zwingend neugestartet werden (also mit ExitWindows /ImmediateReboot), da sonst die Oberfläche des momentan eingeloggten Users opsiSetupAdmin mit Administratorrechten(!) freigegeben wird;
* nach dem Reboot wird wieder aufgeräumt (alten Zustand von Autologon wiederherstellen, lokale Setup-Dateien löschen, Benutzerprofil von opsiSetupAdmin löschen).

Wie man sieht, gliedert sich die Installation in 2 Bereiche: ein Skript, das als Service ausgeführt wird, alles zum lokalen Login vorbereitet und später wieder aufräumt (Masterscript) und ein Skript, dass als lokaler Administrator ausgeführt wird und die eigentliche Setup-Routine für das Produkt enthält (Localscript).

CAUTION: Erfordert das Localscript mehr als nur einen Reboot, muss auch das Masterscript verändert bzw. um diese Anzahl von Reboots erweitert werden. Solange das Localscript nicht fertig ist, muss das Masterscript ein ExitWindows /ImmediateLogout ausführen, um die Kontrolle an das Localscript zu übergeben. Der RunOnce-Eintrag muss dann immer wieder neu gesetzt werden. Ebenso müssen Username und Passwort des Autologins nach jedem Reboot neu gesetzt werden.

Es gibt keinen direkten Zugang vom lokalen Skript auf die Produkteigenschaften (üblicherweise erfolgt der Zugang über die String-Funktion GetProductProperty). Wenn Werte benötigt werden, müssen diese über das Masterskript geholt werden und werden ggf. temporär in der Registry gespeichert.

Es kann Produktinstallationen (also aus dem Localscript heraus) geben, die Schlüssel in der Registry verändern, die vorher vom Masterscript gesichert und am Ende durch dieses wieder überschreiben werden. In diesem Fall muss die Wiederherstellung der Werte im Masterscript unterbunden werden.

Das Localscript läuft unter eingeloggtem Administrator Account. Wenn hier nicht Keyboard/Maus gesperrt werden, besteht für den Anwender die Möglichkeit das Skript zu unterbrechen und Administrator zu werden.

Das Passwort des temporären opsiSetupAdmin wird in nachfolgenden Beispiel durch die Funktion RandomStr bestimmt.

Damit die Verarbeitung der Passwörter nicht geloggt wird, wird der LogLevel zeitweise auf -2 gesetzt.

IMPORTANT: Verwenden Sie aktualisierte Versionen des folgenden Beispiels aus dem Templateprodukt: opsi-template-with-admin.
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.

; TEMPLATE for
; Skript fuer Installationen im Kontext eines temporaeren lokalen Administrators
; installations as temporary local admin
; see winst_manual.pdf / winst_handbuch.pdf

; !!! requires winst32.exe version 4.2.x !!!

;
; !!! Das lokale Installations-Skript, das durch den temporaeren lokalen Admin ausgefuehrt wird
; !!! (sein Name steht in $LocalSetupScript$), muss mit dem Befehl  
; !!! exitWindows /Reboot
; !!! enden
; 

; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; Vorarbeiten/Voraussetzungen/Doku pruefen wie in Winsthandbuch
; 8.3 Skript fuer Installationen im Kontext eines lokalen Administrators
; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


[Actions]
requiredWinstVersion >= 4.10.6
setLogLevel=7
DefVar $ProductName$
DefVar $ProductSizeMB$
DefVar $LocalSetupScript$
DefVar $LockKeyboard$
DefVar $OpsiAdminPass$
DefVar $OS$
DefVar $MinorOS$
DefVar $MsVersion$
DefVar $RebootFlag$
DefVar $ShutdownRequested$
DefVar $WinstRegKey$
DefVar $RebootRegVar$
DefVar $AutoName$
DefVar $AutoPass$
DefVar $AutoDom$
DefVar $AutoLogon$
DefVar $AutoBackupKey$
DefVar $LocalFilesPath$
DefVar $LocalWinst$
DefVar $SystemType$
DefVar $platform_cmdexe$
DefVar $DefaultLoglevel$
DefVar $PasswdLogLevel$
DefVar $AdminGroup$
DefVar $SearchResult$

DefStringlist $ResultList$
DefStringlist $ResultList2$
DefStringlist $ResultList3$

comment "set $LockKeyboard$ to true to prevent user hacks while admin is logged in"
Set $LockKeyboard$="true"
Set $LockKeyboard$="false"
Set $ProductName$ = "opsi-template-with-admin"
Set $ProductSizeMB$ = "1"

Set $LocalSetupScript$ = "local_setup.ins"
set $OS$ = GetOS
set $MinorOS$ = GetNTVersion
Set $SystemType$ = GetSystemType
Set $MsVersion$ = GetMsVersionInfo
set $DefaultLoglevel$ = "7"
comment " set $PasswdLogLevel$ to 0 for production"
Set $PasswdLogLevel$="7"
SetLogLevel=$DefaultLoglevel$

if not (fileExists ("%Scriptpath%\psgetsid.exe"))
	LogError "psgetsid.exe is missing. Please install it from http://download.sysinternals.com/Files/PsTools.zip to %Scriptpath%"
	isFatalError
endif

if not(($SystemType$ = "64 Bit System") or ($SystemType$ = "x86 System"))
	LogError "Unknown Systemtype: "+$SystemType$+" - aborting"
	isFatalError
endif

if $SystemType$ = "64 Bit System"
	set $platform_cmdexe$ = "%SystemRoot%\cmd64.exe"
else
	set $platform_cmdexe$ = "%System%\cmd.exe"
endif

comment "handle Rebootflag"
Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
Set $RebootFlag$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"RebootFlag")
Set $ShutdownRequested$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"ShutdownRequested")

sub_test_autologon_data

comment "some paths required"
Set $AutoBackupKey$ = $WinstRegKey$+"\AutoLogonBackup"
Set $LocalFilesPath$ = "C:\opsi_local_inst"
Set $LocalWinst$ = "c:\opsi\utils\winst32.exe"
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\preloginloader\utils\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\preloginloader\opsi-winst\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\opsi-client-agent\opsi-winst\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	LogError "No opsi-winst found. Abborting."
	isFatalError
endif

comment "show product picture"
ShowBitmap /3 "%scriptpath%\localsetup\"+$ProductName$+".png" $ProductName$

if not (($RebootFlag$ = "1") or ($RebootFlag$ = "2") or ($RebootFlag$ = "3"))
	comment "Part before first Reboot"
	comment "just reboot - this must be done if this is the first product after OS installation"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "1"
	Registry_SaveRebootFlag
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2 or 3)

if $RebootFlag$ = "1"
	comment "Part before second Reboot"

	if not(HasMinimumSpace ("%SYSTEMDRIVE%", ""+$ProductSizeMB$+" MB"))
		LogError "Not enough space on drive C: . "+$ProductSizeMB$+" MB on C: required for "+$ProductName$
		isFatalError
	endif
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 1..."
	sub_Prepare_AutoLogon

	comment "we need to reboot now to be sure that the autologon work"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "2"
	Registry_SaveRebootFlag
	sub_test_autologon_data
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2)

if ($RebootFlag$ = "2")
	comment "Part after first Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "3"
	Registry_SaveRebootFlag
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 2..."
	Registry_enable_keyboard /64bit
	comment "now let the autologon work"
	comment "it will stop with a reboot"
	ExitWindows /ImmediateLogout
endif ; Rebootflag = 2

if ($RebootFlag$ = "3")
	comment "Part after second Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "0"
	Registry_SaveRebootFlag
	
	comment "Lets work..."
	Message "Cleanup "+$ProductName$+" install (step 3)..."
	sub_Restore_AutoLogon
	set $SearchResult$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce] opsi_autologon_setup")
	if $SearchResult$ = $LocalWinst$+" "+$LocalFilesPath$+"\"+$LocalSetupScript$+" /batch"
		LogError "Localscript did not run. We remove the RunOnce entry and abort"
		Registry_del_runonce /64Bit
		isFatalError
	endif
	comment "This is the clean end of the installation"
endif ; Rebootflag = 3
ExitWindows /Reboot

[sub_Prepare_AutoLogon]
comment "copy the setup script and files"
Files_copy_Setup_files_local
comment "read actual Autologon values for backup"
set $AutoName$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultUserName")
comment "if AutoLogonName is our setup admin user, something bad happend"
comment "then let us cleanup"
if ($AutoName$="opsiSetupAdmin")
	set $AutoName$=""
	set $AutoPass$=""
	set $AutoDom$=""
	set $AutoLogon$="0"
else
	set $AutoPass$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
	set $AutoDom$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
	set $AutoLogon$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")
endif

comment "backup AutoLogon values"
Registry_save_autologon

comment "prepare the admin AutoLogon"
SetLogLevel=$PasswdLogLevel$
set $OpsiAdminPass$= randomstr
Registry_autologon /64Bit

comment "get the name of the admin group"
comment "using psgetsid from sysinernals pstools"
set $ResultList$ = getOutStreamFromSection("DosInAnIcon_get_admin_group")
set $AdminGroup$ = takeString(6,$ResultList$)
set $AdminGroup$ = takeString(1,splitstring($AdminGroup$,"\"))
comment "create our setup admin user"
DosInAnIcon_makeadmin
SetLogLevel=$DefaultLoglevel$

comment "remove c:\tmp\winst.bat with password"
Files_remove_winst_bat

comment "store our setup script as run once"
Registry_runOnce /64Bit

comment "disable keyboard and mouse while the autologin admin works"
if ($LockKeyboard$="true")
	Registry_disable_keyboard /64Bit
endif

[sub_test_autologon_data]
set $AutoPass$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
set $AutoDom$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
set $AutoLogon$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")

[sub_Restore_AutoLogon]
comment "read AutoLogon values from backup"
set $AutoName$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultUserName")
set $AutoPass$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultPassword")
set $AutoDom$= GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultDomainName")
set $AutoLogon$= GetRegistryStringValue("["+$AutoBackupKey$+"] AutoAdminLogon")

comment "restore the values"
SetLogLevel=$PasswdLogLevel$
Registry_restore_autologon /64Bit
SetLogLevel=$DefaultLoglevel$
comment "delete our setup admin user"
DosInAnIcon_deleteadmin
comment "cleanup setup script, files and profiledir"
Files_delete_Setup_files_local
comment "delete profiledir"
DosInAnIcon_deleteprofile

[Registry_save_autologon]
openkey [$AutoBackupKey$]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[Registry_restore_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[DosInAnIcon_deleteadmin]
NET USER opsiSetupAdmin  /DELETE

[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$RebootFlag$"

[Files_copy_Setup_files_local]
copy -s %ScriptPath%\localsetup\*.* $LocalFilesPath$

[Files_delete_Setup_files_local]
delete -sf $LocalFilesPath$
; folgender Befehl funktioniert nicht vollständig, deshalb ist er zur Zeit auskommentier
; der Befehl wird durch die Sektion "DosInAnIcon_deleteprofile" ersetzt (P.Ohler)
;delete -sf "%ProfileDir%\opsiSetupAdmin"

[DosInAnIcon_deleteprofile]
rmdir /S /Q "%ProfileDir%\opsiSetupAdmin"

[DosInAnIcon_get_admin_group]
@echo off
"%ScriptPath%\psgetsid.exe" /accepteula S-1-5-32-544

[DosInAnIcon_makeadmin]
NET USER opsiSetupAdmin $OpsiAdminPass$ /ADD
NET LOCALGROUP $AdminGroup$ /ADD opsiSetupAdmin

[Registry_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="opsiSetupAdmin"
set "DefaultPassword"="$OpsiAdminPass$"
set "DefaultDomainName"="localhost"
set "AutoAdminLogon"="1"

[Registry_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
set "opsi_autologon_setup"='"$LocalWinst$" "$LocalFilesPath$\$LocalSetupScript$" /batch'

[Registry_del_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
DeleteVar "opsi_autologon_setup"

[Registry_disable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x4
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x4

[Registry_enable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x1
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x1

[Files_remove_winst_bat]
delete -f c:\tmp\_winst.bat
----

[[opsi-winst-cookbook-patchxml]]
=== XML-Datei patchen: Setzen des Vorlagenpfades für OpenOffice.org 2.0

Das Setzen des Vorlagenpfades kann mit Hilfe der folgenden Skriptteile erfolgen:
[source,winst]
----
[Actions]
; ....

DefVar $oooTemplateDirectory$
;----------------------------------------------------------------------
;set path here:

Set $oooTemplateDirectory$ = "file://server/share/verzeichnis"
;----------------------------------------------------------------------
;...

DefVar $sofficePath$
Set $sofficePath$= GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\OpenOffice.org\OpenOffice.org\2.0] Path")
DefVar $oooDirectory$
Set $oooDirectory$= SubstringBefore ($sofficePath$, "\program\soffice.exe")
DefVar $oooShareDirectory$
Set $oooShareDirectory$ = $oooDirectory$ + "\share"

XMLPatch_paths_xcu $oooShareDirectory$+"\registry\data\org\openoffice\Office\Paths.xcu"
; ...


[XMLPatch_paths_xcu]
OpenNodeSet
- error_when_no_node_existing false
- warning_when_no_node_existing true
- error_when_nodecount_greater_1 false
- warning_when_nodecount_greater_1 true
- create_when_node_not_existing true
- attributes_strict false

documentroot
all_childelements_with:
elementname: "node"
attribute:"oor:name" value="Paths"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="Template"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="InternalPaths"
all_childelements_with: 
elementname: "node"

end

SetAttribute "oor:name" value="$oooTemplateDirectory$"
----

[[opsi-winst-cookbook-readxml]]
=== XML-Datei einlesen mit dem {opsi-winst}

Wie bereits im vorangehenden <<opsi-winst-cookbook-patchxml,Kapitel "XML-Datei patchen">> beschrieben, lassen sich auch XML-Dateien mit dem '{opsi-winst}' einlesen. Hier soll nun exemplarisch gezeigt werden, wie man die Werte eines bestimmten Knotens ausliest. Als Quelle dient dazu folgende XML-Datei:
[source,winst]
----
<?xml version="1.0" encoding="utf-16" ?>
<Collector xmlns="http://schemas.microsoft.com/appx/2004/04/Collector" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:schemaLocation="Collector.xsd" UtcDate="04/06/2006 12:28:17" LogId="{693B0A32-76A2-4FA0-979C-611DEE852C2C}"  Version="4.1.3790.1641" >
   <Options>
      <Department></Department>
      <IniPath></IniPath>
      <CustomValues>
      </CustomValues>
   </Options>
   <SystemList>
      <ChassisInfo Vendor="Chassis Manufacture" AssetTag="System Enclosure 0" SerialNumber="EVAL"/>
      <DirectxInfo Major="9" Minor="0"/>
   </SystemList>
   <SoftwareList>
      <Application Name="Windows XP-Hotfix - KB873333" ComponentType="Hotfix" EvidenceId="256" RootDirPath="C:\WINDOWS\$NtUninstallKB873333$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x4235b909">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873333" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873333$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873333" UninstallString="C:\WINDOWS\$NtUninstallKB873333$\spuninst\spuninst.exe" OsComponent="true" UniqueId="256"/>
         </Evidence>
      </Application>
      <Application Name="Windows XP-Hotfix - KB873339" ComponentType="Hotfix" EvidenceId="257" RootDirPath="C:\WINDOWS\$NtUninstallKB873339$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x9c550c9c">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873339" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873339$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873339" UninstallString="C:\WINDOWS\$NtUninstallKB873339$\spuninst\spuninst.exe" OsComponent="true" UniqueId="257"/>
         </Evidence>
      </Application>
   </SoftwareList>
</Collector>
----

Möchte man nur die Elemente und deren Werte aller „Application“-Knoten auslesen, kann man dies machen mit folgendem Code (nur Ausschnitt):
[source,winst]
----
[Actions]
DefStringList $list$

...

set $list$ = getReturnListFromSection ('XMLPatch_findProducts '+$TEMP$+'\test.xml')
for $line$ in $list$ do Sub_doSomething

[XMLPatch_findProducts]
openNodeSet
	; Knoten „Collector“ ist der documentroot
	documentroot
	all_childelements_with:
	  elementname:"SoftwareList"
	all_childelements_with:
	  elementname:"Application"
end
return elements

[Sub_doSomething]
set $escLine$ = EscapeString:$line$
; hier kann man nun diese Elemente in $escLine$ bearbeiten
----

Hier sieht man auch eine weitere Besonderheit. Es sollte vor dem Benutzen der eingelesenen Zeilen erst ein EscapeString der Zeile erzeugt werden, damit enthaltene Sonderzeichen nicht vom '{opsi-winst}' interpretiert werden. Die Zeile wird nun gekapselt behandelt, sonst könnten reservierte Zeichen wie $,%,“ oder \' leicht zu unvorhersehbaren Fehlfunktionen führen.

'
[[opsi-winst-cookbook-xmlnamespace]]
=== Einfügen einer Namensraumdefinition in eine XML-Datei 

Die '{opsi-winst}' XMLPatch-Sektion braucht eine voll ausgewiesenen XML Namensraum (wie es im XML RFC gefordert wird). Aber es gibt XML Konfigurationsdateien, in denen „nahe liegende“ Elemente nicht deklariert werden (und auslesende Programme, die auch davon ausgehen, dass die Konfigurationsdatei entsprechend aussieht). 

Besonders das Patchen der meisten XML/XCU Konfigurationsdateien von OpenOffice.org erweist sich als sehr schwierig. Um dieses Problem zu lösen hat A. Pohl (Vielen Dank!) die Funktionen XMLaddNamespace und XMLremoveNamespace entwickelt. Die Funktionsweise ist im folgenden Beispiel demonstriert:
[source,winst]
----
DefVar $XMLFile$
DefVar $XMLElement$
DefVar $XMLNameSpace$
set $XMLFile$ = "D:\Entwicklung\OPSI\winst\Common.xcu3" 
set $XMLElement$ = 'oor:component-data'
set $XMLNameSpace$ = 'xmlns:xml="http://www.w3.org/XML/1998/namespace"'

if XMLAddNamespace($XMLFile$,$XMLElement$, $XMLNameSpace$) 
  set $NSMustRemove$="1" 
endif 
;
; now the XML Patch should work
; (commented out since not integrated in this example)
;
; XMLPatch_Common $XMLFile$ 
;
; when finished we rebuild the original format 
if $NSMustRemove$="1" 
  if not (XMLRemoveNamespace($XMLFile$,$XMLElement$,$XMLNameSpace$)) 
    LogError "XML-Datei konnte nicht korrekt wiederhergestellt werden"    
    isFatalError
  endif 
endif 
----

Es ist zu beachten, dass die XML Datei so formatiert wird, dass der Element-Tag-Bereich keine Zeilenumbrüche enthält. 


[[opsi-winst-special-errors]]
== Spezielle Fehlermeldungen

* Keine Verbindung mit dem opsi-Service +
Der '{opsi-winst}' meldet "... cannot connect to service".

Hinweise auf mögliche Probleme gibt die dazu angezeigte Nachricht:

Socket-Fehler #10061, Verbindung abgelehnt::
Möglicherweise läuft der Service nicht

Socket-Fehler #10065, Keine Route zum Host::
Keine Netzwerkverbindung zum Server

HTTP/1.1. 401 Unauthorized::
Der Service antwortet, akzeptiert aber das Passwort nicht.



