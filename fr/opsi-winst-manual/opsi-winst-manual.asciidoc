////
; Copyright (c) uib gmbh (www.uib.de)
; Cette documentation appartient à uib
; et publié sous licence Creative Commons by-sa allemande
; voir:
; http://creativecommons.org/licenses/by-sa/3.0/de/
; http://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; anglais:
; http://creativecommons.org/licenses/by-sa/3.0/
; http://creativecommons.org/licenses/by-sa/3.0/legalcode
; 
; crédits: http://www.opsi.org/credits/
////


:Author:    uib gmbh
:Email:     info@uib.de
:Date:      05.10.2011
:Revision:  4.0.1
:doctype:	book

// Include common opsi terms
include::../common/opsi_terms.asciidoc[]



opsi-winst Manual (4.11.2)
============================

// Include common opsi copyright
include::../common/opsi_manual_copyright.asciidoc[]


[[opsi-winst-introduction]]
== Présentation

Le programme open source '{opsi-winst}' sert dans le contexte de OPSI – serveur d'intégration de pc (cf. www.opsi.org) – comme rôle central pour initier et effectuer l'installation automatique du logiciel. Il peut également être utilisé seul comme un outil pour les programmes d'installation pour n'importe quel logiciel. 

'{opsi-winst}' est fondamentalement un interprète pour un particulier, assez simple, langage de script qui peut être utilisé pour exprimer tous les éléments pertinents d'une installation de logiciel. 

Une installation du logiciel qui est décrit par un script '{opsi-winst}' et exécuté par l'exécution du script a plusieurs avantages par rapport aux installations qui sont gérées par un tas de commandes shell (par exemple copie etc):

* '{opsi-winst}' montre dans le fichier journal très soigneusement toutes les opérations du processus d'installation. L'équipe de support peut vérifier les fichiers journal, et peut facilement détecter quand des erreurs sont survenues ou d'autres circonstances problématiques.

* Les actions de copie peut être configuré avec une grande variété d'options si les fichiers existants doivent être écrasés

* Surtout, il peut être configuré que les fichiers sont copiés selon leur version interne.

* Il y a différents modes pour écrire dans le registre Windows:
** écraser les valeurs existantes
** écrire seulement quand aucune valeur existe
** ajouter une valeur à une valeur existante.

* Le registre de Windows peut être patché pour tous les utilisateurs existant sur un poste de travail (y compris l'utilisateur par défaut, qui est utilisé comme prototype pour d'autres utilisateurs).

* Il y a une syntaxe sophistiquée pour un patch intégré des fichiers de configuration XML.


[[opsi-winst-cliparams]]
== Parametres de la ligne de commande

'{opsi-winst}' peut être démarré avec différents ensembles de paramètres dépendant du contexte et du but de l'utilisation. 

Il y a les suivants schémas syntaxique:

(1) montrer l'utilisation (aide):

`opsi-winst /?` +
`opsi-winst /h`[elp]

(2 ) Exécuter un script 

`opsi-winst` <fichier de script> +
      [`/logfile` <fichier journal> ] +
      [`/batch` | `/histolist` <Chemin du fichier de config de opsi-winst>] +
      [`/usercontext` <[domaine\]nom d'utilisateur> ] +
      [`/parameter` <chaîne de paramètres>]

(3) Exécuter une liste de scripts (séparées par des virgules) un par un:

`opsi-winst` `/scriptfile` <fichier de script> [;<fichier de script>]* [ `/logfile` <fichier journal> ] +
      [`/batch` | `/silent` ] +
      [`/usercontext` <[domaine\]nom d'utilisateur> ] +
      [`/parameter` <chaîne de paramètres>] +

4) Lire la configuration du PC à partir du service OPSI et agir en conséquence, depuis '{opsi-winst}' 4.3

`opsi-winst /opsiservice` <URL du service OPSI> +
     [`/clientid` <nom du client>] +
     [`/username` <nom d'utilisateur>] +
     [`/password` <mot de passe>] +
     [`/sessionid` <id de la session>] +
     [`/logfile` <fichier journal>] +
     [`/allloginscripts`]  +
     [`/silent`]  +
     [`/parameter` <chaîne de paramètres>]
   
Quelques explications:

* Le nom par defaut du fichier de log est `c:\tmp\instlog.txt`

* La chaîne de paramètres, qui se caractérise par l'option `/parameter`, est accessible pour chaque script appelé de '{opsi-winst}' (via la fonction de chaîne `ParamStr`).


Explications pour (2) et (3) :

* Si l'option `/batch` est utilisé, alors '{opsi-winst}' montre seulement sa "batch surface" n'offrant aucune dialogues utilisateur. Par l'option `/silent` même la "batch surface" est supprimée. Sans l'aide de l'option `/batch` nous entrons dans le mode interactif où le fichier de script et le fichier journal peuvent être choisis de manière interactive (principalement pour des fins de test). 

* Le paramètre `winstconfigfilepath` qui est désigné par `/histofile` se réfère à un fichier au format ini qui contient (en mode interactif) les dernières noms de fichier de script utilisé. La surface de dialogue présente une zone de liste qui affiche ces noms de fichiers pour choisir le fichier suivant à interpréter. Si `winstconfigfilepath` se termine par "\" il est supposé être un nom de répertoire et `WINST.INI` sert de nom de fichier.

Explications pour (4):

* La valeur par défaut pour `clientid` est le nom d'ordinateur complet

* Quand il est appellé avec l'option `/allloginscripts` '{opsi-winst}' fait les configurations pour l'utilisateur de la session currante (particulierment dans un contexte de profils Itinerants). C'est un'option en co-financement - vous devez l'acheter pour pouvoir l'utiliser. +
Regardez le manuel d'opsi pôur plus d'information sur  'Le Support des Profils Itinerants'.

* By option `/silent` event the batch surface is suppressed.


Le mode non interactif est implicite.
     
[[opsi-winst-logpath]]
=== Chemins des journaux système

Par défaut les journaux système sont écrits dans le répertoire `c:\tmp` qui  '{opsi-winst}' essaie de créer. Si '{opsi-winst}' n'a pas accès à ce répertoire, il utilise le répertoire temporaire de l'utilisateur. 

Le nom du journal système par défaut est `instlog.txt`. Le nom du fichier journal et l'emplacement seront écrasées par l'option spécifiques en ligne de commande. 

Dans le cas, que '{opsi-winst}' exécute un script dans le mode `/batch` et avec un contexte utilisateur (et de travail) spécifié, le chemin d'enregistrement par défaut est `opsi/tmp` dans le répertoire ApplicationData de l'utilisateur. Ce sera écrasé par un chemin de journal donné explicitement.

En plus, '{opsi-winst}' utilise le répertoire de journalisation pour la sauvegarde de certains fichiers temporaires.

[[opsi-winst-configuration-options]]
== Configurations supplémentaires 

[[opsi-winst-central-logging]]
=== Journalisation centrale des messages d'erreur

Si vous le souhaitez, '{opsi-winst}' écrit les données d'erreur dans un second fichier sur un lecteur réseau ou les envoie à un démon syslog.

La fonction peut être configuré dans le registre Windows:

Dans HKEY_LOCAL_MACHINE, nous avons, dans une installation standard, la clé  \SOFTWARE\opsi.org.  Nous pouvons créer une sous-clé syslogd avec une variable remoteerrorlogging. Sa valeur détermine si, et si oui par quelle méthode, une journalisation centrale doit avoir lieu.

En outre, dans +
'HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\syslogd' +
nous devons observer trois variables:

* Si remoteerrorlogging a la valeur 0, aucun log supplémentaires centrale a lieu (par défaut).

////
* Si remoteerrorlogging a la valeur 1, '{opsi-winst}' essaie d'ouvrir un $pcname$.err dans configshare, sous-répertoire pcpatch\pclog, et écrire les données. 
////

* Si remoteerrorlogging a la valeur 2, les rapports d'erreur sont envoyés à syslog démon. Le nom d'hôte du démon est lu dans la variable sysloghost (défaut localhost) , le numéro du canal syslog peut être configuré à partir de la valeur de la variable syslogfacility (par défaut 18, qui est local2).

Le tableau suivant montre les valeurs possibles:

[source,ini]
----
ID_SYSLOG_FACILITY_KERNEL     = 0;  // messages du kernel 
ID_SYSLOG_FACILITY_USER       = 1;  // messages du niveau utilisateur
ID_SYSLOG_FACILITY_MAIL       = 2;  // système de messagerie
ID_SYSLOG_FACILITY_SYS_DAEMON = 3;  // démons système
ID_SYSLOG_FACILITY_SECURITY1  = 4;  // sécurité / messages d'autorisation (1)
ID_SYSLOG_FACILITY_INTERNAL   = 5;  // messages générés en interne par syslogd
ID_SYSLOG_FACILITY_LPR        = 6;  // imprimante système
ID_SYSLOG_FACILITY_NNTP       = 7;  // sous-système de nouvelles du réseau
ID_SYSLOG_FACILITY_UUCP       = 8;  // UUCP sous-système
ID_SYSLOG_FACILITY_CLOCK1     = 9;  // démon horloge (1)
ID_SYSLOG_FACILITY_SECURITY2  = 10; // sécurité / messages d'autorisation (2)
ID_SYSLOG_FACILITY_FTP        = 11; // démon FTP
ID_SYSLOG_FACILITY_NTP        = 12; // sous-système NTP
ID_SYSLOG_FACILITY_AUDIT      = 13; // journal d'audit
ID_SYSLOG_FACILITY_ALERT      = 14; // journal d'alerte
ID_SYSLOG_FACILITY_CLOCK2     = 15; // démon horloge (2)
ID_SYSLOG_FACILITY_LOCAL0     = 16; // utilisation locale 0  (local0)
ID_SYSLOG_FACILITY_LOCAL1     = 17; // utilisation locale 1  (local1)
ID_SYSLOG_FACILITY_LOCAL2     = 18; // utilisation locale 2  (local2)
ID_SYSLOG_FACILITY_LOCAL3     = 19; // utilisation locale 3  (local3)
ID_SYSLOG_FACILITY_LOCAL4     = 20; // utilisation locale 4  (local4)
ID_SYSLOG_FACILITY_LOCAL5     = 21; // utilisation locale 5  (local5)
ID_SYSLOG_FACILITY_LOCAL6     = 22; // utilisation locale 6  (local6)
ID_SYSLOG_FACILITY_LOCAL7     = 23; // utilisation locale 7  (local7)
----

[[opsi-winst-skins]]
=== Thèmes opsi-winst

Depuis la version 3.6  '{opsi-winst}' a un thème adaptable. Ses éléments sont situés dans un sous-répertoire winstskin du répertoire '{opsi-winst}' en exécution. Le fichier de définition que vous pouvez éditer est skin.ini. 

[[opsi-winst-script]]
== Le script opsi-winst

En principe:  '{opsi-winst}' est un interprète pour un particulier, facile à utiliser, langage de script qui est adapté pour les besoins des installations de logiciels. Un script devrait être une description intégrée, et un moyen de contrôle, pour l'installation d'un logiciel.

La section suivante esquisses de la structure d'un script '{opsi-winst}'. Le but est d'identifier les signets d'un script: de quelle manière nous devons étudier la question pour comprendre son traitement.

Tous les éléments sont décrits plus en détail dans la section plus loin. Le but sera alors de montrer comment les scripts peuvent être modifiés ou développés.

[[opsi-winst-script-first-example]]
=== Un Exemple

Les scripts '{opsi-winst}' sont à peu près issus des fichiers .INI. Ils sont composés de sections, qui sont marquées par un titre (le nom de section), qui est écrite entre parenthèses []. 

Schématiquement un script '{opsi-winst}' ressemble à celui (ici avec une vérification de quel système d'exploitation est installé):

[source,winst]
----
[Actions]
Message "Installation de Mozilla"
SetLogLevel=6

;which Windows-Version?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "ce n'est pas une version d'OS supporté"
  endif
endif
  

[sub_install_win7]
Files_copy_win7
WinBatch_Setup

[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP

[Files_copy_win7]
copy "%scriptpath%\files_win7\*.*" "c:\temp\installation"

[Files_copy_winxp]
copy "%scriptpath%\files_winxp\*.*" "c:\temp\installation"

[WinBatch_Setup]
c:\temp\installation\setup.exe

[WinBatch_SetupXP]
c:\temp\installation\install.exe
-----

Comment pouvons-nous lire les sections de ce script?

[[opsi-winst-kinds-of-sections]]
=== Sous-programmes primaires et secondaires d'un script opsi-winst

Le script dans son ensemble constitue un programme, une instruction pour une procédure d'installation. Ainsi chacune de ses sections peut être vu comme un sous-programme (ou "procedure" ou "method").  Le script est une collection de sous-programmes.

Le lecteur humain ainsi qu'un logiciel interprète, doivent savoir à partir de quel élément de cette collection doit commencer la lecture.

L'exécution d'un script '{opsi-winst}' commence sur les sections [Initial] et [Actions] (dans cet ordre). Toutes les autres sections sont appelés comme sous-programmes de ces deux sections. Ce processus n'est récursif que pour les sous-sections: Sub-sections ont la même syntaxe que les sections Initial et Actions et peuvent contenir des appels à des sous-routines supplémentaires.

NOTE: Si un script est executé comme 'userLoginScript' et contient une section [ProfileActions], l'interpretation du script demarrera à la section `ProfleActions`.

Cela donne la raison de faire la distinction entre les sous-programmes primaire et secondaire:

Les sections de contrôle primaire ou générale comprennent 

* la section optionnel *Initial* (par convention, le début du script),

* la section *Actions* (doit suivre la section *Initial*), et 

* *Sub* sections (de 0 à n sous-programmes appelés par la section *Actions* qui sont des extensions syntaxiques et logiques de la section d'appel).

* la section *ProfileActions*, qui sera interpretée de differents façons selon le mode du script (Machine/Login).

La logique procédurale du script est déterminé par la séquence d'appels dans ces sections. 

Les sections secondaires ou spécifiques peuvent être appelés depuis n'importe quelle section primaire, mais ont une syntaxe différente. La syntaxe est dérivé des exigences fonctionnelles et des conditions de la bibliothèque et des conventions pour les fins spécifiques. Par conséquent, aucune autre section peut être appelé à partir d'une section secondaire.

En ce moment il y a les types suivants de sections secondaires:

* Files sections, 
* WinBatch sections,
* DosBatch/DosInAnIcon/ShellInAnIcon sections,
* Registry sections
* Patches sections,
* PatchHosts sections,
* PatchTextFile sections,
* XMLPatch sections,
* LinkFolder sections,
* opsiServiceCall sections,
* ExecPython sections,
* ExecWith sections,
* LDAPsearch sections.

Sens et syntaxe des types de sections différentes sont traitées dans
<<opsi-winst-prim-section>>
et
<<opsi-winst-secsections>>.

[[opsi-winst-stringvalues]]
=== Expressions de chaîne dans un script opsi-winst

Les valeurs textuels (valeurs de chaîne) dans les sections primaires peuvent être donnés de façon différente:

* La valeur peut être directement cités, surtout par écrit en marques de citation (entre double). Exemples: +
'"Installation de Mozilla"' +
'"n:\home\nom d'utilisateur"'

* La valeur peut être donnée par une variable chaîne ou une constante chaîne, qui "contient" la valeur: +
La variable '$MsVersion$' peut se porter "6.1"  –  si elle a été affectée avant avec cette valeur.

* Une fonction récupère ou calcule une valeur par une procédure interne. Par exemple:
`EnvVar ("Username")` +
récupère une valeur de l'environnement système, dans ce cas, la valeur de la variable d'environnement 'Username'.  Les fonctions peuvent avoir n'importe quel nombre de paramètres, y compris le zéro: +
`GetMsVersionInfo` +
Sur un système Win7, cet appel de fonction donne la valeur "6.1" (non pas comme une variable, cette valeur doit être produite à chaque appel à nouveau). 

* Une valeur peut être construit par une expression adjuvant, où les valeurs de chaîne et d'expressions partielles sont concaténés - théoriquement "plus" peut être vu comme une fonction de deux paramètres: +
'$Home$ + "\mail"'


(Plus sur ce sujet dans <<opsi-winst-string>>)

Il n'ya pas de façon analogue d'utiliser des expressions de chaîne dans les sections secondaires. Ils y suivent une syntaxe de domaine spécifique. Par exemple pour les commandes de copie, similaire à la commande de copie en ligne de Windows. Jusqu'à ce moment, il n'ya pas de syntaxe d'échappement mis en œuvre pour le transport de la logique de section primaire vers une section secondaire.

La seule façon pour le transport de valeurs de chaîne dans les sections secondaires est l'utilisation des noms des variables et des constantes comme conteneur de valeur dans ces sections. Jetons un coup d'œil aux variables et aux constantes d'un script de '{opsi-winst}':

[[opsi-winst-var-const]]
== Définition et utilisation de variables et constantes dans un script opsi-winst 

[[opsi-winst-var-const-general]]
=== Général

Dans un script '{opsi-winst}', variables et constantes apparaissent comme "mots", qui sont interprétés par '{opsi-winst}' et "contiennent" des valeurs. "Mots"  sont des séquences de caractères comprenant des lettres, des chiffres et certains caractères spéciaux (en particulier ".", "-", "_", "$", "%"), mais pas des blancs, pas de crochets, parenthèses, ou les signes opérateur ("+") . 

Les variables et constantes '{opsi-winst}' ne sont pas sensibles à la casse.

Il existe les types suivants de variables ou de constantes:

* Constantes texte global, constantes courtes, +
contiennent des valeurs qui sont présents par le programme '{opsi-winst}' et ne peuvent être changé dans un script. Avant d'interpréter le script, '{opsi-winst}' remplace chaque occurrence du nom de constante avec sa valeur dans l'ensemble du script (substitution textuelle). +
Un exemple permettra de clarifier cela: +
La constante `%ScriptPath%` est le nom prédéfini de l'endroit où '{opsi-winst}', trouve et lit le script qu'il exécute. Cet emplacement peut être, par exemple,  `p:\product`. Puis nous devons écrire +
`"%ScriptPath%"` +
dans le script lorsque l'on veut faire obtenir la valeur +
`"p:\product"`. +
** respecter les guillemets qui incluent le délimiteur de la constante.

* Variables de texte ou chaîne, variables courtes, +
ont une apparence très semblable à toutes les variables (chaîne) dans un langage de programmation commune. Ils doivent être déclarés par une déclaration  `DefVar` avant qu'ils puissent être utilisés. Dans les sections primaires, les valeurs peuvent être assignées à des variables (une ou plusieurs fois). Ils peuvent être utilisés comme éléments dans les expressions composées (comme l'addition de chaînes) ou comme arguments de fonction.  +
Mais ils se comportent comme une constante dans une section secondaire, ils apparaissent comme un élément non-syntaxiques étrangers. Leur valeur est fixé et insérée par substitution textuelle pour leurs noms (quand une section est appelée, alors la substitution textuelle pour les constantes réelles a lieu avant de commencer l'exécution de l'ensemble du script).

* Variables de liste de chaînes +
sont renseignés par une déclaration `DefStringList`. Dans les sections primaires peuvent être utilisés à des fins multiples, par exemple collecte des chaînes, manipulation des chaînes, building sections. 

En détail:

[[opsi-winst-global-const]]
=== Constantes Global Text

Les scripts doivent travailler dans un des contextes différents, sans modification manuelle. Les contextes peuvent être caractérisées par des valeurs système comme la version de l'OS ou certains chemins. '{opsi-winst}'  introduit ces valeurs comme des constantes dans le script. 

[[opsi-winst-global-const-usage]]
==== Utilisation

La caractéristique fondamentale d'une constante texte est la manière avec laquelle les valeurs qu'elle représente entrent dans le processus d'interprétation du script:

Le nom de la constante, qui est une simple séquence de caractères, est remplacé par sa valeur fixe, dans le script entier avant commencer l'exécution du script.

Le remplacement ne tient pas compte de tout contexte syntaxique dans lequel le nom éventuellement se produit (exactement comme avec des variables dans les sections secondaires).

[[opsi-winst-global-const-exmple]]
==== Exemple
'{opsi-winst}' met en œuvre des constantes %ScriptPath%  pour l'emplacement du script interprété momentanément et %System% pour le nom du répertoire système de Windows. La sous-section suivante (Fichiers) définit une commande qui copie tous les fichiers du répertoire de script dans le répertoire système de Windows:
[source,winst]
----
[files_do_my_copying]
copy "%ScriptPath%\system\*.*" "%System%" 
----

En ce moment les constantes suivantes sont fournie:

[[opsi-winst-global-const-list]]
[[opsi-winst-global-const-list-system1]]
==== System paths

[[opsi-winst-global-const-list-system-base]]
===== Répertoires du système de base

`%ProgramFilesDir%`:	'c:\program files'

`%ProgramFiles32Dir%`:	'c:\Program Files (x86)'

`%ProgramFiles64Dir%`:	'c:\program files'

`%ProgramFilesSysnativeDir%` :	'c:\program files'

`%Systemroot%` :  	'c:\windows'

`%System%` :  	 	'c:\windows\system32'

`%Systemdrive%` :       	'c:'

`%ProfileDir%` :	        'c:\Documents and Settings'

[[opsi-winst-global-const-list-commondir]]
===== Répertoires communs (AllUsers)

`%AllUsersProfileDir%` ou `%CommonProfileDir%` : 'c:\Documents and Settings\All Users'

`%CommonStartMenuPath%` ou `%CommonStartmenuDir%` : 'c:\Documents and Settings\All Users\Startmenu'

`%CommonAppdataDir%` : 'c:\Documents and Settings\All Users\Application Data'

`%CommonDesktopDir%`

`%CommonStartupDir%`

`%CommonProgramsDir%`

[[opsi-winst-global-const-list-currentuser]]
===== Répertoires utilisateur courant (connecté ou contexte de l'utilisateur)

`%AppdataDir%` ou `%CurrentAppdataDir%` : 'c:\Documents and Settings\%USERNAME%\Application Data'

`%CurrentStartmenuDir%` 

`%CurrentDesktopDir%`

`%CurrentStartupDir%`

`%CurrentProgramsDir%`

`%CurrentSendToDir%`

`%CurrentProfileDir%`  //depuis 4.11.2.1

[[opsi-winst-global-const-list-allntuser]]
===== Répertoire constantes /AllNtUserProfiles

Dans les sections 'Files' qui sont appelés avec l'option `/AllNtUserProfiles` il y a une pseudo variable  +
`%UserProfileDir%` +
Lorsque la section est exécutée pour chaque utilisateur qui existe sur un poste de travail cette variable représente le nom du répertoire du profil de l'utilisateur venons de traiter. 

`%CurrentProfileDir%`  // depuis 4.11.2.1 +
doit etre utilisé à la place de `%UserProfileDir%` pour avoir les `Files`-sections utilisable aussi pour 'userLoginScripts'.

[[opsi-winst-global-const-list-winst]]
==== Chemins de opsi-winst

`%ScriptPath%` ou `%ScriptDir%` : représente le chemin du script '{opsi-winst}' actuelle (sans dosseret de fermeture). En utilisant cette variable, nous pouvons construire chemin et les noms de fichier dans les scripts qui sont relatives à l'emplacement du script. Donc, tout peut être copié, appelé de son nouveau lieu, et tous fonctionne comme avant.

`%ScriptDrive%` : Il conduit où le script '{opsi-winst}' exécuté est situé (y compris le côlon).

`%WinstDir%` : L'emplacement de '{opsi-winst}' actuellement executé (sans dosseret de fermeture).

`%WinstVersion%` : Version de '{opsi-winst}' en cours d'exécution.

`%Logfile%` : Le nom du fichier de journalisation système utilisé par '{opsi-winst}'.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "Testing constants: "+"%"+"winstversion" +"%"
	set $ConstTest$ = "%WinstVersion%"
	set $InterestingFile$ = "%winstdir%\winst.exe"
	if not (FileExists($InterestingFile$))
		set $InterestingFile$ = "%winstdir%\winst32.exe"
	endif
	set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
	set $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----
	
résultats dans le journal suivante:
[source,winst]
----
comment: Testing: 
message Testing constants: %winstversion%

Set  $ConstTest$ = "4.10.8.3"
  The value of the variable "$ConstTest$" is now: "4.10.8.3"

Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable "$InterestingFile$" is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]

Set  $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
    retrieving strings from $INST_Resultlist$ [switch to loglevel 7 for debugging]
  The value of the variable "$CompValue$" is now: "4.10.8.3"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed

Else
EndIf
----

[[opsi-winst-global-const-list-network]]
==== Information réseau

`%Host%` :	(Obsolète) La valeur de la variable d'environnement hôte (Traditionnellement, signifiant le nom du serveur OPSI, ne pas confondre avec  %HostID%  signifiant le nom du réseau du client).

`%PCName%`:	La valeur de la variable d'environnement +PCName+, quand existante. Sinon, la valeur de la variable d'environnement +computername+. (Doit être le nom NetBIOS de l'ordinateur) 

`%IPName%` : Le nom DNS de l'ordinateur. Habituellement identique au nom netbios et donc avec `%PCName%` outre que les noms NetBIOS, utilisé en majuscules. 

`%Username%` :	Nom de l'utilisateur connecté.

[[opsi-winst-global-const-list-service]]
==== Les données, pour et à partir, du service opsi

`%HostID%` :	Doit être le nom de domaine entièrement qualifié du client opsi car il est fourni par la ligne de commande ou autrement. 

`%opsiserviceURL%` : L'URL du service opsi (normalement https://).

`%opsiServer%` : Le nom du serveur dérivé de `%opsiserviceURL%`.

`%opsiserviceUser%` : L'ID utilisateur pour lequel il y a une connexion au service opsi.

`%opsiservicePassword%` : Le mot de passe d'utilisateur utilisé pour la connexion au service opsi. Le mot de passe est éliminée lors de la connexion par la fonction de journalisation standard de '{opsi-winst}'.

`%installingProdName%`: 	Le 'productid' du produit qui est réellement installée via l'appel par le service opsi. Vide si le script n'est pas lancé par le service opsi.

`%installingProdVersion%`:	Une chaîne combinées de +<productversion>-<packageversion>+ pour le produit qui est actuellement installée via l'appel par le service opsi. Vide si le script n'est pas lancé par le service opsi.

`%installingProduct%` :	(Obsolète) Le nom (productId) du produit pour lequel le service a appelé le script exécuté. Dans le cas où le script n'est pas exécuté via le service la chaîne est vide.

[[opsi-winst-strvar]]
=== Variables chaîne (ou texte)

[[opsi-winst-strvar-decl]]
==== Déclaration

Les variables chaîne doivent être déclarés avant qu'ils ne puissent être utilisées. La syntaxe de la déclaration est

`DefVar` <nom de la variable>

exemple:
[source,winst]
----
DefVar $MsVersion$
----

Explication:

* Les noms de variables ne sont pas nécessairement commencé ou terminé par un signe dollar, mais cela est recommandé comme une convention pour comprendre leur fonctionnement dans les sections secondaires.

* Les variables ne peuvent être déclaré que dans les sections primaires (Initial section,  Actions section and sub sections).

* La déclaration ne devrait pas dépendre d'une condition. Ne doit pas être placée dans une branche d'une instruction if – else. Sinon, il pourrait arriver que la déclaration DefVar n'est pas exécuté pour une variable, mais une évaluation de la variable est essayé dans certains clause if (produisant une erreur de syntaxe).
Les variables sont initialisées avec une chaîne vide (""). 

Recommandation:

* La première lettre et la dernière du nom doit être '+$+'

* Définissez toutes les variables au début du script

[[opsi-winst-strvar-set]]
==== Affectation de valeur

Comme il est approprié pour une variable, il peut prendre en une seule valeur la réponse à une série de valeurs alors que le script progresse. Les valeurs sont affectées par des déclarations avec la syntaxe

`Set` <nom de la variable> `=` <Valeur>

<Valeur> désigne toute expression (valeur de chaîne). 

Exemples (Par Exemples voir <<opsi-winst-string>>):

[source,winst]
----
Set $OS$ = GetOS
Set $NTVersion$ = "nicht bestimmt"

if $OS$ = "Windows_NT"
  Set $NTVersion$ = GetNTVersion
endif

DefVar $Home$
Set $Home$ = "n:\home\user name"
DefVar $MailLocation$
Set $MailLocation$ = $Home$ + "\mail"
----

[[opsi-winst-strvar-usage]]
==== Utilisation de variables dans les expressions de chaîne

Dans les sections primaires d'un script '{opsi-winst}', une variable "détient" une valeur. Quand elle est déclaré, est initialisé avec la chaîne vide "".  Lorsqu'une nouvelle valeur est assignée à lui via la commande `set`, il représente cette valeur. 

In a primary section a variable can replace any String expression resp. can be  a component of a String expression, e.g. 
[source,winst]
----
Set $MailLocation$ = $Home$ + "\mail"
----

Dans une section primaire le nom de la variable désigne un objet qui représente une chaîne, Si nous ajoutons la variable, nous entendons que la chaîne sous-jacente doit être ajouté en quelque sorte.

Cette chaîne de représentation est contextuel dans une section secondaire. Juste le nom de la variable se trouve maintenant pour la chaîne. 

[[opsi-winst-strvar-in-sections]]
==== Sections secondaire contre primaires

Quand une section secondaire est chargé, et '{opsi-winst}' commence son interprétation, la séquence de caractères d'un nom de variable est directement remplacée par la valeur de la variable.

Exemple: +
Une commande `copy` dans une section fichiers doit copier un fichier dans +
"+n:\home\user name\mail\backup+" +
copiés.

Nous avons mis `$MailLocation$` dans le répertoire au-dessus:
[source,winst]
----
DefVar $Home$
DefVar $MailLocation$
Set $Home$ = "n:\home\user name"
Set $MailLocation$ = $Home$ + "\mail"
----

$MailLocation$ maintenant contient +
"+n:\home\user name\mail+"

Dans une section primaire, nous pouvons désormais exprimer le répertoire +
"+n:\home\user name\mail\backup+" +
avec +
+$MailLocation$ + "\backup"+


Le même répertoire doit être désignée dans une section secondaire: +
`"$MailLocation$\backup"`

Une différence fondamentale entre la pensée de variables dans les sections primaires par rapport au secondaires, c'est que, dans une section primaire, nous pouvons former une expression d'assignation, comme +
`$MailLocation$ = $MailLocation$ + "\backup"`

Comme d'habitude, cela signifie que `$MailLocation$` a tout d'abord une valeur initiale et prend une nouvelle valeur en ajoutant quelques chaîne à la valeur initiale. La référence de la variable est dynamique, et peut avoir des antécédents. 

Dans une section secondaire telle expression ne serait rien (et éventuellement erronée), depuis `$MailLocation$` ne peut être que remplacée par une chaîne de caractères fixes (à toutes les occurrences quasiment au même moment).

[[opsi-winst-lstvar]]
=== Variables liste de chaînes

Les variables pour les listes de chaîne doivent être affecté dans une déclaration DefStringList, par exemple:
[source,winst]
----
DefStringList SMBMounts
----

Une liste de chaîne peut servir par exemple comme conteneur pour la sortie capturé d'un programme shell. Les chaînes collectées peuvent être manipulés dans un grand nombre de façons. Dans le détail ce sera traitée dans la section sur le traitement des listes de chaînes (voir <<opsi-winst-stringlist>>).

CAUTION: Si (imbriquées) les sous-sections seront confiés à des fichiers externes, les sections dites secondaires sont généralement placés dans le fichier, à partir de laquelle ils sont appelés. Selon la complexité de la syntaxe, ils peuvent avoir besoin *supplémentaires* également être logés dans le fichier principal.


[[opsi-winst-prim-section]]
== Syntaxe et signification des sections primaires d'une script opsi-winst 

Comme présenté brièvement dans le chapitre 4 la section Actions d'une script peut être considéré comme une méthode principale du script '{opsi-winst}' et décrit la séquence de traitement global. Il peut appeler des sous-routines - les sous-sections - qui peuvent ensuite appeler récursivement les sous-sections elles-mêmes.

Les sections suivantes expliquent la syntaxe et l'utilisation des sections primaires d'un script '{opsi-winst}'.

[[opsi-winst-prim-section-kinds]]
=== Sections primaires

Il y a trois sortes de sections primaires dans un script

* Une section `Initial` (peut être omise),

* Une section `Action`, 

* n'importe quel nombre de sections `Sub`

* une section `ProfileActions`

Les sections `Initial` et `Action` sont syntaxiquement équivalents (mais Initial doit garder la première place). Par convention,  dans la section Initial sont faits certains paramétrages de l'exécution du script (par exemple le niveau de journalisation). La section Action peut être considéré comme le programme principal dans un scripts '{opsi-winst}'. Il contient la séquence d'actions qui sont contrôlées par le script.

Les sous-sections sont ainsi syntaxiquement équivalents. Mais ils sont appelés depuis la section Action. Ensuite, ils peuvent appeler eux-mêmes des sous-sections `Sub`. 

Une sous-section `Sub` est déterminée par la création d'un nom qui commence par "Sub", par exemple `Sub_InstallBrowser`. En écrivant son nom dans la section Action nous produisons un appel à la sous-section. Le sens de cet appel est défini par le contenu de la section dans le script qui commence par le nom entre crochets, dans l'exemple  `[Sub_InstallBrowser]`

NOTE: Les sous-sections du second ordre et supérieur ne peuvent accueillir des sections internes. Au lieu de cela, leurs appels de procédure doit se référer aux sections définies dans le fichier script principal ou définies comme des sections externes (voir <<opsi-winst-commands-subcall>>).

CAUTION: Si (imbriqués) les sous-sections seront confiés à des fichiers externes, les sections appelées doivent être dans ce fichier d'où ils sont appelés. Selon la complexité du script ils peuvent parfois être placé *aussi* dans le fichier principal.

Une section `ProfileActions` dans un script d'installation tipique peut etre utilisè comme une sous-section avec une syntaxe speciale. Dans un 'userLoginScript' cette section sera utilisée comme un script de dèmarrage (à la place de `Actions`). Voir le chapitre 'User Profile Management' dans le manuel d'opsi et <<opsi-winst-commands-loginscripts>>.


[[opsi-winst-params]]
=== Paramétrage de ospi-winst

Entrées typiques d'une section Initial définissent certains attributs d'exécution de '{opsi-winst}'. L'exemple suivant montre comment les réponses d'erreur peuvent être configuré:

[[opsi-winst-params-example]]
==== Exemple
[source,winst]
----
[Initial]
SetLogLevel=5
ExitOnError=false
ScriptErrorMessages=on
TraceMode=off
----
Cela signifie que: 

* le niveau de journalisation est réglé à 5

* quand une erreur survient winst vais essayer de continuer l'exécution du script

* Si une erreur de syntaxe de script survient, il doit être communiquée (ce sera dans une fenêtre spéciale)

* nous ne voulons pas activer le mode trace pour l'exécution du script (ce qui voudrait dire que nous avons une demande après chaque étape du programme, si nous voulons continuer).

Les valeurs ci-dessus sont les valeurs par défaut, '{opsi-winst}' va les assumer si ces déclarations sont manquants.

Pour les détails de la syntaxe et de la signification: 

[[opsi-winst-params-loglevel]]
==== Spécification du niveau de journalisation

CAUTION: L'ancienne fonction `LogLevel=` est obsolète depuis la version 4.10.3 de '{opsi-winst}'. Pour des raisons de compatibilité descendante Loglevels sera augmenté de 4 avant qu'ils ne soient utilisés.

Il y a deux variantes syntaxiques pour spécifier le niveau de journalisation:

SetLogLevel = <nombre> 
SetLogLevel = <expression de chaîne> 
À savoir le nombre peut être donnée comme une valeur entière ou comme une expression chaîne (voir section 6.3). Dans le second cas, '{opsi-winst}' tente d'évaluer l'expression de chaîne comme un nombre.
Il existe dix niveaux de 0 à 9. 

Il existe deux variantes similaires pour spécifier le niveau de log:

`SetLogLevel =` <nombre> 

`SetLogLevel =` <expression de chaîne>

À savoir le nombre peut être donnée comme une valeur entière ou comme une expression chaîne (voir section 6.3). Dans le second cas, '{opsi-winst}' tente d'évaluer l'expression de chaîne comme un nombre.

Ils existent dix niveaux de 0 à 9. 
****
                0 = rien (absolument rien)
                1 = essentielles ("informations essentielles")
                2 = critiques (des erreurs inattendues qui peuvent entraîner une interruption du programme)
                3 = erreur (Les erreurs qui n'arrêteront pas  l'exécution du programme)
                4 = avertissement (vous devriez jeter un oeil à ce)
                5 = notice (Important statements to the program flow)
                6 = info (Infos supplémentaires)
                7 = débogage (messages de débogage importants)
                8 = débogage2 (beaucoup plus d'informations de débogage et de données)
                9 = confidentielles (mots de passe et autres données de sécurité pertinentes)

****

[[opsi-winst-params-required-winst]]
==== Version requise de opsi-winst

La déclaration 

`requiredWinstVersion`   <symbole relationnel>   <chaîne de valeurs>

par exemple:
[source,winst]
----
requiredWinstVersion >= "4.3"
----

permet à '{opsi-winst}' de vérifier si l'état de la version désirée est donnée. Sinon un message d'erreur windows apparait. 

Cette fonctionnalité existe depuis la version 4.3 de '{opsi-winst}'. Pour une version antérieure, la déclaration est inconnue, et la déclaration elle-même est un erreur de syntaxe qui sera indiquée par la fenêtre erreur de syntaxe (voir la section suivante). Par conséquent, la déclaration peut être utilisée indépendamment de la version de '{opsi-winst}' actuellement utilisée tant que la version requise est au moins la version 4.3.

[[opsi-winst-params-errors]]
==== Réaction sur ​​les erreurs

Il y a deux sortes d'erreurs qui sont traités de différentes manières:

. déclarations illégales qui ne peuvent pas être interprétées par '{opsi-winst}' (erreurs syntaxiques),

. faute de déclarations qui ne peuvent pas être exécutées à cause de raisons externes objectives (erreurs d'exécution).

En principe, les erreurs syntaxiques sont indiquées dans une fenêtre pop-up pour la correction immédiate, les erreurs d'exécution sont enregistrées dans un fichier journal pour être analysés plus tard.

Le comportement de '{opsi-winst}' quand il reconnaît une erreur de syntaxe est défini par la déclaration de configuration

* `ScriptErrorMessages =` <valeur booléenne> +
Si la valeur est vraie (défaut), les erreurs de syntaxe déclenchent une fenêtre popup avec quelques informations sur l'erreur. Ce genre d'erreurs ne sont pas enregistrées dans le fichier journal. Le fichier journal doit conserver des informations sur l'exécution réelle d'un script de syntaxe correcte. +
La valeur booléenne peut être true (vrai) ou false (faux). Les délimiteurs  `on` ou `off` peuvent être utilisés aussi bien.

Il y a deux options de configuration pour des erreurs d'exécution.

* `ExitOnError =` <valeur booléenne> +
Cette déclaration définit si l'exécution du script prend fin quand une erreur survient. Si la valeur est `true` ou `yes` le programme va arrêter l'exécution, sinon les erreurs sont simplement enregistré (défaut).

* `TraceMode =` <valeur booléenne> +
En TraceMode (défaut `false`) chaque entrée du journal systeme sera en plus affiché dans la fenêtre de message, avec un bouton OK.

[[opsi-winst-params-stayontop]]
==== Rester au-dessus 

*  `StayOnTop =` <valeur booléenne>

Avec StayOnTop = true (ou = on) nous demandons que - en mode batch - la fenêtre de '{opsi-winst}' soit sur ​​le dessus des fenêtres qui se partagent l'écran. Cela signifie qu'il devrait être visible dans le "premier plan" tant qu'aucune autre fenêtre aie le même statut. 
 
CAUTION: Selon le manuel du système la valeur ne peut pas être modifié pendant l'exécution du programme.  Mais il semble que nous pouvons donner une nouvelle valeur pour une fois. 

`StayOnTop` il est à `false` par défaut afin d'éviter que certains autres processus génère un message d'erreur qui peut éventuellement ne pas être vu si '{opsi-winst}' reste au-dessus.

[[opsi-winst-string]]
=== Expressions de chaîne, Valeurs de chaîne, et Fonctions de chaîne

Une expression de chaîne peut être

* une valeur de chaîne élémentaires
* une valeur de chaîne imbriquées
* une variable chaîne
* la concaténation d'autres expressions de type chaîne
* un appel de fonction d'une valeur de chaîne

[[opsi-winst-string-elementary]]
==== Valeur de chaîne élémentaires
Une valeur de chaîne élémentaires est une séquence de caractères qui est enfermé dans des guillemets double ou simple, formellement:

'"<séquence de caractères>"'

ou

''<séquence de caractères>''

Exemple:
[source,winst]
----
DefVar $ExampleString$
Set $ExampleString$ = "mon texte"
----

[[opsi-winst-string-nested]]
==== Chaînes dans des chaînes (valeur de chaîne imbriquées)

Si la séquence de caractères contient elle-même des guillemets, nous devons utiliser les autres types de guillemets pour l'entourer:
[source,winst]
----
DefVar $citation$
Set $citation$ = 'il a dit "Oui"'
----

Si la séquence de caractères contient les deux types de guillemets, nous devons utiliser l'expression spéciale suivante: +
`EscapeString:` <séquence de caractères> +
Par exemple nous pouvons écrire: +
[source,winst]
----
DefVar $Meta_citation$
Set $Meta_citation$ = EscapeString: Set $citation$ = 'il a dit "Oui"'
----
Alors la variable `$Meta_citation$` va exactement contenir la séquence complète de caractères qui suit la colonne après "EscapeString" (y compris le vide). `$Meta_citation$` contiendra la déclaration complète: +Set $citation$ = `'il a dit "Oui"'`+ 

[[opsi-winst-string-concat]]
==== Concaténation de chaînes 

Une concaténation de chaîne est écrite en utilisant le signe plus ("+") 

<expression de chaîne> `+` <expression de chaîne>

Exemple:
[source,winst]
----
DefVar $String1$
DefVar $String2$
DefVar $String3$
DefVar $String4$
Set $String1$ = "mon texte"
Set $String2$ = "et"
Set $String3$ = "ton texte"
Set $String4$ =  $String1$ + " " + $String2$ + " " + $String3$
----

$String4$ a alors la valeur "mon texte et ton texte".

[[opsi-winst-string-expressions]]
==== Variables chaîne

Une variables chaîne dans une section primaire "contient" une valeur de chaîne. Dans une expression de chaîne, il peut toujours remplacer une chaîne élémentaire. Pour savoir comment définir et configurer les variables de chaîne voir <<opsi-winst-strvar>>.

Les sections suivantes présentent une variété de fonctions de chaînes. 

[[opsi-winst-string-functions-os]]
==== Fonctions de chaîne qui renvoient le type de système d'exploitation

* `GetOS` +
La fonction indique le type de système d'exploitation en marche. +
Nous recommendon l'utilisation de `GetMsVersionInfo`. +
`GetOs` retourne l'une des valeurs suivantes: +
"Windows_16" +
"Windows_95" (y compris Windows 98 et ME) +
"Windows_NT" (y compris Windows 2000 et XP) +
"Linux"


* GetNtVersion +
Obsolete - utilisez `GetMsVersionInfo`. +
Un système d'exploitation Windows NT est caractérisé par un numéro de type et de sous-type Windows. GetNtVersion  retourne le nom de sous-type précis. Les valeurs possibles sont +
"NT3" +
"NT4" +
"Win2k" (Windows 5.0) +
"WinXP" (Windows 5.1) +
"Windows Vista" (Windows 6) +
Si le système d'exploitation NT est plus que la version 6 ou il y a une version pas explicitement connue, la fonction retourne "Win NT" et le numéro de version complet (5.2, ... , 6.0 ..) . Par exemple pour Windows Server 2003 R2 Enterprise Edition, nous obtenons +
"Win NT 5.2" +
Si le système d'exploitation n'est pas Windows NT la fonction retourne la valeur d'erreur +
"No OS of Windows NT type"

* GetMsVersionInfo +
pour les systèmes de type Windows NT renvoie les informations de version de Microsoft comme indiqué par l'API, par exemple un ordinateur Windows XP produit le résultat + 
"5.1"

.Versions de Windows
[options="header"]
|=======================
|GetMsVersionInfo|Versions de Windows
|5.0    |Windows 2000
|5.1    |Windows XP (Home, Prof)
|5.2    |XP 64 Bit, 2003, Home Server, 2003 R2
|6.0    |Vista, 2008
|6.1    |Windows 7, 2008 R2
|=======================
voir aussi `GetMsVersionMap`

*  `GetSystemType` +
vérifie l'installation de Windows OS, si on peut supposer que le système est de 64 bits. Dans ce cas, la valeur est '64 Bit System' autrement 'x86 System'.

[[opsi-winst-string-functions-env]]
==== Fonctions de chaîne pour la récupération de l'environnement ou de données en ligne de commande

La fonction lit et retourne la valeur momentanée d'une variable d'environnement système. 

Par exemple, nous pouvons récupérer l'utilisateur qui est connecté avec EnvVar ("Username").
ParamStr
La fonction passe la chaîne de paramètres de la ligne de commande de winst à savoir le paramètre de ligne de commande qui est indiqué par /parameter. S'il n'ya pas de paramètre  ParamStr renvoie la chaîne vide.
GetLastExitCode
retourne le code de sortie (aussi appelé ErroLevel) du dernièr appel WinBatch.
GetUserSID(<nom d'utilisateur Windows>)
retourne le SID pour un utilisateur donné (éventuellement avec le préfixe de domaine sous la forme 
DOMAINE\UTILISATEUR).

*  `EnvVar (` <string>`)` +
La fonction lit et retourne la valeur momentanée d'une variable d'environnement système. Par exemple, nous pouvons récupérer l'utilisateur qui est connecté avec `EnvVar ("Username")`.

*  `ParamStr` +
La fonction passe la chaîne de paramètres de la ligne de commande de '{opsi-winst}' à savoir le paramètre de ligne de commande qui est indiqué par /parameter. S'il n'ya pas de paramètre  ParamStr renvoie la chaîne vide.

*  `GetLastExitCode` +
retourne le code de sortie (aussi appelé ErroLevel) du dernièr appel WinBatch.

*  `GetUserSID(`<Windows Username>`)` +
retourne le SID pour un utilisateur donné (éventuellement avec le préfixe de domaine sous la forme 
DOMAINE\UTILISATEUR).

* `GetUsercontext` +
renvoie la chaîne qui a été donné à '{opsi-winst}' par le paramètre optionnel `/usercontext`. Si ce paramètre n'a pas été utilisé la chaîne retournée est vide.

[[opsi-winst-string-functions-reg]]
==== Lire des valeurs du registre Windows et transformer les valeurs en format Registre

*  `GetRegistryStringValue (`<chaîne>`)` +
essaie d'interpréter la valeur chaîne passée comme une expression de format +
'[KEY] X' +
Ensuite, la fonction tente d'ouvrir la clé de registre `KEY`, et, au cas où elle réussit, à lire et retourner la valeur de chaîne qui appartient au nom de la variable de registre `X` . 

Exemple
[source,winst]
----
GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] Shell")
----

généralement donne  "Explorer.exe", la valeur par défaut du programme shell de Windows.

S'il n'y a pas de clé de registre `KEY` ou la variable `X` n'existe pas la fonction produit un message d'avertissement dans le fichier journal et retourne la chaîne vide.

Par exemple:
Si nous avons fait une 'standard entry' avec la valeur +standard entry+ à la clé +HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0+, nous l'obtiendrons avec
[source,winst]
----
Set  $CompValue$ = GetRegistryStringValue32 ("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0]")
----

le journal systeme suivant:
[source,winst]
----
Registry started with redirection (32 Bit)
Registry key [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0]  opened
Key closed
The value of the variable "$CompValue$" is now: "standard entry"
----


*  `GetRegistryStringValue32(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValue64(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValueSysNative(`<chaîne>`)` ->	voir <<opsi-winst-64bit,Chapter 64 Bit>>


*  `RegString(`<chaîne>`)` +
est utile pour transformer les noms de chemin dans le format qui est utilisé dans le Registre Windows. La barre oblique inverse est dupliqué. Par exemple, +
[source,winst]
----
RegString ("c:\windows\system\") 
----
donne +
'"c:\\windows\\system\\"'

[[opsi-winst-string-functions-ini]]
==== Lecture des valeurs de propriété à partir des fichiers ini

Pour des raisons historiques, Il y a trois fonctions pour la lecture des valeurs des fichiers de configuration qui ont le format de fichier ini. Depuis opsi 3.0 les propriétés de produits spécifiques sont récupérées à partir du démon de configuration de OPSI (qui peut les récupérer à partir d'un fichier de configuration ou de tout autre back-end conteneur de données).

En détail: +
Format de fichier Ini signifie que le fichier est un fichier texte et est composé de "sections" chacune contenant des paires de valeurs clés:
[source,winst]
----
[section1]
Varname1=Valeur1
Varname2=Valeur2
...
[section2]
...
----

La fonction la plus générale lit la valeur appartenant à une certaine clé dans une certaine section de certaines fichier INI. Tout paramètre peut être donnée comme une expression chaîne arbitraire:

*  `GetValueFromInifile (`<FICHIER>, <SECTION>, <CLE>, <VALEUR PAR DEFAUT>`)` +
La fonction tente d'ouvrir le fichier ini `FICHIER`, récupérer la `SECTION` demandée et recherche la valeur spécifiée appartenant à la `CLE` que de la fonction retournera. Si aucune de ces opérations échouent `VALEUR PAR DEFAUT` est retourné.

La deuxième fonction emprunte sa syntaxe du format de fichier INI même, et peut parfois être plus facile à utiliser. Mais depuis cette syntaxe compliquée tourne dans des circonstances plus général, elle est obsolète. La syntaxe lit:

*  `GetIni (` <expression de chaîne> [ <séquence de caractères> ] <séquence de caractères> `)` +
(Obsolète) L'<expression de chaîne> est interprété comme nom de fichier, la premiere <séquence de caractères> comme nom de la section, la seconde comme nom de clé.  

[[opsi-winst-string-functions-prodprop]]
==== Lecture des Propriétés du produit

* `GetProductProperty (` <Nom de la propriété>, <Valeur par défaut>`)` +
quand $PropertyName$ et $DefaultValue$ sont des expressions de chaîne. 
Si '{opsi-winst}' est connecté au service de configuration OPSI la propriété produit est récupéré du service. 
Si '{opsi-winst}' n'est pas connecté au service ou pour d'autres raisons, l'appel échoue, le donné +<Valeur par défaut>+ sera retourné.

Les propriétés du produit peuvent être utilisé pour configurer des variantes de l'installation.

Par exemple l'installation OPSI du viewer réseau UltraVNC peut être configuré en utilisant les options 

* viewer = <yes> | <no>

* policy = <factory_default> | 

Les branches de script d'installation, selon les valeurs choisies pour ces options, peuvent être récupérées par 
[source,winst]
----
GetProductProperty("viewer", "yes")
GetProductProperty("policy", "factory_default")
----


*  `IniVar(`<Nom de la propriété>`)` +
(obsolète: use GetProductProperty)

[[opsi-winst-string-functions-hosts]]
==== Récupération de données à partir de etc/hosts

*  `GetHostsName(`<chaîne>`)` +
retourne le nom d'hôte pour une adresse IP donnée car elle est déclarée dans le fichier hosts local. Si le système d'exploitation est "Windows_NT" (en fonction de la variable d'environnement de l'OS)  "%systemroot%\system32\drivers\etc\"  est supposé l'emplacement du fichier hôte, autrement  "C:\Windows\".

*  `GetHostsAddr(`<chaîne>`)` +
indique l'adresse IP à un hôte donné ou à un nom d'alias.

[[opsi-winst-string-functions-handling]]
==== Traitement des chaîne

*  `ExtractFilePath(`<chaîne>`)` +
interprète la valeur chaîne passée comme nom de fichier ou chemin et retourne la partie chemin (la chaîne jusqu'à la dernière "\", y compris).

*  `StringSplit (`VALEUR CHAÎNE1, VALEUR CHAÎNE2, INDEX`)` +
(obsolète: utilisez `splitString` / `takestring`)

*  `takeString(`<index>,<liste>`)` +
revient d'une liste de chaînes <liste> la chaîne avec l'indice <index>. +
Souvent utilisé en combinaison avec `splitstring`:
`takeString(`<index>, `splitString(`<chaîne1>, <chaîne2>`)` +
(voir aussi <<opsi-winst-stringlist>>). +
Le résultat est produit en coupant <chaîne1> où chaque tranche est délimité par une occurrence de <chaîne2>, puis en prenant la tranche avec l'index <index> (où le décompte commence avec 0).

Exemple:
[source,winst]
----
takeString(3, splitString ("\\server\share\directory",  "\"))
----

retourne '"share"', +
la chaîne donnée est découpé au "\" et retourne la liste de chaînes: +
Index 0 - "" (chaîne vide), car il n'y a rien avant le premier "\" +
Index 1 - "" (chaîne vide), car il n'y a rien avant le deuxième "\" +
Index 2 - "server" +
Index 3 - "share" +
Index 4 - "directory"

`takestring` compte vers le bas, si l'indice est négatif, à commencer par le nombre d'éléments. Par conséquent,
[source,winst]
----
takestring(-1, $list1$)
----

désigne le dernier élément de la liste de chaîne $list1$.

* `SubstringBefore(`<chaîne1>, <chaîne2>`)` +
(obsolète: utilisez `splitString` / `takestring`)
donne la séquence de caractères de chaîne1 jusqu'au début de la chaîne2. +
Exemple:
[source,winst]
----
SubstringBefore ("C:\programme\staroffice\program\soffice.exe", "\program\soffice.exe")
----
retourne '"C:\programme\staroffice"'.

* `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne de <liste> qui contient <chaîne de recherche>. +
Retourne une chaîne vide si aucune chaîne correspondante est trouvé.

* `Trim(`<chaîne>`)` +
coupe les blancs entourant <chaîne>.

* `lower(`<chaîne>`)` +
retourne une <chaîne> avec des lettres minuscules.

* `unquote(`<chaîne>,<chaîne coté>`)`  //depuis 4.11.2.1 +
Si la <chaîne> est cité par <chaîne coté> il renvoie la <chaîne> non coté +
De la <chaîne coté> seulement le premier caractère est utilisé, les premiers espaces sont ignorés.

* `HexStrToDecStr(`<chaîne>`)` +
Renvoie la représentation décimale de la chaîne d'entrée si cela a été la représentation hexadécimale d'un entier. Les caractères en tête comme '0x' ou '$' seront ignorés. En cas d'erreur de conversion, la fonction retourne une chaîne vide.

* `DecStrToHexStr(`<chaîne>`)`+
Renvoie la représentation hexadécimale de la chaîne d'entrée si cela a été la représentation décimale d'un entier. En cas d'erreur de conversion, la fonction retourne.

* `base64EncodeStr(`<chaîne>`)` +
renvoie la valeur codée en base64 de <chaîne>.

* `base64DecodeStr(`<chaîne>`)` +
renvoie la valeur décodées en base64 de <chaîne>.

[[opsi-winst-string-functions-others]]
==== Autres fonctions de chaîne

* `RandomStr` + 
renvoie une chaîne aléatoire de longueur 10, où les lettres en majuscule, les lettres minuscules et les chiffres sont mélangés (pour créer des mots de passe). Plus exactement: 2 caractères minuscules, 2 caractères majuscules, 2 caractères spéciaux et 4 chiffres. Les caractères possibles spéciales sont: +
'!','$','(',')','*','+','/',';','=','?','[',']','{','}','ß','~','§','°'

* `CompareDotSeparatedNumbers(`<chaîne1>, <chaîne2>`)` +
compare deux chaînes de la forme <nombre>.<nombre>[.<nombre>[.<nombre>]] +
Il retourne "0" si les chaînes sont égales, "1" si <chaîne1> est plus grande et "-1" si <chaîne1> est inférieur à <chaîne2>.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedNumbers"
	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.31.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

entraîne le journal système suivant:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedNumbers

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is equal to 1.2.3.4.5

Else
EndIf

Set  $string1$ = "1.2.31.4.5"
  The value of the variable "$string1$" is now: "1.2.31.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.31.4.5 is higher then 1.2.13.4.5

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is lower then 1.2.13.4.5

Else
EndIf
----

*  `CompareDotSeparatedStrings (`<chaîne1>, <chaîne2>`)` +
compare deux chaînes de la forme <chaîne>.<chaîne>[.<chaîne>[.<chaîne>]] +
Il retourne "0" si les chaînes sont égales, "1" si <chaîne1> est plus grande et "-1" si <chaîne1> est inférieure à <chaîne2>. La fonction n'est pas sensible à la casse.

Exemple: +
Le code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.A.B.C.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.cb.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.ab.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.13.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

entraîne le journal système suivant:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedStrings

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.A.B.C.3"
  The value of the variable "$string2$" is now: "1.A.B.C.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.A.B.C.3

Else
EndIf

Set  $string1$ = "1.a.cb.c.3"
  The value of the variable "$string1$" is now: "1.a.cb.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.cb.c.3 is higher then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.ab.c.3"
  The value of the variable "$string1$" is now: "1.a.ab.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.ab.c.3 is lower then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.2.13.4.5"
  The value of the variable "$string1$" is now: "1.2.13.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.13.4.5 is lower then 1.2.3.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is higher then 1.2.13.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf
----

[[opsi-winst-string-functions-license]]
==== (Chaîne-) Fonctions de gestion des licences

* `DemandLicenseKey(`poolId [, productId [,windowsSoftwareId]]`)` +
demande au service OPSI via la fonction getAndAssignSoftwareLicenseKey pour une réservation d'une licence pour le client. +
Le pool à partir duquel les licences sont prises peut être explicitement donné par son ID ou est identifié par un ID du produit associé ou de l'ID du Software Windows (possible, si ces associations sont définies dans la configuration des licences). +
'poolId', 'productId', 'windowsSoftwareId' sont des chaînes (expressions de type chaîne). +
Si aucun 'poolId' est explicitement donnée, le premier paramètre doit être une chaîne vide  "". La même procédure se fait avec d'autres Ids ne pas donné explicitement. +
La fonction retourne la clé de licence qui est tirée du pool.

Exemples:
[source,winst]
----
set $mykey$ = DemandLicenseKey ("pool_office2007")
set $mykey$ = DemandLicenseKey ("", "office2007")
set $mykey$ = DemandLicenseKey ("", "", "{3248F0A8-6813-11D6-A77B}")
----

* `FreeLicense (`poolId [, productId [,windowsSoftwareId]]]`)` +
demande au service OPSI, via la fonction freeSoftwareLicense, de libérer la licence actuelle de réservation.
La syntaxe est analogue à la syntaxe pour `DemandLicenseKey`

Exemple:
[source,winst]
----
DefVar $opsiresult$
set $opsiresult$ = FreeLicense("pool_office2007")
----

'$opsiresult$' devient la chaîne vide, si aucune erreur s'est produite, et, si une erreur survient, le texte d'info de l'erreur.

[[opsi-winst-string-functions-serviceerrors]]
==== Récupération Infos erreur des appels de service

* `getLastServiceErrorClass` +
Renvoie, comme son nom l'indique, le nom de classe de l'information d'erreur du dernier appel de service. Si le dernier appel de service n'a pas produit une erreur la fonction retourne la valeur "None".

* `getLastServiceErrorMessage` +
Renvoie la chaîne du message de la dernière information  d'erreur "None". +
Depuis la chaîne du message a plus de chances d'être changée, il est recommandé de baser la logique de script sur le nom de la classe.

Exemple:
[source,winst]
----
if getLastServiceErrorClass = "None"
    comment "kein Fehler aufgetreten"
endif
----

[[opsi-winst-stringlist]]
=== Fonctions de liste de chaînes et Traitement de liste de chaînes

Une liste de chaîne (ou une valeur de liste de chaînes) est une séquence de valeurs de chaîne. Pour ce genre de valeurs nous avons la variable de type `String list`. Elles sont définies par la déclaration

`DefStringList` <Nom de la variable>

Une valeur de liste de chaînes peut être affecté à la variable de liste de chaînes:

`Set` <Nom de la variable> `=` <StringListValue>

Les valeurs d'une liste de chaînes peuvent être données seulement comme résultat des expressions de chaîne. Il y a plusieurs façons de créer ou de capturer des listes de chaînes, et de nombreuses options pour les traiter, souvent donnant une nouvelles liste de chaînes. Elles sont présentées dans les paragraphes suivants. 

Pour les exemples suivants, nous déclarons une variable de liste de chaînes '$list1$':

[source,winst]
----
DefStringList $list1$
----

Si nous nous référons des variables nommées  String0, StringVal, .. on entend que ceux-ci représentent toutes les expressions de chaîne.

Nous commençons avec un type particulier et plutôt utile de listes de chaînes: 'maps' – également appelés hachages ou tableaux associatifs – qui se composent d'une ligne de la forme 'CLÉ'='VALEUR'. En fait, chaque 'map' devrait établir une fonction qui associe une 'VALEUR' à une 'CLÉ', et toute les 'CLÉ' devrait avoir lieu maximum une fois tant que première partie d'une ligne (alors différentes 'CLÉ's peuvent être associées avec les mêmes 'VALEUR').

[[opsi-winst-stringlist-maps]]
==== Informations sur Maps

*  `getMSVersionMap` +
récupér les informations sur le système d'exploitation et les enregistre dans une liste de chaînes table de hachage. +
Il y a les clés suivants:
* major_version
* minor_version
* build_number
* platform_id
* csd_version
* service_pack_major
* service_pack_minor
* suite_mask
* product_type_nr
* 2003r2

Les résultats de 'suite_mask' et 'product_type_nr' sont des entiers qui peuvent être bâtie par une opérations 'or' des valeurs suivantes.

product_type_nr
****
    0x0000001 (VER_NT_WORKSTATION)
    0x0000002 (VER_NT_DOMAIN_CONTROLLER)
    0x0000003 (VER_NT_SERVER)
****

SuiteMask
****
    0x00000001 (VER_SUITE_SMALLBUSINESS)
    0x00000002 (VER_SUITE_ENTERPRISE)
    0x00000004 (VER_SUITE_BACKOFFICE)
    0x00000008 (VER_SUITE_COMMUNICATIONS)
    0x00000010 (VER_SUITE_TERMINAL)
    0x00000020 (VER_SUITE_SMALLBUSINESS_RESTRICTED)
    0x00000040 (VER_SUITE_EMBEDDEDNT)
    0x00000080 (VER_SUITE_DATACENTER)
    0x00000100 (VER_SUITE_SINGLEUSERTS)
    0x00000200 (VER_SUITE_PERSONAL)
    0x00000400 (VER_SUITE_SERVERAPPLIANCE)
****

Exemple: +
Le code
[source,winst]
----
DefStringList $INST_Resultlist$
DefStringList $INST_Resultlist2$

message "getMSVersionMap"
comment "get value by winst function"
set $INST_Resultlist$ = getMSVersionMap
----

entraîne le journal système suivant:
[source,winst]
----
message getMSVersionMap
comment: get value by winst function

Set  $INST_Resultlist$ = getMSVersionMap
    retrieving strings from getMSVersionMap [switch to loglevel 7 for debugging]
        (string   0)major_version=5
        (string   1)minor_version=1
        (string   2)build_number=2600
        (string   3)platform_id=2
        (string   4)csd_version=Service Pack 3
        (string   5)service_pack_major=3
        (string   6)service_pack_minor=0
        (string   7)suite_mask=256
        (string   8)product_type_nr=1
        (string   9)2003r2=false
----

[NOTE]
==============================
Infos de base pour getMSVersionMap

* http://msdn.microsoft.com/en-us/library/ms724385%28VS.85%29.aspx
* http://msdn.microsoft.com/en-us/library/dd419805.aspx
* http://msdn.microsoft.com/en-us/library/ms724833%28VS.85%29.aspx

==============================

*  `getFileInfoMap(`<NOM DE FICHIER>`)` +
récupère les informations de version intégré dans le fichier  NOM DE FICHIER et les enregistre dans une liste de chaînes map.

En ce moment, il existe les clés,

* Comments
* CompanyName
* FileDescription
* FileVersion
* InternalName
* LegalCopyright
* LegalTrademarks
* OriginalFilename
* PrivateBuild
* ProductName
* ProductVersion
* SpecialBuild
* Language name <index>
* Language ID <index>
* file version with dots
* file version
* product version

Utilisation: Si nous définissons et appelons
[source,winst]
----
DefStringList FileInfo
DefVar $InterestingFile$
Set $InterestingFile$ = "c:\program files\my program.exe"
set FileInfo = getFileInfoMap($InterestingFile$)
----

nous obtenons la valeur associée à la clé "FileVersion" par l'appel 
[source,winst]
----
DefVar $result$
set $result$ = getValue("FileVersion", FileInfo)
----

(pour la fonction getValue voir <<opsi-winst-stringlist-getstring>>).

Exemple: +
Le code:
[source,winst]
----
set $InterestingFile$ = "%winstdir%\winst.exe"
if not (FileExists($InterestingFile$))
	set $InterestingFile$ = "%winstdir%\winst32.exe"
endif
set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
----

produit la sortie journal système suivante:
[source,winst]
----
Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]
        (string   0)Language name 0=Deutsch (Deutschland)
        (string   1)Language ID 0=1031
        (string   2)file version=1125942857039872
        (string   3)file version with dots=4.10.8.0
        (string   4)product version=1125942857039872
        (string   5)Comments=
        (string   6)CompanyName=uib gmbh (www.uib.de)
        (string   7)FileDescription=opsi.org
        (string   8)FileVersion=4.10.8.0
        (string   9)InternalName=
        (string  10)LegalCopyright=uib gmbh under GPL
        (string  11)LegalTrademarks=opsi
        (string  12)OriginalFilename=
        (string  13)PrivateBuild=
        (string  14)ProductName=opsi-winst
        (string  15)ProductVersion=4.0
        (string  16)SpecialBuild=
----

*  `getLocaleInfoMap` +
récupère les informations du système sur la localisation et l'écrit dans une liste de chaînes map.

En ce moment, il existe les clés:

* language_id_2chars (version de deux lettres du nom de la langue par défaut du système)
* language_id (version de trois lettres, y compris les sous-type de la langue)
* localized_name_of_language
* English_name_of_language
* abbreviated_language_name
* native_name_of_language
* country_code
* localized_name_of_country
* English_name_of_country
* abbreviated_country_name
* native_name_of_country
* default_language_id
* default_language_id_decimal
* default_country_code
* default_oem_code_page
* default_ansi_code_page
* default_mac_code_page
* system_default_language_id	Hexadecimal Windows locale Id
* system_default_posix		Language_Region (Posix Style)
* system_default_lang_region	Language-Region (BCP 47 Style)

Les clés system_default donnent des informations sur la langue de l'OS installé. Les autres clés donnent des informations sur la localisation de l'interface graphique.

Exemple: +
Le code:
[source,winst]
----
message "Locale Infos"
set $INST_Resultlist$ = getLocaleInfoMap
----

produit par exemple le journal système:
[source,winst]
----
message Locale Infos

Set $INST_Resultlist$ = getLocaleInfoMap
    retrieving strings from getLocaleInfoMap [switch to loglevel 7 for debugging]
        (string   0)language_id_2chars=DE
        (string   1)language_id=DEU
        (string   2)localized_name_of_language=Deutsch (Deutschland)
        (string   3)English_name_of_language=German
        (string   4)abbreviated_language_name=DEU
        (string   5)native_name_of_language=Deutsch
        (string   6)country_code=49
        (string   7)localized_name_of_country=Deutschland
        (string   8)English_name_of_country=Germany
        (string   9)abbreviated_country_name=DEU
        (string  10)native_name_of_country=Deutschland
        (string  11)default_language_id=0407
        (string  12)default_language_id_decimal=1031
        (string  13)default_country_code=49
        (string  14)default_oem_code_page=850
        (string  15)default_ansi_code_page=1252
        (string  16)default_mac_code_page=10000
        (string  17)system_default_language_id=0407
        (string  18)system_default_posix=de_DE
        (string  19)system_default_lang_region=de-DE
----

Utilisation: Si nous définissons et appelons
[source,winst]
----
DefStringList $languageInfo$
set  $languageInfo$ = getLocaleInfoMap
----

nous obtenons la valeur associée à la clé "language_id_2chars" par l'appel 
[source,winst]
----
DefVar $result$
set $result$ = getValue("language_id_2chars", $languageInfo$)
----

(pour la fonction getValue voir <<opsi-winst-stringlist-getstring>>). Nous pouvons maintenant écrire des scripts en utilisant une construction comme
[source,winst]
----
if getValue("language_id_2chars", languageInfo) = "DE"
   ; installiere deutsche Version
else 
   if getValue("language_id_2chars", languageInfo) = "EN"
   ; installiere englische Version
   endif
endif 
----

[NOTE]
==============================

Infos de base pour getLocaleInfoMap:

* http://msdn.microsoft.com/en-us/library/cc233968.aspx
* http://msdn.microsoft.com/en-us/library/0h88fahh.aspx
* bcp 47 validator: +
http://schneegans.de/lv/?tags=de-de-1996&format=text

* http://www.iana.org/assignments/language-subtag-registry
* http://www.the-localization-tool.com/?p=698

==============================

*  `getLocaleInfo` +
(obsolète): utilisez `GetLocaleInfoMap` .

* `getProductMap` // depuis 4.11.2.1 +
retourne une carte d'information du produit opsi que vous venez d'installer. +
Il fonctionne uniquement si '{opsi-winst}' s'exécute en mode service d'opsi. +
les clés sont: id, name, description, advice, productversion, packageversion, priority, installationstate, lastactionrequest, lastactionresult, installedversion, installedpackage, installedmodificationtime


Exemple:
[source,winst]
----
set $INST_Resultlist$ = getProductMap
set $string1$ = getValue("id", $INST_Resultlist$)
----

produit par exemple le journal système:
[source,winst]
----
Set  $INST_Resultlist$ = getProductMap
    retrieving strings from getProductMap [switch to loglevel 7 for debugging]
        (string   0)id=opsi-winst-test
        (string   1)name=opsi-winst test
        (string   2)description=Test  and example script for opsi-winst
        (string   3)advice=
        (string   4)productversion=4.11.2
        (string   5)packageversion=1
        (string   6)priority=0
        (string   7)installationstate=unknown
        (string   8)lastactionrequest=setup
        (string   9)lastactionresult=successful
        (string  10)installedversion=4.11.2
        (string  11)installedpackage=1
        (string  12)installedmodificationtime=
        

Set  $string1$ = getValue("id", $INST_Resultlist$)
    retrieving strings from $INST_Resultlist$ [switch to loglevel 7 for debugging]
        (string   0)id=opsi-winst-test
        (string   1)name=opsi-winst test
        (string   2)description=Test  and example script for opsi-winst
        (string   3)advice=
        (string   4)productversion=4.11.2
        (string   5)packageversion=1
        (string   6)priority=0
        (string   7)installationstate=unknown
        (string   8)lastactionrequest=setup
        (string   9)lastactionresult=successful
        (string  10)installedversion=4.11.2
        (string  11)installedpackage=1
        (string  12)installedmodificationtime=
        
  The value of the variable "$string1$" is now: "opsi-winst-test"
----  

[[opsi-winst-stringlist-create-by-value]]
==== Produire des listes de chaînes à partir des chaînes

* `createStringList (`chaîne0, chaîne1 ,... `)` +
forme une liste de chaînes à partir des valeurs des expressions chaîne énumérés. Par exemple, avec
[source,winst]
----
set $list1$ = createStringList ('a','b', 'c', 'd')
----

nous obtenons une liste des quatre premières lettres de l'alphabet. 

Les deux fonctions suivantes produisent une liste de chaînes en séparant des chaîne:

* `splitString (`<chaîne1>, <chaîne2>`)` +
génère la liste partielle des chaînes de <chaîne1> (y compris les chaînes vides) before resp. between the occurences of <chaîne2>.  E.g., 
[source,winst]
----
set $list1$ = splitString ("\\server\share\directory",  "\")
----
définit la liste  +
'"", "", "server", "share", "directory"'

* `splitStringOnWhiteSpace (`<chaîne>`)` +
coupes StringVal par le "blancs" dedans. Par exemple 
[source,winst]
----
set $list1$ = splitStringOnWhiteSpace("Status   Lokal     Remote         Netzwerk")
----
produit la liste +
'"Status", "Lokal", "Remote", "Netzwerk"' +
peu importe combien d'espaces ou des tabulations constituent l'espace blanc entre les mots.

[[opsi-winst-stringlist-create-by-file]]
==== Chargement des lignes d'un fichier texte dans une liste de chaînes

* `loadTextFile (`<nom de fichier>`)` +
lit le fichier <nom de fichier> et génère la liste de chaînes, qui contient toutes les lignes du fichier.


* `loadUnicodeTextFile (`<nom de fichier>`)` +
lit le fichier texte unicode <nom de fichier> et génère la liste de chaînes, qui contient toutes les lignes du fichier. +
Par cet appel, les chaînes sont converties dans le code par défaut du système 8 bits.

* `getSectionNames (`<nom de fichier>`)` +
interprète le fichier spécifié comme un fichier ini, regardant pour la liste toutes les lignes de la forme +
'[<SectionName>]' +
et renvoie les noms de section (sans parenthèses).

[[opsi-winst-stringlist-getstring]]
==== Valeurs de chaîne simple générés à partir des listes de chaînes
 
* `composeString (`<liste de chaînes>, <liens de chaîne>`)` +
Grâce à cette fonction, les éléments d'une liste chaîne peuvent être collés les uns aux autres, médiée par un "colle de chaîne". +
Par exemple si '$list1$' représente la liste 'a', 'b', 'c', 'd', 'e' +
avec 
[source,winst]
----
$line$ = composeString ($list1$, " | ")
----
nous attribuons la valeur  '"a | b | c | d | e".' à '$line$'.

* `takeString(`<index>,<liste>`)` +
Par exemple si  $list1$ représente la liste des cinq premières lettres de l'alphabet, avec +
[source,winst]
----
takeString (2, $list1$)
----
on obtient la chaîne "c" (puisque le comptage de liste commence par 0). +
Les valeurs négatives de l'indice vont vers le bas de la valeur de comptage de liste. Par exemple, 
[source,winst]
----
takeString (-1, $list1$)
----
retourne le dernièr élément de la liste, qui est  "e".

* `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne de la liste qui contient la <chaîne de recherche>. +
Retourne une chaîne vide si aucune chaîne correspondant n'a été trouvé.

* `getValue (`<clé>, <liste>`)` +
Cette fonction tente d'interpréter une liste de chaînes comme liste de lignes de la forme 
'clé=valeur' +
Il examine la première ligne, où la chaîne <clé> est suivi par le signe égal, et renvoie le reste de la ligne ('valeur', la chaîne qui commence après le signe égal). S'il n'y a pas de ligne de raccord, elle retourne la chaîne 'NULL'. +
La fonction est requise pour l'utilisation des fonctions `getLocaleInfoMap` et `getFileVersionMap` (voir <<opsi-winst-stringlist-maps>>).

* `getValueBySeparator(`<chaîne clef>,<chaîne de séparation>,<liste de chaînes de hachage> `)` //depuis 4.11.2.1 +
fonctionne comme `getValue` mais vous devez donner la <chaîne de séparation> de sorte que peut également travailler avec des hachages, comme +
'key:value' 


* `count (`<liste>`)` +
renvoie le nombre d'éléments de la liste de chaînes <liste> en tant que chaîne. +
par exemple pour $list1$ composé comme +
'a', 'b', 'c', 'd', 'e' +
`count ($list1$)` a la valeur "5".

[[opsi-winst-stringlist-create-by-section]]
==== Produire des listes de chaîne à partir des sections opsi-winst

* `retrieveSection (`nom de la section`)` +
donne les lignes de la section spécifiée comme liste de chaînes.

* `getOutStreamFromSection (`nom de la section`)` +
invoque la section et – à ce moment mis en œuvre uniquement pour les appels `DosInAnIcon` (`ShellInAnIcon`),`ExecWith` et `ExecPython` – capture la sortie standard et des erreurs de la commande invoquée pour les écrire dans une liste de chaînes. Par exemple: +
[source,winst]
----
set $list$ = getOutStreamFromSection ('DosInAnIcon_netuse')

[DosInAnIcon_netuse]
net use
----
`$list1$` contient, parmi les quelques trucs environnantes, la liste de toutes les partages montée d'un PC. 


* `getReturnListFromSection (`nom de la section`)` +
Pour certains types de section - à ce moment mis en œuvre uniquement pour les sections `XMLPatch` et `opsiServiceCall` -  il y a une déclaration spécifique `return` qui donne un résultat de l'exécution de la section (supposé être de type liste de chaîne).  +
Par exemple nous pouvons utiliser l'instruction
[source,winst]
----
set list1 = getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----
pour obtenir une liste de noeud spécifique du fichier XML `mimetypes.rdf`. (Plus d'infos pour les sections XMLPatch dans <<opsi-winst-xmlpatch>> du manuel). +
Ou la liste des clients OPSI est produite par la référence à un appel de service OPSI: +
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")

[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

[[opsi-winst-stringlist-transform]]
==== Transformer les listes de chaînes

* `getSubList (`<index de démarrage>, <index de fin>, <liste> `)` +
retourne une liste partielle d'une liste donnée. +
Par exemple, si 'liste' représente la liste des lettres 'a', 'b', 'c', 'd', 'e', par la déclaration:
[source,winst]
----
set $list1$ = getSubList(1 : 3, $list$)
----
on obtient la liste partielle 'b', 'c', 'd' . L'index de démarrage ainsi que l'index de fin doivent être interprétées comme l'indice du premièr et du dernièr éléments de la liste incluse. Le comptage commence par 0. +
L'index de début par défaut est 0, l'indice de fin par défaut est l'indice du dernier élément de la liste. +
Par conséquent, (pour la list1 définie ci-dessus) la commande +
[source,winst]
----
set $list1$ = getSubList(1 : , $list$)
----
donne la liste 'b', 'c', 'd', 'e'. 
[source,winst]
----
set $list1$ = getSubList(:, $list$)
----
produit une copie de la liste originale. +
Il est possible de compter à rebours afin de déterminer le dernier indice: 
[source,winst]
----
set $list1$ = getSubList(1 : -1, $list$)
----
définit la liste des éléments à commencer par le premièr et se terminant du deuxième au dernier élément de la liste –  dans l'exemple ci-dessus on obtient à nouveau la liste 'b', 'c', 'd'.

* `getListContaining(`<liste>,<chaîne de recherche>`)` +
retourne la première chaîne à partir de <liste> qui contient la <chaîne de recherche>. Retourne une chaîne vide si la <chaîne de recherche> n'est pas trouvée.

* `takeFirstStringContaining(`<liste>,<chaîne de recherche>`)` +
Retourne la première chaîne de <liste> qui contient la <chaîne de recherche>. + Retourne une chaîne vide si la <chaîne de recherche> n'est pas trouvée.

* `addtolist(`<liste>,<chaîne>`)` +
Ajoute <chaîne> à la liste <liste>.

* `addlisttolist(`<liste1>,<liste2>`)` +
Ajoute la liste <liste2> à la liste <liste1>.

* `reverse (`<liste>`)` +
Produit la liste inversée, +
si  $list$ est 'a', 'b', 'c', 'd', 'e', avec +
[source,winst]
----
set $list1$ = reverse ($list$)
----
nous obtenons la $list1$ 'e', 'd', 'c', 'b', 'a'.

[[opsi-winst-stringlist-iteration]]
==== Itération à travers les listes de chaînes

Une utilisation importante de listes de chaînes est basé sur la possibilité que le script s'exécute à travers tous les éléments d'une liste exécutant quelques opérations sur chaque élément de la chaîne.

La syntaxe pour définir cette répétition est:

* `for` %s% `in` <liste> `do` <une déclaration | une sous-section>

Cette expression définit localement une variable de chaîne %s% qui prend une à une les valeurs des éléments de la liste.
<une déclaration> peut être n'importe quelle instruction unique qui peut exister dans une section primaire ou (et plus intéressant) il peut être un appel à une sous-section. L'indice d'itération définis localement %s% existe dans l'ensemble du contexte de la déclaration, en particulier dans la sous-section si la déclaration est un appel à la sous-section. 

CAUTION: Le mécanisme de remplacement pour %s% fonctionne toujours comme ça pour les constantes:  Le nom de la variable est remplacée par les valeurs des éléments. Si l'on parcour une liste 'a','b','c' et l'indice d'itération est nommé %s%, nous obtenons pour %s% un à un  a, b, c  –   pas les valeurs de la chaîne. Pour reproduire la liste originale des éléments nous devons enfermer %s% entre guillemets.

Exemple: Que $list1$ soit la liste  'a', 'b', 'c', 'd', 'e', et $line$ une variable chaîne. La déclaration  
[source,winst]
----
for %s% in $list1$ do  set $line$ = $line$ + "%s%"
----
parcourt les éléments de la liste interne exécutant
[source,winst]
----
$line$ = $line$ + "a"
$line$ = $line$ + "b"
$line$ = $line$ + "c"
$line$ = $line$ + "d"
$line$ = $line$ + "e"
----
A la fin la ligne a la valeur 'abcde' . Si nous avons omis les guillemets autour de %s% nous obtiendrions une erreur de syntaxe pour chaque étape d'itération.

Remarque: La variable note n'est valable que dans la procédure appelée directement. Si elle est nécessaire dans les sous-programmes de celui-ci sa valeur doit être transféré à une variable globale.

[[opsi-winst-special-commands]]
=== Commandes spéciales

* `Killtask` <processus>
tente d'arrêter tous les processus qui exécutent le programme nommé par l'expression de chaîne. +
Par exemple
[source,winst]
----
killtask "winword.exe"
----

*  `sleepSeconds` <entier> +
rompt l'exécution du programme pour <entier> secondes.

*  `markTime` +
établit l'horodatage pour l'actuel heure du système et ecris dans le juornal système. 

* `diffTime` +
enregistre le temps écoulé depuis le dernier `marktime`.


[[opsi-winst-commands-logging]]
=== Commandes pour contrôler la journalisation

* `comment` <chaîne> or `comment` = <const chaîne> +
écrit la valeur de l'expression de chaîne respectivement la séquence de caractères dans le journal système.

* `LogError` <chaîne> or `LogError` = <const chaîne> +
écrit des messages d'erreur supplémentaires dans le journal système et incrémente par un le compteur d'erreur.

* `LogWarning` <chaîne> or `LogWarning` = <const chaîne> +
écrit des messages d'avertissement additionnels dans le journal système et incrémente par un le compteur d'avertissement.

* `includelog` <nom de fichier> <taille de la queue>   //depuis 4.11.2.1 +
Inclut le fichier <nom de fichier> dans le journal système. Seule la dernière ligne <taille de la queue> sera incluse. Si vous démarrez un autre programme (par exemple le programme d'installation) qui produit un fichier de log, vous pouvez utiliser cette commande pour inclure les informations à partir de ce log dans le fichier de log de '{opsi-winst}'. +
Exemple: 
[source,winst]
----
includelog "%Scriptpath%\test-files\10lines.txt" "5"
----



[[opsi-winst-commands-information]]
=== Commandes d'information sur l'utilisateur et l'interaction utilisateur

*  `Message` <expression chaîne> +
ou +
`Message` = <séquence de caractères> +
permet à '{opsi-winst}' d'afficher la valeur de l'expression de chaîne respectivement la séquence de caractères dans la fenêtre des traitements par lots, dans la ligne d'information en haut. Le texte est conservé aussi longtemps qu'aucun nouveau `message` est défini. +
Exemple:
[source,winst]
----
Message "Installation von "+$productid$
----

* `ShowMessageFile` <nom de fichier> +
interprète l'expression de chaîne comme nom de fichier texte, essaie de lire le texte et de l'afficher dans une fenêtre d'informations utilisateur. L'exécution s'arrête jusqu'à ce que l'utilisateur confirme la lecture.  Par exemple par une commande comme 
[source,winst]
----
ShowMessageFile "p:\login\day.msg"
----
on peut réaliser un "Message du jour".

* `ShowBitMap` [<nom de l'image>] [<inscription>] +
place l'image dénotée par <nom de l'image> (dans le format BMP, JPEG ou PNG, de taille 160x160 pixel) et montre l'inscription. + 
<nom de l'image> et <inscription> sont des expressions de chaîne. +
Exemple: +
[source,winst]
----
ShowBitmap "%scriptpath%\" + $ProductId$ + ".png"  "$ProductId$"
----


* `Pause` <chaîne> ou `Pause` = <const chaîne> +
afficher le texte donné comme une expression chaîne ou comme une séquence de caractères dans une fenêtre d'information en attente jusqu'à ce que l'utilisateur confirme la poursuite. 

* `Stop` <chaîne> ou `stop` = <const chaîne> +
arrêt l'exécution du programme si l'utilisateur le confirme. The String expression resp. the (possibly empty) sequence of chars explain to the user what is supposed to be stopped.

[[opsi-winst-commands-loginscripts]]
=== Commandes pour userLoginScripts / Support de profil itinérant
NOTE: Le module 'Support de profil itinérant' est sous co-financement. Cela signifie que ces fonctionnalités ne sont pas libres encore (05.10.2011)

* `GetScriptMode`   //depuis 4.11.2.1 +
donne l'une des valeurs possibles 'Machine','Login': +
** 'Machine' - le script *ne* s'exécute *pas* en tant que 'userLoginScript'
** 'Login' - le script s'exécute en tant que 'userLoginScript'

* `GetUserSID(`<Nom d'utilisateur Windows>`)`

* `GetLoggedInUser`   //depuis 4.11.1.2

* `GetUsercontext`   //depuis 4.11.1.2 +
retourne le nom d'utilisateur dans le contexte duquel '{opsi-winst}' est en cours d'exécution.

* `saveVersionToProfile` //depuis 4.11.2.1 +
enregistre +productversion+-+packageversion+ dans le profil local  +
Il est conçu pour être utilisé dans 'userLoginScripts'. +
Cette commande est utilisée en combinaison avec `readVersionFromProfile` ou `scriptWasExecutedBefore`. Il marque que le 'userLoginScript' pour ce produit dans cette version du produit et cette version du paquet a été exécuté pour l'utilisateur actuel. Les informations sont enregistrées dans le fichier "%CurrentAppdataDir%\.opsi.org\userLoginScripts.ini"

* `readVersionFromProfile` //depuis 4.11.2.1 +
retourne une chaîne avec le +productversion+-+packageversion+ pour le produit opsi en cours d'exécution qui a été lue à partir du profil local. Voir aussi: `saveVersionToProfile` +
Il est conçu pour être utilisé dans 'userLoginScripts'.

* `scriptWasExecutedBefore` //depuis 4.11.2.1 +
Cette fonction booléenne `scriptWasExecutedBefore` vérifie si il ya un cachet de version dans le profil (comme vous pouvez le faire avec la commande `readVersionFromProfile`). Il retourne 'true' si +productversion+-+packageversion+ sauvegardés et cours d'exécution son identiques. Puis il crée une nouvelle empreinte du profil (comme vous pouvez le faire avec la commande `saveVersionToProfile`).  Vous pouvez donc simplement utiliser cette commande uniquement dans une déclaration +if+. +
Il est conçu pour être utilisé dans 'userLoginScripts'. 

* `isLoginScript`    //depuis 4.11.2.1 +
Cette fonction booléenne retourne 'true' si le script s'exécute en tant que 'userLoginScript'. Voir aussi: `GetScriptMode`



[[opsi-winst-commands-if-else]]
=== Instructions conditionnelles (déclarations if)

Dans les sections primaires, l'exécution d'une instruction ou d'une séquence d'instructions peut être subordonnée à certaines conditions.

Exemple
[source,winst]
----
;Quelle version de Windows?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----

[[opsi-winst-commands-if-else-syntax]]
==== Syntaxe générale

La syntaxe de l'instruction `if` complète est: +
`if` <condition> +
  <séquence d'instructions> +
`else` +
  <séquence d'instructions> +
`endif`

La partie `else` peut être omise.

Les déclarations `if` peuvent être imbriquées. A savoir, dans la séquence d'instructions qui dépendent d'une clause if (peu importe si if est à l'intérieur d'un if ou d'une partie else) une autre déclaration if peut se produire. 

<condition> est une <expression booléenne> . Une expression booléenne (ou logique) peut être construite comme une (chaîne) comparaison des valeurs, par les opérateurs booléens, ou par certains appels de fonctions qui permettent d'évaluer à vrai ou faux. Jusqu'à présent, ces valeurs booléennes ne peuvent pas être explicitement représentée dans un script '{opsi-winst}').

[[opsi-winst-commands-if-else-bool-functions]]
==== Les expressions booléennes

La comparaison de chaînes (ce qui est une expression booléenne) a la forme +
+<expression de chaîne> <signe de comparaison> <expression de chaîne>+ +
où <signe de comparaison> est l'un des signes +
`<`  `<=`  `=`  `>=`  `>`

Les comparaisons de chaînes sont des cas indépendant dans '{opsi-winst}'. 

L'inégalité doit être exprimée par un `NOT()` expression qui est présenté ci-dessous.

Il y a ainsi une expression de comparaison pour comparer des chaînes de chiffres (entier). Si aucun d'entre eux ne peuvent pas être convertie en chiffres, un erreur sera indiquée. +
Cette expression de comparaison de chiffres a la même forme que la comparaison des chaînes mais avec un préfixe INT du signe de comparaison: +
+<expression de chaîne> INT<signe de comparaison> <expression de chaîne>+ +
Ainsi, nous pouvons construire des expressions comme
[source,winst]
----
if $Nom1$ INT<= $Nom2$
----

ou
[source,winst]
----
if $chiffre1$ INT>= $chiffre2$
----

Les opérateurs booléens sont `AND`, `OR`, et `NOT()` (Peu importe la casse). Si  b1, b2 et b3 sont des expressions booléennes des expressions combinées +
b1 `AND` b2 +
b1 `OR` b2 +
`NOT(` b3 `)` +
sont des expressions booléennes ainsi dénotant respectivement la conjonction (`AND`), la disjonction (`OR`) et la négation (`NOT`).

Une expression booléenne peut être mis entre parenthèses (produisant une nouvelle expression booléenne avec la même valeur).

Les règles communes de priorité des opérateurs booléens ("and" avant "or") à cet instant ne sont pas appliqué.  Une expression avec plus d'un opérateur est interprétée de gauche à droite. Pour plus de clarté, dans une expression booléenne qui combine les opérateurs `AND` et `OR`  les parenthèses doivent être employés, par exemple nous devrions écrire explicitement
b1 `OR` (b2 `AND` b3) +
ou +
(b1 `OR` b2) `AND` b3 +
Le deuxième exemple décrit ce que serait exécuté s'il n'y avait pas de parenthèses - alors que l'interprétation commune irait comme l'autre ligne indique.

Les opérateurs booléens peuvent être conçus comme des fonctions de valeur Booléenne spéciaux (l'opérateur de négation le démontre très clairement).

Il y a quelques fonctions booléenne en plus mis en œuvre. Chaque appel d'une telle fonction constitue une expression booléenne ainsi:

* `FileExists`(<nom de fichier>) +
Renvoie 'true' si le fichier ou le répertoire notée existe autrement 'false'.  

* `FileExists32`(<nom de fichier>)	voir <<opsi-winst-64bit,Chapter 64 Bit support>>

* `FileExists64`(<nom de fichier>)	voir <<opsi-winst-64bit,Chapter 64 Bit support>>

* `FileExistsSysNative`(<nom de fichier>) voir <<opsi-winst-64bit,Chapter 64 Bit support>>

* `LineExistsIn`(<ligne>, <nom de fichier>) +
Renvoie 'true' si le fichier texte désigné par <nom de fichier> contient une ligne tel que spécifié dans le premier paramètre, où chaque paramètre est une expression chaîne. Sinon (ou si le fichier n'existe pas) il renvoie 'false'.

* `LineBeginning_ExistsIn`(<chaîne>, <nom de fichier>)  +
Renvoie 'true' si il y a une ligne qui commence par <chaîne> dans le fichier texte désigné par <nom de fichier> (chaque paramètre étant une expression chaîne). Sinon (ou si le fichier n'existe pas) il renvoie 'false'.

* `XMLAddNamespace`(<nom de fichier XML>, <nom de l'élément XML>, <XMLnamespace>) +
insère une définition XML namespace dans le premier élément XML avec le nom donné (si non existant). Il restitue si une insertion a eu lieu. (La section patch XML de '{opsi-winst}' a besoin de la définition de namespace.) +
The file must be formatted that an element tag has no line breaks in it.  
Pour un exemple, voir les recettes <<opsi-winst-cookbook-xmlnamespace>>. 

* `XMLRemoveNamespace`(<nom de fichier XML>, <nom de l'élément XML>, <XMLnamespace>)  +
supprime la définition XML namespace à partir de XML element. Il restitue si un retrait a eu lieu. Nous avons besoin de cela pour simuler que le fichier original reste inchangé. Pour un exemple, voir les recettes <<opsi-winst-cookbook-xmlnamespace>>.

* `HasMinimumSpace`(<Nom du disque>, <Capacité>) +
renvoie vrai si au moins une capacité reste sur le disque  <Nom du disque>.  <Capacité> ainsi que  <Nom du disque> syntaxiquement sont expressions de chaîne. La capacité peut être donné comme une chiffre sans spécification d'unité (ensuite interprété comme octets) ou avec les unité "kB", "MB", or "GB" (la casse est indépendante). +
Exemple:
[source,winst]
----
if not (HasMinimumSpace ("%SYSTEMDRIVE%", "500 MB"))
  LogError "Not enough space on %SystemDrive%, 500MB on drive %SystemDrive% needed"
  isFatalError
endif
----

* `opsiLicenseManagementEnabled` +
Renvoie 'true' si le module de gestion des licences opsi est activé.

* `runningAsAdmin` +
Renvoie 'true' si le script est exécuté dans un compte administrateur.

[[opsi-winst-commands-subcall]]
=== Appels de Sous-programme

Les déclarations dans les sections primaires qui désignent des instructions déclaré ailleurs sont des appels de sous-programme.,

[source,winst]
----
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----
Dans cet exemple la déclaration:
[source,winst]
----
sub_install_winXP
----
"appelle" la section intitulée [sub_install_winXP] qui est placé quelque part ailleurs dans le script. Par exemple nous pouvons avoir
[source,winst]
----
[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP
----

Généralement, Il y a trois façons de placer les instructions mentionnées:

* La cible la plus courante d'un appel de sous-programme est une autre section interne dans le fichier de script où la déclaration d'appel est placé (comme dans l'exemple).

* Nous pouvons mettre les instructions mentionnées dans un autre fichier servant de section externe.

* Toute liste de chaînes peuvent être utilisés comme liste d'instructions pour un appel de sous-programme.

Nous décrivons la syntaxe des appels de sous-programme dans le détail:

[[opsi-winst-commands-subcall-components]]
==== Syntaxe de procédure d'appel

Formellement, la syntaxe peut être donnée par +
'<type de proc.>(<nom de proc.> | <Fichier Extern de proc.> | <Fonction de liste de chaînes> )'

Cette expression peut être complétée par un ou plusieurs paramètres (dépendant du type de procédure). 

Cela signifie que: Un appel de procédure se compose de trois parties principales.

La première partie est le spécificateur de type de sous-programme. +
Exemples de noms de type sont 'Sub' (nous appelons une procédure de type 'sub' qui est à nouveau une section primaire) ou 'Files' et 'WinBatch' (appels des sections secondaires spéciales). La vue d'ensemble complète des types de sous-programme existants figure à <<opsi-winst-commands-subcall>>.

La deuxième partie détermine où et comment on trouve les lignes de sous-programme.

. Le sous-programme est une séquence de lignes situées dans le script '{opsi-winst}' en exécution, comme une autre section interne. Puis un nom (constitué à partir de lettres, de chiffres et de caractères spéciaux) doit être ajouté au spécificateur de type (sans espaces) afin de former un nom de section unique. +
`sub_install_winXP` +
ou +
`files_copy_winXP` +
Section names sont indépendentes de la casse comme toute autre chaîne. 

. Si le spécificateur de type est unique, une expression de liste de chaînes ou une expression de chaîne est attendue. Si l'expression suivant le spécificateur de type ne peut pas être résolue comme un'expression de liste de chaînes (voir case (3)) il est supposé être une expression chaîne. La chaîne est alors interprétée comme un nom de fichier. '{opsi-winst}' essaie d'ouvrir le fichier comme un fichier texte et interprète ses lignes comme une section externe du type spécifié. +
Par exemple: +
`sub "p:\install\opsiutils\mainroutine.ins"`
essaie d'exécuter les lignes de mainroutine.ins comme des déclarations d'une sous-section. 

. Si l'expression suivant le spécificateur de type de section pure est résoluble comme une expression liste de chaîne les lignes de la liste sont interprétés comme des déclarations de la section. +
Ce mécanisme peut par exemple être utilisés pour charger un fichier au format Unicode et ensuite la traiter par les mécanismes habituels
[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----

Syntaxiquement, cette ligne est composée de trois parties principales: +
* `registry`, la déclaration coeur, spécifiant le type de section, +
* `loadUnicodeTextFile(...)`, une expression de liste de chaînes spécifiant la façon d'obtenir les lignes d'une section registre respectivement son substitut. +
* `/regedit`, paramétrage de l'appel de registre. 

Dans cet exemple, le paramètre d'appel donne déjà un exemple pour la troisième partie d'un appel desous-section:

La troisième partie d'une procédure d'appel comprend les options d'appel spécifique du type. 

Pour une référence des options d'appel voir les descriptions des appels de section dans <<opsi-winst-secsections>>.

[[opsi-winst-commands-reboot]]
=== Contrôle du redémarrage

La commande `ExitWindows` est utilisé pour contrôler le redémarrage, l'arrêt et des actions similaires qui devrait se dérouler après la fin de l'execution de '{opsi-winst}'. Le nom de la commande et le fait qu'il n'y ait pas de 'ExitWindows' sans modificateur a des raisons historiques: Dans Windows 3.1 vous pourriez quitter Windows pour revenir au niveau DOS.

* `ExitWindows /RebootWanted` +
DEPRECATED: une demande de redémarrage est enregistré qui devrait être exécutée lorsque toutes les demandes d'installations sont traitées, et le dernier script est terminé. +
En fait, cette commande est maintenant traitée comme un `ExitWindows /Reboot` (car sinon une installation pourrait échouer parce qu'un produit nécessaire n'est pas encore complètement installé).

* `ExitWindows /Reboot` +
déclenche le redémarrage après que '{opsi-winst}' a terminé le script actuellement traités.

* `ExitWindows /ImmediateReboot` +
brise l'exécution normale d'un script n'importe où dedans. Lorsque cette commande est appelée '{opsi-winst}' s'exécute aussi directement que possible jusqu'au bout entraînant l'appel système ExitWindows. Dans le contexte d'un opsi-client-agent installé il est garanti que après le redémarrage '{opsi-winst}' s'exécute à nouveau dans le script qui a avorté. Par conséquent, le script doit prendre des dispositions que l'exécution continue après le point où elle a été laissée la fois avant (sinon on peut obtenir une boucle infinie ...) Voir l'exemple dans cette section.

* `ExitWindows /ImmediateLogout` +
L'exécution normale d'un script se coupe au point de l'appel, et '{opsi-winst}' s'arrête. Ce comportement est nécessaire si une connexion automatisé doit avoir lieu pour un utilisateur (voir <<opsi-winst-cookbook-local-admin>>).

* `ExitWindows /ShutdownWanted` +
positionne un drapeau dans le registre que le PC s'éteint lorsque toutes les demandes d'installations sont traitées, et le dernier script est terminé. 

Par le fragment de code suivant nous démontrons la manière dont des drapeaux peuvent être définis pour s'assurer que le script ne s'exécute pas dans une boucle infinie lorsque l'on appelle `ExitWindows /ImmediateReboot`:
[source,winst]
----
DefVar $OS$
DefVar $Flag$
DefVar $WinstRegKey$
DefVar $RebootRegVar$

set $OS$=EnvVar("OS")

if $OS$="Windows_NT"
   
  Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
  Set $Flag$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"RebootFlag")

  if not ($Flag$ = "1")
     ;========================= 
     ; Statements BEFORE Reboot 

     Files_doSomething    

     ; initialize reboot ...
     Set $Flag$ = "1"
     Registry_SaveRebootFlag
     ExitWindows /ImmediateReboot

  else 
     ;========================= 
     ; Statements AFTER Reboot

     ; set back reboot flag
     Set $Flag$ = "0"
     Registry_SaveRebootFlag

     ; the work part after reboot:

     Files_doMore

  endif

endif   


[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$Flag$"

[Files_doSomething]
; une section exécutée avant le redémarrage 

[Files_doMore]
; une section exécutée après le redémarrage
----

[[opsi-winst-commands-isfatalerror]]
=== Garder la trace des installations qui ont échoué

Si une installation de produit échoue cela devrait être signalé au serveur.

Selon le fait qu'il n'y a pas d'automatisme pour détecter une installation qui a échoué cela doit être fait par les commandes du script. 

Pour indiquer dans un script '{opsi-winst}' que l'installation a échoué nous devons appeler la déclaration: +
`isFatalError` +
Si cette déclaration est appelé '{opsi-winst}' arrête l'exécution normale du script et définit le résultat du produit à 'failed' (sinon, il est à 'success'). +
Par exemple, une "erreur fatale" doit être déclenchée s'il n'y a pas beaucoup d'espace disque libre nécessaire pour une installation: 
[source,winst]
----
DefVar $SpaceNeeded$"
Set $SpaceNeeded$" = "200 MB"

DefVar $LogErrorMessage$ 
Set $LogErrorMessage$ = "Not enough space on drive . Required " 
Set $LogErrorMessage$ = $LogErrorMessage$ + $SpaceNeeded$" 

if not(HasMinimumSpace ("%SYSTEMDRIVE%", $SpaceNeeded$))
  LogError $LogErrorMessage$
  isFatalError
  ; finish execution and set ProductState to failed

 else
  ; we start the installation 
  ; ...

 endif
----

Il est aussi possible d'indiquer +
`isFatalError` +
selon le nombre d'erreurs qui sont survenues dans une partie critique d'un script d'installation. Pour ce faire, on initialise le compteur d'erreur par la commande +
* `markErrorNumber` +
Le nombre d'erreurs d'exécution qui se produisent après le réglage du compteur peut être interrogé par la fonction +
* `errorsOccuredSinceMark` +
Nous pouvons évaluer le résultat dans une condition de comparaison numérique (que n'est encore mis en œuvre pour cette expression). Par exemple, on peut indiquer: +
* `if errorsOccuredSinceMark > 0` +
et, si cela semble logique, indiquer ensuite: +
`isFatalError` +
Pour augmenter le nombre d'erreurs compté en fonction de certaines circonstances (qui ne produisent pas directement d'erreur) nous pouvons utiliser la déclaration `logError`. 

Nous pouvons le tester avec le script de l'exemple suivant:
[source,winst]
----
markErrorNumber
; Les erreurs survenant après cette marque sont comptés and 
; et seront éventuellement considérés comme fatales

logError "test error"
; nous écrivons "test error" dans le journal système
; et augmentons le nombre d'erreurs de 1
; pour les tests, commentez cette ligne 


if errorsOccuredSinceMark > 0
    ; nous terminons l'exécution du script le plus rapidement possible
    ; et nous mettons, l'état du produit à "failed"

    isFatalError
    ; mais l'écriture des commentaires n'est pas arrêté 

    comment "error occured"

else
    ; aucune erreur n'est survenue, nous allons journaliser ceci:

    comment "no error occured"
endif
----

[[opsi-winst-secsections]]
== Sections Secondaires

Les sections secondaires peuvent être appelés depuis n'importe quelle section primaire mais elles ont une syntaxe différente. La syntaxe est dérivé des exigences fonctionnelles, des conditions de la bibliothèque et des conventions pour les besoins spécifiques. Donc à partir d'une section secondaire, aucune autre section peut être appelée.

Les sections secondaires sont spécifiques à chaque zone fonctionnelle. Il s'agit de l'objet de la fonctionnalité, par exemple le système de fichier en général, le registre de Windows, ou les fichiers XML. Mais il se réfère encore plus au dispositif qui est appliquée en interne. Cela peut être démontré par les variantes des sections batch (qui appellent des programmes ou des scripts externes). 

Le contexte fonctionnel est reflété dans la syntaxe spécifique du type de section particulière. 

[[opsi-winst-files]]
=== Les sections Files (Fichiers)

Une section Fichiers propose principalement des fonctions qui correspondent aux commandes de copie du système d'exploitation sous-jacent. La plus-value lorsque vous utilisez les commandes '{opsi-winst}' est la journalisation détaillée et la vérification de toutes les opérations si nécessaire. Si vous le souhaitez l'écrasement des fichiers peut être interdit si des nouvelles versions d'un fichier (par exemple un nouveau fichier dll) sont déjà installés sur le système. 

[[opsi-winst-files-example]]
==== Exemple 

Une simple section Files pourrait être:

[source,winst]
----
[Files_do_some_copying]
copy -sV "p:\install\instnsc\netscape\*.*" "C:\netscape"
copy -sV "p:\install\instnsc\windows\*.*" "%SYSTEMROOT%"
----

Ces commandes font en sorte que tous les fichiers du répertoire
 'p:\install\instnsc\netscape' sont copiés dans le répertoire `C:\netscape`, et ensuite tous les fichiers de `p:\install\instnsc\windows` dans le répertoire système de Windows (sa valeur est automatiquement inséré dans la constante `%SYSTEMROOT%`).
L'option `-s` signifie que tous les sous-répertoires sont aussi bien copiés, `-V` active le contrôle de version pour les fichiers de la bibliothèque.

[[opsi-winst-files-params]]
==== Modificateur

Dans la plupart des cas, une section Files sera appelé sans paramètres.

Il ya seulement quelques utilisations spéciales d'une section Files où la cible d'actions de copie est défini ou modifié d'une certaine manière spécifiée. Nous avons obtenu les deux paramètres optionnels

* `/AllNTUserProfiles` resp.
* `/AllNTUserSendTo`

Les deux variantes signifient: +
La section Files appelée est exécuté une fois pour chaque utilisateur local Windows NT.
Chaque commande de copie dans la section est associée à un répertoire d'utilisateurs spécifiques. 

Dans d'autres cas nous avons besoin de construire d'autres noms de chemins spécifiques aux utilisateurs, alors nous pouvons utiliser la variable, définie automatiquement, `%UserProfileDir%` ou `%CurrentProfileDir%` depuis la version 4.11.2 de '{opsi-winst}'. 
Avec l'option `/AllNTUserProfiles` le répertoire cible spécifique aux utilisateurs pour les tâches de copie, est le répertoire du profil utilisateur (qui est habituellement désigné par le nom de l'utilisateur et est située par défaut comme un sous-répertoire du répertoire userappdata. En cas d'option `/AllNTUserSendTo` le répertoire cible est le chemin du dossier utilisateur spécifique 'SendTo' (pour les liens du menu contextuel de l'explorateur de Windows).

La règle exacte pour déterminer le chemin cible pour une commande de copie, comporte trois parties:

. Si seulement la source d'une action de copie est spécifié, les fichiers sont copiés directement dans le répertoire cible de l'utilisateur. Nous avons la syntaxe +
`copy <fichier(s) source>` +
Elle sera équivalente +
`copy <fichier(s) source> "%UserProfileDir%"`
ou depuis 4.11.2 +
`copy <fichier(s) source> "%CurrentProfileDir%"`


. Si un targetdir est spécifié et targetdir est une description de chemin relatif (commencent ni avec un nom de lecteur, ni un anti-slash) alors targetdir est le nom d'un sous-répertoire du répertoire spécifique de l'utilisateur. Par exemple +
`copy <fichier(s) source> <targetdir>` +
est interprété comme: +
`copy <fichier(s) source> "%UserProfileDir%\targetdir"`
ou depuis 4.11.2 +
`copy <fichier(s) source> "%CurrentProfileDir%\targetdir"`

L'usage de `%CurrentProfileDir%` a l'avantage que vous pouvez avoir la même section 'Files' avec `/AllNTUserProfiles` si elle ne s'èxecute pas comme 'userLoginScript' (dans le mode 'Machine' du script) et sans `/AllNTUserProfiles` si elle s'èxecute comme 'userLoginScript' (dans le mode 'Login' du script).


. Si targetdir est un chemin absolu il est utilisé comme chemin cible statique de l'action de copie.

Il y a aussi les options:

* `/32Bit`
* `/64Bit`
* `/SysNative`

qui manipulent les 'file redirection' sur les systèmes 64 bits. 
Pour plus de détails, voir <<opsi-winst-64bit>>
 
==== Commandes

Dans une section Files sont définies les commandes suivantes:

* `Copy`

* `Delete`

* `del`

* `SourcePath`

* `CheckTargetPath`

`Copy` et `Delete` correspondent grosso modo aux commandes shell Windows xcopy et del. 

`SourcePath` et `CheckTargetPath` definissent l'origine et la destination des actions à venir de copie (comme si nous allions ouvrir deux fenêtres d'explorateur pour les tâches de copie entre eux). Si le chemin cible n'existe pas il sera créé.


Les définitions de syntaxe sont: 

* `Copy` [-svdunxwnr] <source(masque)> <chemin cible>
+ 
Les fichiers source peuvent être désigné explicitement, en utilisant le caractere joker (”* ”) ou par un nom de répertoire.  
+
CAUTION: Le <chemin cible> est toujours entendue comme un nom de répertoire. Renommer en copiant n'est pas possible. Si le chemin cible n'existe pas il sera créé (cas échéant, une hiérarchie de répertoires). 
+
Les modificateurs optionnels de la commande Copy signifient (l'ordre est insignifiante): 

** `s` -> récursif dans les sous-répertoires.

** `e` -> sous-répertoires vides. +
S'il y a des sous-répertoires vides dans le chemin source ils seront créés aussi bien dans le répertoire cible.

** `V` -> vérification de version +
Une nouvelle version d'un fichier de bibliothèque de Windows n'est pas écrasée par un ancien (conformément principalement au numero de version interne du fichier). S'il y a des doutes quant à la priorité des fichiers un avertissement est ajouté au fichier journal système.

** `v` -> (Ne pas utiliser) +
Avec le contrôle de version: +
Obsolète: Ne pas utiliser sur des systèmes supérieurs à win2k. Parce qu'il vérifie non seulement le répertoire cible, mais aussi %System%.
utiliser `-V` à la place.

** `d` -> Avec vérification de la date: +
Un nouveau fichier .exe n'est pas écrasé par un ancien. 

** `u` -> seulement mise à jour des fichiers: +
Un fichier n'est pas copié s'il y a un nouveau fichier ou tout aussi un ancien du même nom. 

** `x` -> extraire +
Si un fichier est une archive zip, il sera déballé (extrait) à la copie. +
Attention: Les archives zip ne sont pas caractérisés par leur nom mais par une définition interne. Par exemple un fichier jar java est un fichier zip. S'il est déballé l'appel à application ne fonctionnera pas.

** `w` -> faible +
Respectons toutes protections en écriture d'un fichier avec une procédure "sans force" (au contraire du comportement par défaut qui est d'essayer d'utiliser les privilèges d'administrateur et d'écraser un fichier protégé en écriture).

** `n` -> ne pas écraser +
Les fichiers existants ne sont pas écrasés. 

** `c` -> continue +
Si un système de fichier est utilisé, alors il peut être remplacé seulement après un redémarrage. Le comportement par défaut de '{opsi-winst}' est donc que les fichiers en cours d'utilisation seront marqués pour écrasement au prochain réamorçage, ET l'indicateur de redémarrage de '{opsi-winst}' est défini. Le réglage du modificateur de copy à "-c" desactive le redémarrage automatique. Au lieu, le traitement normal se poursuit, la copie sera terminée que lorsque le redémarrage est par ailleurs déclenché.

** `r` -> attribut de lecture seule +
Si un fichier copié a un attribut de lecture seule il est mis de nouveau (au contraire du comportement par défaut qui est d'éliminer les attributs de lecture seule). 

* `Delete` [-sfd[n]] <chemin>

ou

* `Delete` [-sfd[n]] <source(masque)>
+
supprime les fichiers et les répertoires. 

Les options possibles sont (avec un ordre arbitraire)

** `s` -> sous-répertoires +
recursivement dans les sous-répertoires. Tout ce qui correspond au nom du chemin ou au masque source est supprimé. 
+
CAUTION: La commande +
`delete -s c:\opsi` +
Ne veut pas dire: supprimer le répertoire 'c:\opsi' recursivement, mais cela signifie: supprimer à partir de 'c:\' toutes les occurrences de 'opsi'. Cela peut conduire à une analyse complète du disque dur. +
Si vous voulez supprimer recursivement le répertoire 'c:\opsi' utilisez la commande: +
`delete -s c:\opsi\` +
en utilisant une barre oblique inverse vous définissez que 'opsi' est un répertoire. +
*Il est plus sûr d'utiliser la commande `del` plutôt.*

** `f` -> force +
force à supprimer les fichiers en lecture seule 

** `d [n]` -> date +
Seuls les fichiers d'âge n jours ou plus sont supprimés. n par défaut à 1.

* `del` [Options] <chemin[/masque]]   //depuis 4.11.2.1 +
Fonctionne comme `delete` mais à +
`del -s -f c:\not-exists` +
Si +c:\not-exists+ n'existe pas, ne sera pas faite une recherche complète dans +c:\+ pour +not-exits+  

Exemple (*vous pouvez oublier la barre oblique inverse*): +
`del -sf c:\delete_this_dir`


* `SourcePath` = < répertoire source > +
Définit <répertoire source> comme répertoire par défaut pour les commandes suivantes `Copy` et (!) `Delete`.

* `CheckTargetPath` = <répertoire cible> +
Définit <répertoire cible> comme répertoire par défaut pour la commande `Copy`. Si le chemin spécifié n'existe pas il sera créé.

[[opsi-winst-patches]]
=== Sections Patches 

Une section Patches modifie un fichier de propriétés au format de fichier ini. À savoir un fichier qui se compose des sections qui sont une séquence des entrées construites en tant que paramètres '<variable> = <valeur>'. Où les sections sont caractérisées par titres qui sont des noms entre parenthèses, comme '[nom_de_section]'. 

[[opsi-winst-patches-examples]]
==== Exemple

[source,winst]
----
Patches_DUMMY.INI $HomeTestFiles$+"\dummy.ini"

[Patches_dummy.ini]
add [secdummy] dummy1=add1
add [secdummy] dummy2=add2
add [secdummy] dummy3=add3
add [secdummy] dummy4=add4
add [secdummy] dummy5=add5
add [secdummy] dummy6=add6
set [secdummy] dummy2=set1
addnew [secdummy] dummy1=addnew1
change [secdummy] dummy3=change1
del [secdummy] dummy4
Replace dummy6=add6 replace1=replace1
----

entraîne le journal système suivant:
[source,winst]
----
Execution of Patches_DUMMY.INI
      FILE C:\tmp\testFiles\dummy.ini
      Info: This file does not exist and will be created 
  addEntry [secdummy] dummy1=add1
    addSection [secdummy]
      done
      done
  addEntry [secdummy] dummy2=add2
      done
  addEntry [secdummy] dummy3=add3
      done
  addEntry [secdummy] dummy4=add4
      done
  addEntry [secdummy] dummy5=add5
      done
  addEntry [secdummy] dummy6=add6
      done
  setEntry [secdummy] dummy2=set1
    Entry      dummy2=add2
    changed to dummy2=set1
  addNewEntry [secdummy] dummy1=addnew1
    appended entry
  changeEntry [secdummy] dummy3=change1
    entry      dummy3=add3
    changed to dummy3=change1
  delEntry [secdummy] dummy4
    in section secdummy deleted  dummy4=add4
  replaceEntrydummy6=add6 replace1=replace1
    replaced in line 7
  C:\tmp\testFiles\dummy.ini saved back
----

Pour plus d'exemples, s'il vous plaît vérifier le produit standard OPSI 'opsi-winst-test' et dans ce produit la partie '$Flag_winst_patches$ = "on"'

[[opsi-winst-patches-params]]
==== Paramètre

Comme le montre l'exemple le nom du fichier de la propriété à patcher est spécifié comme paramètre de l'appel au sous programme.

[[opsi-winst-patches-commands]]
==== Commandes

Pour une section Patches, nous avons les commandes:

* `add`

* `set`

* `addnew`

* `change`

* `del`

* `delsec`

* `replace`

Chaque commande fait référence à une certaine section du fichier qui doit être patché. Le nom de cette section est précisé entre parenthèses `[ ]` (qui ne veut pas dire ici "syntaxe optionnelle"!!).

En détail: 

* `add [`<nom de la section>`]` <variable1> `=` <valeur1> +
Cette commande ajoute une entrée de type <variable1> = <valeur1> à la section <nom de la section> s'il n'y a pas encore d'entrée pour <variable1> dans cette section. Sinon rien n'est écrit. Si la section n'existe pas elle sera créée.

* `set [`<nom de la section>`]`<variable1> `=` <valeur1> +
S'il n'y a pas d'entrée pour <variable1> dans la section <nom de la section> le paramètre <variable1> = <valeur1> est ajoutée. Sinon, la première entrée  <variable1> = <valeurX> est changé en <variable1> = <valeur1>. 

* `addnew [`<nom de la section>`]`<variable1> `=` <valeur1> +
Peu importe s'il y a une entrée pour <variable1> dans la section <nom de la section> le paramètre <variable1> = <valeur1> est ajoutée. 

* `change [`<nom de la section>`]`<variable1> `=` <valeur1> +
Seulement s'il ya une entrée pour <variable1> dans la 
section <nom de la section> elle est changée en <variable1> = <valeur1>. 

* `del [`<nom de la section>`]` <variable1> `=` <valeur1> +
respectivement +
`del [`<nom de la section>`]` <variable1> +
supprime toutes les entrées <variable1> = <valeur1> respectivement toutes les entrées pour <variable1> dans la section <section name>. 

* `delsec [`<nom de la section>`]` +
supprime la section <section name>.

* `replace` <variable1>`=`<valeur1> <variable2>`=`<valeur2> +
signifie que <variable1> = <valeur1> sera remplacé par <variable2> = <valeur2> dans toutes les sections du fichier ini. Il ne doit pas y avoir aucun espace dans la valeur ou autour du signe égal.  

[[opsi-winst-patchhosts]]
=== Sections PatchHosts

En vertu d'une section PatchHosts nous sommes en mesure de modifier un fichier hosts qui est n'importe quel fichier avec des lignes ayant le format +
'adresseIP	nomHôte aliases  # commentaires'

'Aliases' et 'commentaires' (et le séparateur de commentaires #) sont optionnels. Une ligne peut également être une ligne de commentaire commençant par # .

Le fichier qui doit être modifié peut être donnée comme paramètre d'un appel 'PatchHosts'. S'il n'y a aucun paramètre un fichier nommé `HOSTS` est recherché dans les répertoires `c:\nfs`, `c:\windows` et `%systemroot%\system32\drivers\etc`. Si aucun fichier n'est trouvée l'appel 'PatchHosts' termine avec une erreur.

Dans une section PatchHosts il y a des commandes définies: 

* `setAddr`

* `setName`

* `setAlias`

* `delAlias`

* `delHost`

* `setComment`


Exemple:
[source,winst]
----
PatchHosts_add $HomeTestFiles$+"\hosts"

[PatchHosts_add]
setAddr ServerNo1 111.111.111.111
setName 222.222.222.222 ServerNo2
setAlias ServerNo1 myServerNo1
setAlias 222.222.222.222 myServerNo2
setComment myServerNo2 Hallo Welt
----

entraîne le journal système suivant:
[source,winst]
----
Execution of PatchHosts_add
   FILE C:\tmp\testFiles\hosts
  Set ipAddress 111.111.111.111 Hostname "ServerNo1"
  Set Hostname "ServerNo2" for ipAddress 222.222.222.222
  Alias "myServerNo1" set for entry "ServerNo1"
  Alias "myServerNo2" set for entry "222.222.222.222"
  SetComment of Host "myServerNo2" to "Hallo Welt"
  C:\tmp\testFiles\hosts saved back
----

Pour plus d'exemples, s'il vous plaît vérifier le produit standard OPSI 'opsi-winst-test' et dans ce produit la partie '$Flag_winst_patch_hosts$ = "on"'.

En détail: 

* `setaddr` <nom d'hôte> <Adresse ip> +
définit l'adresse IP pour l'hôte <nom d'hôte> à <Adresse ip>. S'il n'y a pas d'entrée pour le nom d'hôte il sera créé. 

* `setname` <ipaddresse> <nom d'hôte> +
définit le nom d'hôte pour l'adresse IP donnée. S'il n'y a pas d'entrée pour l'Adresse IP il sera créé.

* `setalias` <nom d'hôte> <alias> +
ajoute un alias pour l'hôte nommé <nom d'hôte>.

* `setalias` <Adresse ip> <alias> +
ajoute un nom d'alias pour l'hôte avec Adresse ip <Adresse ip>.

* `delalias` <nom d'hôte> <alias> +
supprime le nom d'alias <alias> pour l'hôte nommé <nom d'hôte> .

* `delalias` <Adresse ip> <alias> +
supprime le nom d'alias <alias> pour l'hôte avec Adresse ip <Adresse ip>.

* `delhost` <nom d'hôte>
supprime l'entrée complète de l'hôte avec le nom <nom d'hôte>.

* `delhost` <Adresse ip> +
supprime l'entrée complète de l'hôte avec l'Adresse ip <Adresse ip>. 

* `setComment` <identité> <commentaire> +
écrit <commentaire> après le signe de commentaire pour l'hôte avec le nom d'hôte, Adresse ip ou nom d'alias <identité>.

[[opsi-winst-idapi]]
=== Sections IdapiConfig

Les sections IdapiConfig ont été conçues pour écrire des paramètres dans les fichiers idapi*.cfg qui sont utilisés par les Borland Database Engine.

Ce type de sections ne sont plus supporté.

[[opsi-winst-patchtextfile]]
=== Sections PatchTextFile

Une section PatchTextFile offre une variété d'options pour patcher les fichiers de configuration quelconque qui sont donnés sous forme de fichiers texte ordinaire (à savoir qu'ils peuvent être traités ligne par ligne).

Un outil indispensable pour travailler sur des fichiers texte est vérifier si une ligne spécifique est contenue dans un fichier donné. A cet effet, nous disposons des fonctions booléennes `Line_ExistsIn` et `LineBeginning_ExistsIn` (voir <<opsi-winst-commands-if-else-bool-functions>>).

[[opsi-winst-patchtextfile-params]]
==== Paramètre

Le fichier texte à traiter est donné en paramètre.

[[opsi-winst-patchtextfile-commands]]
==== Commandes

Nous disposons de deux commandes en particulier pour patcher les fichiers des préférences de Mozilla, plus les deux obsolète et plus restreint anciennes versions de ces commandes:

* `Set_Mozilla_Pref` ("<type de préférence>", "<clé de préférence>", "<valeur de préférence>") +
fixér pour <type de préférence> la valeur associée à "<preference variable>" à "<valeur de préférence>". +
Dans les fichiers de préférences actuelles de Mozilla il y a des expressions comme +
'user_pref("<clé>", "<valeur>") +
pref("<clé>", "<valeur>") +
lock_pref("<clé>", "<valeur>")' +
Chacun d'entre eux, en fait, tout appel de fonction (javascript) de la forme +
'functionname (chaîne1, chaîne2)' +
peut être patché avec cette commande en définissant la chaîne appropriée pour <type de préférence> (qui est, respectivement pour functionname),
Si une entrée commençant par "functionname (chaîne1) existe dans le fichier traité, il sera patché (et laissé à sa place). Sinon une nouvelle ligne sera ajoutée.
Exceptionnellement dans '{opsi-winst}', toutes les chaînes sont sensibles à la casse.

* `Set_Netscape_User_Pref` ("<preference variable>", "<valeur>") +
fixe la ligne du fichier de préférences de l'utilisateur spécifié pour la variable <preference variable> à la valeur <valeur>. L'ordre ASCII du fichier sera reconstruit. +
(Obsolète!)

* `AddStringListElement_To_Mozilla_Pref ("<type de préférence>", "<preference variable>", "<valeur à ajoutér>")` +
ajoute un élément à une entrée de liste dans le fichier de préférence donné. Il est vérifié si la valeur qui devrait être ajouté est déjà contenue dans la liste (alors il ne sera pas ajouté). 

* `AddStringListElement_To_Netscape_User_Pref ("<preference variable>", "<valeur à ajoutér dans la liste>")` +
 (Obsolète!)
 
Les autres commandes d'une section 'PatchTextFile' ne sont pas de type de fichier spécifique. Toutes les opérations sont basées sur le concept que un pointeur de ligne existe et peut être déplacé du début du fichier par exemple dessus de la ligne du haut vers le bas (ligne).

Il y a trois commandes pour effectuer des recherches:

* `FindLine <chaîne de recherche>`
* `FindLine_StartingWith <chaîne de recherche>`
* `FindLine_Containing <chaîne de recherche>`

Chaque commande commence à chercher à la position courante du pointeur de la ligne. S'ils trouvent une ligne correspondant, le pointeur de la ligne il est déplacé vers. Sinon, le pointeur de la ligne conserve sa position. 

<chaîne de recherche> - comme toutes les autres références de chaîne dans les commandes suivantes - elles sont entourée par des guillemets simples ou doubles.

* `GoToTop` +
déplacer le pointeur à la ligne du sommet.

(quand nous comptons les lignes il faut noter que cette commande déplace le pointeur de la ligne dessus de la ligne supérieure).
We step any - positive or negative - number of lines through the file by

* `AdvanceLine [nombre de lignes]` +
déplacer le pointeur de ligne à [nombre de lignes] lignes en avant ou en arrière.

* `GoToBottom` +
Avance jusqu'à la dernière ligne

Avec la commande suivante :

* `DeleteTheLine` +
nous supprimons la ligne à laquelle le pointeur de ligne est dirigé, s'il y a une telle ligne (si le pointeur de ligne est au sommet, rien n'est supprimé)

* `DeleteAllLines_StartingWith <chaîne de recherche>` +
supprimer toutes les lignes qui commencent par <chaîne de recherche>

* `AddLine <ligne>` ou `Add_Line <ligne>` +
La ligne est ajouté au fichier.

* `InsertLine <ligne>` ou `Insert_Line <ligne>` +
<ligne> est inséré à la position du pointeur de la ligne.

* `AppendLine <ligne>`ou `Append_Line <ligne>` +
<ligne> est ajoutée après la ligne à laquelle le pointeur est dirigé.

* `Append_File <nom de fichier>` +
lit le fichier et ajoute ses lignes dans le fichier édité.

* `Subtract_File <nom de fichier>` +
supprime les lignes du début du fichier édité, tant qu'elles sont identiques, avec les lignes du fichier <nom de fichier>.

* `SaveToFile <nom de fichier>` +
écrit les lignes éditées dans un fichier <nom de fichier>.

* `Sorted` +
entraîne que les lignes édités sont ordonnée (ASCII).

[[opsi-winst-patchtextfile-examples]]
==== Exemples

Pour plus d'exemples, regardez le paquet standard OPSI 'opsi-winst-test' et dans ce produit la partie '$Flag_winst_patch_text_file$ = "on"'

[[opsi-winst-linkfolder]]
=== Sections LinkFolder

Dans une section LinkFolder sont gérés les entrées du menu démarrage ainsi que les liens du bureau. 

Par exemple la section suivante crée un dossier nommé "acrobat“ dans le menu démarrer commune (partagé par tous les utilisateurs):
[source,winst]
----
[LinkFolder_Acrobat]
set_basefolder common_programs

set_subfolder "acrobat"
set_link 
  name: Acrobat Reader 
  target: C:\Programme\adobe\Acrobat\reader\acrord32.exe
  parameters: 
  working_dir: C:\Programme\adobe\Acrobat\reader
  icon_file: 
  icon_index:
end_link
----

Comme on peut le voir dans l'exemple, dans une section LinkFolder la première chose à définir est le dossier système virtuel sur lequel les déclarations suivantes doivent fonctionner: +
`set_basefolder` '<dossier système>'

Les dossiers système virtuel prédéfinis qui peuvent être utilisés sont: 

'desktop, sendto, startmenu, startup, programs, desktopdirectory, common_startmenu, common_programs, common_startup, common_desktopdirectory'

Les dossiers sont 'virtuels' depuis que le système d'exploitation (entrées de registre) détermine les endroits réels d'eux dans le système de fichiers. 
Deuxième, nous devons ouvrir un sous-dossier du dossier virtuel sélectionné: +
`set_subfolder` <chemin du dossier> +
Le nom du sous-dossier doit être interprété comme un nom de chemin avec le dossier système virtuel sélectionnée en tant que racine. Certain lien sont directement placés dans le dossier système que nous avons à rédiger +
`set_subfolder ""`

Dans la troisième étape, nous pouvons commencer à mettre des liens. La commande est une expression à plusieurs lignes commençant par +
`set_link` +
et finissant par 
`end_link.`

Entre ces lignes les paramètres du lien sont définis dans le format suivant:


`set_link` +
  `name:` [nom du lien] +
  `target:` <chemin complet du programme> +
  `parameters:` [paramètres de ligne de commande du programme] +
  `working_dir`: [répertoire de travail] +
  `icon_file:` [Chemin du fichier icône] +
  `icon_index:` [position de l'icône dans le fichier de l'icône] +
`end_link` 

Le nom 'target' est la seule entrée essentielle. Les autres entrées ont des valeurs par défaut:

* `name` valeur par défaut est le nom du programme.
* `parameters`valeur par défaut est une chaîne vide.
* `icon_file` par défaut à 'target'.
* `icon_index` par défaut est 0.

CAUTION: Si la cible ne se trouve pas référencé sur un partage monté au moment de la création d'un lien, windows raccourcit son nom au format 8.3. +
Solution: +
Créer un lien correct lorsque le partage est connecté. +
Copiez le fichier de lien prêt à un endroit qui existe à l'exécution du script. +
Que ce dossier soit la cible.

* `delete_element` <Nom du lien> +
supprimer un lien à partir du dossier ouvert. 

* `delete_subfolder` <Folderpath> +
le dossier est supprimé depuis le dossier virtuel de base

[[opsi-winst-linkfolder-examples]]
==== Exemples

[source,winst]
----
set $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
for $var$ in $list2$ do LinkFolder_Dummy

[LinkFolder_Dummy]
set_basefolder $var$
set_subfolder "Dummy"
set_link
	name: Dummy
	target: C:\Programme\PuTTY\putty.exe
	parameters:
	working_dir: C:\Programme\PuTTY
	icon_file:
	icon_index:
end_link
----

entraîne le journal système suivant:
[source,winst]
----
Set  $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
    retrieving strings from createStringList [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        
    retrieving strings from $list2$ [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        

~~~~~~ Looping through:  'common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory'
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTMENU folder
    Created "Dummy" in the COMMON STARTMENU folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON PROGRAMS folder
    Created "Dummy" in the COMMON PROGRAMS folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTUP folder
    Created "Dummy" in the COMMON STARTUP folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON DESKTOPDIRECTORY folder
    Created "Dummy" in the COMMON DESKTOPDIRECTORY folder
      ShellLink "Dummy" created

~~~~~~ End Loop
----

Pour plus d'exemples, vérifiez le paquet standard OPSI 'opsi-winst-test' et dans ce produit la partie '$Flag_winst_link_folder$ = "on"'.

[[opsi-winst-xmlpatch]]
=== Sections XMLPatch

Aujourd'hui, le moyen le plus populaire pour conserver les données de configuration,ou les données elles memes, est un fichier en format de document XML. Sa syntaxe suit les conventions telles que définies dans les spécifications XML (ou "Extended Markup Language") (http://www.w3.org/TR/xml/).

'{opsi-winst}' offre les sections XMLPatch pour l'édition de documents XML. 

Avec les actions définies pour ce type de section '{opsi-winst}' peut: 

* 'choisir' (et éventuellement créer) des ensembles d'éléments d'un document XML suivant un chemin de description
* 'patcher' tous les éléments d'un ensemble d'éléments sélectionnés
* 'retourner' le nom et/ou les attributs des éléments sélectionnés dans la section d'appel

[[opsi-winst-xmlpatch-params]]
==== Paramètre

Lors de l'appel d'une section XMLPatch le nom de chemin du document est donné comme paramètre, par exemple +
`XMLPatch_mozilla_mimetypes $mozillaprofilepath$ + "\mimetypes.rdf"`

[[opsi-winst-xmlpatch-xmldoc]]
==== Structure d'un Document XML

Un document XML décrit logiquement un "arbre" qui départ d'une "racine" - donc nommé document root– et se développe dans les branches. Chaque branche est étiquetée comme un noeud. Le sous-noeuds de certains noeuds sont appelés les enfants ou noeuds enfants de leur noeud parent.

Dans XML, l'arbre est construit à partir des éléments. Le début de toute description de l'élément est marqué par une balise (comme dans le HTML) à savoir un morceau de texte spécifiques qui est fixé dans une paire de crochets ("<“ ">“). La fin de la description de l'élément est définie par la même balise mais maintenant avec les crochets "</“ et „>“. Si un élément n'a aucun élément subordonné alors il n'y a pas d'espace nécessaire entre la balise de début et la balise de fin. Dans ce cas, les deux balises peuvent être combinées dans une avec le crochet de fin "/>“.

Ce schéma montre un simple arbre à "V", juste un branchement au niveau de la racine, pivoté de sorte que la racine est le sommet:  
~~~~
    |     noeud racine (level 0)
   / \    noeud 1 et noeud 2 les deux au niveau 1  
  .   .   implicitement les noeuds d'extrémité en dessous du niveau 1
~~~~
Cet arbre peut être décrit en XML de la façon suivante:
[source,xml]
----
<?xml version="1.0"?>
<root>
    <node_level_1_no_1>
    </node_level_1_no_1>
    <node_level_1_no_2>
    </node_level_1_no_2>
</root>
----
La première ligne doit déclarer la version XML utilisée. Le reste des lignes décrivent l'arbre.

Tant la structure semble être simple. Mais encore, nous avons seulement des "nodes principaux" définissant chacun un élément de l'arbre et marqués par une paire de balises. Mais chaque noeud principal peut avoir plusieurs types de sous-noeuds.

Bien sûr, un élément peut avoir des éléments subordonnés, par exemple nous pouvons avoir sous-noeuds de A à C du noeud 1:
[source,xml]
----
<node_level_1_no_1>
    <node_level_2_A>
    </node_level_2_A>
    <node_level_2_B>
    </node_level_2_B>
    <node_level_2_C>
    </node_level_2_c>
</node_level_1_no_1>
----
S'il n'y a pas d'éléments subordonnés un élément peut avoir un texte subordonnés. Alors on dit que l'élément a un noeud de texte subordonnés. Exemple
[source,xml]
----
<node_level_1_no_2>hello world
</node_level_1_no_2>
----
Un saut de ligne placé dans le noeud texte est maintenant interprétée comme une partie du texte là où autrement il est seulement un moyen d'afficher la structure XML. Pour éviter un saut de ligne dans "hello world" nous devons rédiger
[source,xml]
----
<node_level_1_no_2>hello world</node_level_1_no_2>
----
Chaque élément (peu importe s'il a des éléments subordonnés ou texte subordonnés) est constitué comme un noeud principal avec des balises spécifiques. Il peut encore être précisée par des attributs, dits noeuds d'attributs. Par exemple, il peut y avoir des attributs "colour" ou "angle" qui distinguent les différents nœuds du niveau 1.
[source,xml]
----
<node_level_1_no_1 colour="green" angle="65"
</node_level_1_no_1>
----
Pour sélectionner un ensemble d'éléments tout type d'information peut être utilisée:

. le niveau de l'élément,

. les noms des éléments qui sont traversés lors de la descente de l'arbre (le "chemin XML"),

. les noms et les valeurs des attributs utilisés,

. l'ordre des attributs,

. l'ordre des éléments,

. d'autres relations des éléments,

. le contenu textuel des éléments (resp. leurs noeuds de texte subordonnés).

Dans '{opsi-winst}', la sélection basée sur des critères (1) à (3) et (7) est mis en oeuvre

[[opsi-winst-xmlpatch-search-options]]
==== Options pour la sélection d'un ensemble d'éléments


Avant toute opération sur le contenu d'un fichier XML l'ensemble précis d'éléments sur lequel il sera opéré doit être déterminée. L'ensemble est construit étape par étape en définissant les chemins autorisés dans l'arborescence XML. Enfin, les points d'extrémité restants, des chemins, définissent l'ensemble sélectionné.

La commande '{opsi-winst}' basique est:

* `OpenNodeSet`

Il y a deux formats pour définir les chemins permis: un court et un long format.

.syntaxe explicite

La syntaxe plus explicite peut être vu dans l'exemple suivant (pour un exemple plus complexe <<opsi-winst-cookbook-patchxml>>):
[source,winst]
----
openNodeSet
  documentroot
  all_childelements_with:
   elementname:"define"
  all_childelements_with:
    elementname:"handler"
    attribute: extension value="doc"
  all_childelements_with:
    elementname:"application"
end
----

.syntaxe courte

Le même ensemble de nœuds est donnée par la ligne:
[source,winst]
----
openNodeSet 'define /handler value="doc"/application /'
----

Dans cette syntaxe, la barre oblique sépare les étapes dans la structure de l'arbre qui sont désignés dans la syntaxe plus explicite chacun par une propre description.

.Sélection par le contenu textuel (seulement pour syntaxe explicite)

Étant donné la syntaxe explicite nous pouvons sélectionner des éléments par le contenu textuel des éléments:
[source,winst]
----
openNodeSet

  documentroot
  all_childelements_with:
  all_childelements_with:
    elementname:"description"
    attribute:“type“ value=“browser“
    attribute:“name“ value=“mozilla“
  all_childelements_with:
    elementname:"linkurl"
    text:"http://www.mozilla.org"
end
----

.Paramétrage de la Stratégie de recherche

Dans les descriptions traversals des exemples de l'arbre XML il reste plusieurs questions.

* Un élément sera acceptée si le nom de l'élément et les attributs énumérés correspondent mais d'autres attributs existent?

* Is the search meant to give one single result value, that is should the resulting element set have no more than one element (et autrement, le fichier XML est à considérer comme erronée)?

* Inversement, is it meant that a traversal shall at any rate lead to some result, à savoir avons-nous à créer l'élément si aucun élément correspondant existe?

Pour répondre à ces questions explicitement il y a des paramètres pour la commande OpenNodeSet. Les lignes suivantes montrent les paramètres par défaut qui peuvent être variées en changeant les valeurs booléennes:
[source,winst]
----
  - error_when_no_node_existing false
  - warning_when_no_node_existing true
  - error_when_nodecount_greater_1 false
  - warning_when_nodecount_greater_1 false
  - create_when_node_not_existing false
  - attributes_strict false
----

Avec la syntaxe courte, le paramétrage précède la commande OpenNodeSet et tient pour tous les niveaux de l'arborescence XML. Avec la syntaxe explicite les paramètres peuvent être réglés directement après la commande OpenNodeSet ou être nouvellement créé pour chaque niveau. En particulier l'option „create when node not existing“ peut être établie pour certains niveaux, mais pas pour tous.

[[opsi-winst-xmlpatch-actions]]
==== Actions Patch

Il existe un ensemble de commandes qui opèrent sur ​​un ensemble d'éléments sélectionnés

* pour le réglage et la suppression des attributs

* pour enlever les éléments

* pour les réglages du texte.

En détail:

* `SetAttribute` "nom de l'attribut" value="valeur de l'attribut" +
Définit l'attribut spécifié pour chaque élément dans le jeu ouvert à la valeur spécifiée. Si l'attribut n'existe pas, il sera créé. + 
Exemple: 
`SetAttribute "name" value="OpenOffice Writer"`

Au contraire, la commande +

* `AddAttribute` "nom de l'attribut" value="valeur de l'attribut" +
définit l'attribut spécifié uniquement à la valeur spécifiée si elle n'existe pas à l'avance. Un attribut existant conserve sa valeur. Par exemple la commande +
`AddAttribute "name" value="OpenOffice Writer"` +
n'écrase pas la valeur s'il y avait nommé un autre programme avant.

Avec +
* `DeleteAttribute` "nom de l'attribut" +
nous enlevons l'attribut spécifié de chaque élément de l'ensemble des éléments sélectionnés.

La commande +
* `DeleteElement` "nom de l'élément" +
supprime tous les éléments avec le nom de noeud principal (nom de la balise) nom de l'élément de l'ensemble des éléments ouverts. 

Enfin, il existe deux commandes pour le réglage voir ajouter des noeuds de texte.:

* `SetText` "Texte"

et

* `AddText` "Texte"

Exemple +
`SetText "rtf"` +
transforme l'élément +
'<fileExtensions>doc<fileExtensions>' +
en +
'<fileExtensions>rtf<fileExtensions>'

Avec +
`SetText ""` +
nous enlevons le noeuds texte complètement.

La variante +
`AddText "rtf"` +
définit le texte que s'il n'y a pas de noeud texte donné. 

[[opsi-winst-xmlpatch-return]]
==== Retour des listes, pour l'appelant

Une section XMLPatch peut retourner les informations récupérées à la section primaire appelante. Le résultat est toujours une liste de chaînes, et pour l'obtenir, l'appel doit se faire via la fonction de liste de chaînes `getReturnListFromSection`. Par exemple nous pouvons avoir le réglage de listes de chaînes suivant dans une section Actions quand nous utilisons une section XMLPatch_mime

[source,winst]
----
DefStringList $list1$
set $list1$=getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----

Dans la section XMLPatch nous avons des commandes `return` qui déterminent le contenu de la liste de chaînes retourné:

* `return elements`+ 
remplit complètement les éléments sélectionnés (nom de l'élément et les attributs) dans la liste de retour.

* `return attributes` + 
produit une liste des attributs.

* `return elementnames` + 
produit une liste de noms d'élément.

* `return attributenames`
donne une liste seulement des noms d'attributs.

* `return text` +
Liste tout le contenu textuel des éléments sélectionnés.

* `return counting` +
donne un rapport avec des informations numériques: la ligne 0 contient le nombre d'éléments sélectionnés, la ligne 1 le nombre d'attributs.

[[opsi-winst-xmlpatch-examples]]
==== Exemples

Pour d'autres exemples voir le produit 'opsi-winst-test'
en particulier le secteur avec '$Flag_winst_xml$ = "on"'


[[opsi-winst-progman]]
=== Sections ProgmanGroups

Ce type de section type est obsolete.

[[opsi-winst-winbatch]]
=== Sections WinBatch

Dans une section WinBatch n'importe quel exécutable Windows peut être lancé. +
Par exemple, nous pouvons démarrer certains programmes d'installation existants par les lignes suivantes dans une section WinBatch +
[source,winst]
----
[winbatch_install]
"%scriptpath%\setup.exe"
----

Il est obsolète mais toujours en charge que vous pouvez appeler – à partir de l'explorateur Windows – un fichier de n'importe quel type pour lequel un programme est enregistré.


[[opsi-winst-winbatch-params]]
==== Paramètre d'appel (Modificateur)

Il y a plusieurs paramètres de l'appel WinBatch qui déterminent si (ou combien de temps) '{opsi-winst}' doit attendre le retour pour les programmes lancés.

* `/WaitOnClose` +
Est le défaut +
'{opsi-winst}' attend le retour de tous les processus initié. 

* `/LetThemGo` +
C'est le contraire de `/WaitOnClose`. Il est utilisé si '{opsi-winst}' doit procéder tandis que les processus débutés s'exécutent dans leur propres threads.


* `/WaitSeconds` [nombre de secondes] +

Si nous appelons avec le paramètre /WaitSeconds [nombre de secondes] '{opsi-winst}' attend le temps spécifié avant de procéder. Dans la configuration par défaut on doit attendre le retour des programmes. Si nous combinons le paramètre avec l'option `/LetThemGo` puis '{opsi-winst}' continue le traitement quand le temps d'attente est terminée.

* `/WaitForWindowAppearing` [titre de la fenêtre] +
voir +
`/WaitForWindowVanish` [titre de la fenêtre] +
Les deux sont obsolètes. Utilisez `/WaitForProcessEnding` +

La première option signifie que '{opsi-winst}' attend jusqu'à ce que tout processus permet de faire apparaître une fenêtre avec titre de la fenêtre. Avec la deuxième option '{opsi-winst}' est en attente aussi longtemps qu'une certaine fenêtre (1) apparu sur le bureau (2) soit disparu. +
CAUTION: Ces options ne connais que des fenêtres de programms 32-bit 
 
* `/WaitForProcessEnding` <nom du programme> +
Attend la fin du processus avec le nom <nom du programme>. +
Devraient être combinées avec des `/TimeOutSeconds`.

* `/TimeOutSeconds` <secondes> +
Un paramètre de temporisation. Après <secondes> le processus sera annulé . +
Ne peut être utilisé sans une condition d'attente (par exemple `/WaitForProcessEnding`) +
Exemple: +
[source,winst]
----
Winbatch_uninstall /WaitForProcessEnding "uninstall.exe" /TimeOutSeconds 20
[Winbatch_uninstall]
"%ScriptPath%\uninstall_starter.exe"
----

* `getLastExitCode` +
La fonction de chaîne getLastExitCode donne accès au ExitCode (code de sortie) – ou ErrorLevel – de l'appel du dernier processus dans la section précédente WinBatch.

[[opsi-winst-winbatch-examples]]
==== Exemples

Pour d'autres exemples voir le paquet 'opsi-winst-test'
en particulier le secteur avec '$Flag_winst_winbatch$ = "on"'

[[opsi-winst-dosbatch]]
=== Sections DOSBatch/DosInAnIcon (ShellBatch/ShellInAnIcon)

Par le biais de sections DOSBatch (aussi appelé ShellBatch) un script '{opsi-winst}' utilise les scripts shell de Windows pour des tâches qui ne peuvent pas être remplies par des commandes internes ou pour lesquels déjà une solution de script batch existe.

'{opsi-winst}' attend que DOS-batch se termine, avant qu'il procède à la section de script suivante.  
 
Une section DOSBatch est tout simplement traitée en écrivant les lignes des sections dans le fichier _winst.bat dans c:\tmp et puis en appelant ce fichier dans le contexte du shellcmd.exe . Ce qui explique que une section DosBatch peut contenir toutes les commandes shell Windows peuvant être utilisés. 


Comparé à l'appel d'une cmd-file dans une section WinBatch, la section DOSBatch 
présente certains avantages: +

* '{opsi-winst}' variables ou constantes dans la section peuvent être facilement utilisés car ils seront remplacés avant l'exécution. 

* La sortie des scripts est écrite dans le fichier de log.

* La sortie de la commande shell peut être capturé en utilisant la fonction de liste de chaînes.

Le type de section 'DOSInAnIcon' ou 'ShellInAnIcon' est identique à 'DOSBatch' concernant la syntaxe et la méthode d'exécution mais elle a une apparence différente: +
Pour 'DOSInAnIcon', un processus shell est créé avec la vue mis à minimisé. Cela a pour conséquence qu'il est exécuté "dans une icône". Aucune fenêtre de commande apparaît, l'interaction avec l'utilisateur est supprimée.

CAUTION: Ne pas utiliser les commandes qui attendent l'interaction de l'utilisateur.

[[opsi-winst-dosbatch-params]]
==== Paramètre

Il y a deux sortes de paramètres qui peuvent être transmis en appelant la section:

* Les paramètres qui sont directement passés au fichier batch appelé.

* Paramètres qui modifient la façon dont '{opsi-winst}' s'occupera de la section.

La syntaxe d'appel est:

+Sektionsname [paramètres batch] [winst [modificateur]]+

Le modificateur de '{opsi-winst}' possibles sont (depuis 4.11.1):

* `/32bit`

* `/64bit`

* `/Sysnative`

Ces modificateurs '{opsi-winst}' doivent être séparés des autres paramètres par le mot-clé `winst`.

D'autres paramètres d'une section DosBatch sont directement transmis en tant que quasi paramètres en ligne de commande au script shell Windows. +
Par exemple on peut appeler DosBatch_1 dans la section Actions pour obtenir un "Hello World" à partir de la commande DOS echo:
[source,winst]
----
[Actions]
DosBatch_1 today we say "Hello World" 

[DosBatch_1]
@echo off
echo %1 %2 %3 %4
pause
----

l'exécution de la commande Dos-Batch echo avec les paramètres 'today we say "Hello World"'.

L'exemple suivant sera sur un système 64 bits exécuté dans un cmd.exe 64 bits et donnant la sortie 'today we say':
[source,winst]
----
[Actions]
DosBatch_1 today we say winst /64bit

[DosBatch_1]
@echo off
echo %1 %2 %3 %4
pause
----

[[opsi-winst-dosbatch-catchout]]
==== Capturer la sortie

La sortie des commandes shell peut être capturé en utilisant la fonction liste de chaînes `getOutStreamFromSection()` à partir des scripts '{opsi-winst}' de section principale
voir aussi: +
<<opsi-winst-stringlist-getstring>>). 

Si la liste de retour doit être évaluée avec un programme il est conseillé d'utiliser le préfixe de commandes '@'. Si faisant nous supprimons la répétition de la ligne de commande dans la sortie qui peut être de différents formats dépendant des configurations système. 

[[opsi-winst-dosbatch-examples]]
==== Exemples

Pour d'autres exemples voir le produit 'opsi-winst-test'
en particulier le secteur avec '$Flag_winst_dos$ = "on"'

[[opsi-winst-registry]]
=== Sections Registry

Par un appel section Registry, nous pouvons créer, patcher et supprimer des entrées dans le Registre Windows. Comme d'habitude, '{opsi-winst}' enregistre toutes les opérations en détail aussi longtemps que l'enregistrement n'est pas désactivé. 

[[opsi-winst-registry-examples]]
==== Exemples

Laissez-nous définir certaines variables de registre par un appel à la section Registry_TestPatch où la section est donnée par
[source,winst]
----
[Registry_TestPatch]
openkey [HKEY_Current_User\Environment\Test]
set "Testvar1" = "c:\rutils;%Systemroot%\hey" 
set "Testvar2" = REG_DWORD:0001
----

Pour d'autres exemples voir le produit 'opsi-winst-test'
en particulier le secteur avec '$Flag_subregistry$ = "on"'

[[opsi-winst-registry-params]]
==== Paramètres d'appel

* L'appel standard d'une section registry n'a pas de paramètres. Cela est suffisant tant que les opérations visent à la base de registre standard d'un système Windows et toutes les entrées peuvent être définies en utilisant un chemin de registre globalement défini.

* `/AllNTUserDats` +
'{opsi-winst}' propose également que les commandes de patch d'une section Registry sont automatiquement exécutées "pour tous les utilisateurs" qui sont définis localement. À savoir que les patchs sont faites pour toutes les branches utilisateur du Registre local. Cette interprétation de la section est évoqué par le paramètre `/AllNTUserDats`

En outre les paramètres de contrôle de la section Registry qui varient syntaxiquement sont valable:

* `/regedit` +
Le paramètre `/regedit` déclare que la syntaxe correspond à la syntaxe du fichier d'exportation de l'éditeur de registre Windows regedit. Aussi, les lignes d'un fichier d'exportation regedit peuvent directement être utilisée comme Registry voir le fichier lui-même peut servir comme une section externe (voir <<opsi-winst-registry-regedit>>).

* `/addReg` +
De même, Le paramètre `/addReg` déclare que la syntaxe de la section Registry est celle d'un fichier inf (utilisé par exemple pour les installations de pilotes)
(voir <<opsi-winst-registry-addreg>>).

Ces variantes syntaxiques pas spécifique de '{opsi-winst}' ne sont pas définies dans ce manuel car ils seront généralement généré par programme.

Il y a aussi les options:

* `/32Bit` +
* `/64Bit` +
* `/SysNative` +

qui manipulent les 'redirections en écriture de registre' sur les systèmes 64 bits. (voir <<opsi-winst-64bit>>).

[[opsi-winst-registry-commands]]
==== Commandes

La syntaxe par défaut d'une section Registry est orienté à la syntaxe de commande d'autres opérations de patch dans '{opsi-winst}'.

Ils existent les commandes suivantes:

* `OpenKey`

* `Set`

* `Add`

* `Supp`

* `GetMultiSZFromFile`

* `SaveValueToFile`

* `DeleteVar`

* `DeleteKey`

* `ReconstructFrom`

* `Flushkey`


En détail:

* `OpenKey` <clé de registre> +
ouvre la clé spécifiée pour la lecture et (si l'utilisateur a les privilèges nécessaires) pour l'écriture. Si la clé n'existe pas elle sera créée.

La clé de registre est désignée par un nom de chemin de registre. Dans des circonstances ordinaires il commence avec l'un des "high keys" qui construisent le plus haut niveau de l'arbre de structure de données du registre (au-dessus du "root" ). Ce sont:
'HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CURRENT_CONFIG' qui peuvent éventuellement être écrite comme 'HKCR, HKCU, HKLM, HKU'. 

Dans la syntaxe '{opsi-winst}' du nom du chemin du registre, les éléments d'un chemin sont séparées par seul backslashs.

Toutes les autres commandes fonctionnent sur ​​une clé de registre ouverte.

* `Set` <nom de la variable> = <valeur> +
définit la variable de registre <nom de la variable> à la valeur <valeur>.
<nom de la variable> ainsi que <valeur> sont des chaînes et doivent être contenue entre guillemets. Une variable non existante sera créé. 
La variable vide "" indique l'entrée standard d'une clé de registre.

Si certaines variables de registre doivent être créé ou definie qui n'ont pas le type par défaut Registry-String (REG_SZ) nous devons utiliser la variante étendue de la commande `Set`:

* `Set` <nom de la variable> = <type de registre>:<valeur> + 
définit la variable de registre <nom de la variable> à la valeur <valeur> du type <registry type>. Les types de registre suivantes sont disponibles:

'REG_SZ'::: (chaîne)

'REG_EXPAND_SZ'::: (une chaîne contenant une sous-chaîne que le système d'exploitation doit élargir, par exemple)

'REG_DWORD'::: (des valeurs entières)

'REG_BINARY'::: (valeurs binaires habituellement donné en deux chiffres nombres hexadécimaux 00 01 02 .. 0F 10)

'REG_MULTI_SZ'::: (matrices valeur de chaîne, dans '{opsi-winst}' nous devons utiliser "|" comme séparateur) +
Un exemple pour definir un REG_MULTI_SZ: +
[source,winst]
----
set "myVariable" = REG_MULTI_SZ:"A|BC|de"
----

Pour construire une multi-chaîne nous pouvons mettre les chaînes comme des lignes dans un fichier et le lire à l'aide de `GetMultiSZFromFile` (voir plus bas). 

* `Add` <nom de la variable> = <valeur>
+
voir
+
`Add` <nom de la variable> = <type de registre> <valeur> +
sont analogues aux commandes `Set` avec la différence que les entrées sont uniquement ajoutées mais les valeurs des variables existantes ne change pas.

* `Supp` <nom de la variable> <liste de séparateur> <supplément> +
Cette commande interprète la valeur de la chaîne de variable <nom de la variable>, une liste de valeurs séparées par <liste de séparateur> et ajoute la chaîne <supplément> à cette liste (si elle n'est pas déjà contenue). Si <supplément> contient le <liste de séparateur> il est divisé en chaînes simples, et la procédure est appliquée à chaque chaîne. +
Une utilisation typique est l'ajout d'entrées à une variable de chemin (qui est définie dans le Registre). +
`Supp` conserve la variante de la chaîne originale (REG_EXPAND_SZ ou REG_SZ). +

Exemple: +
Le chemin d'environnement est déterminé par la valeur pour la variable Path tel que définie à l'intérieur la clé de registre
+
'KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environment'
+
Pour ajouter des entrées à la définition du chemin nous devons avoir accès à cette clé par un OpenKey. Ensuite, nous pouvons appliquer par exemple
+
`supp "Path" ; "C:\utils;%JAVABIN%"`
+
afin de compléter le chemin avec '"C:\utils"' et '"%JAVABIN%"'.
+
(Windows élargit %JAVABIN% vers le nom de chemin correct si %JAVABIN% existe en tant que variable et la chaîne est une REG_EXPAND_SZ.)
+
Ayant lu l'ancienne valeur de chemin de la variable d'environnement, écrit cette valeur à la valeur de registre - et sont alors capables de travailler avec la variable de registre:
+
[source,winst]
----
[Actions] 
DefVar $Path$ 
set $Path$ = EnvVar ("Path") 
Registry_PathPatch 

[Registry_PathPatch] 
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\control\Session Manager\Environment] 
set "Path"="$Path$" 
supp "Path"; "c:\orawin\bin"
----
+
CAUTION: La variable d'environnement obtient une valeur modifiée après un redémarrage.

* `GetMultiSZFromFile` <nom de la variable> <nom de fichier> +
lit les lignes d'un fichier et les met ensemble pour la construction d'une multi-chaîne.

* `SaveValueToFile` <nom de la variable> <nom de fichier> +
exportation de la valeur visée (chaîne ou multi-chaîne) comme fichier <nom de fichier> lignes (chaque chaîne, formant une ligne).

* `DeleteVar` <nom de la variable> +
supprime l'entrée avec la variable <nom de la variable> de la clé ouverte.

* `DeleteKey` <clé de Registre> +
supprime la clé de registre de façon récursive y compris tous les sous-clés et variables contenues. La clé de registre est défini comme pour OpenKey.
+
Exemple:
+
[source,winst]
----
[Registry_Keydel]
deletekey [HKCU\Environment\subkey1]
----

* `ReconstructFrom` <nom de fichier> +
(obsolète)

* `FlushKey` +
garantit que toutes les entrées d'une clé sont sauvegardés sur le disque dur, non seulement dans la mémoire (se fait automatiquement lors de la fermeture d'une clé, donc en particulier quand une section de registre est quitté).


[[opsi-winst-registry-allntuser]]
==== Sections Registry pour Patcher 'All NTUser.dat'

Une section Registry appelé avec le paramètre `/AllNTUserdats` est exécuté pour chaque utilisateur local.

À cette fin, pour tous les utilisateurs locaux (le stockage permanent pour la branche de registre 'HKEY_Users') les fichiers 'NTUser.dat' sont recherchées, un par un et temporairement chargé dans une sous-clé de certaines branches du registre. Les commandes de la section de registre sont exécutés pour cette sous-clé, puis la sous-clé est déchargé. Comme résultat, la valeur stockée pour 'NTUser.dat' est modifiée. 

Le mécanisme ne fonctionne pas pour un utilisateur connecté. Son 'NTUser.dat' est déjà utilisé, et la requête de le charger produit une erreur. Pour faire les changements pour lui aussi, les commandes du registre en plus sont exécutées sur la branche 'HKEY_Users' pour l'utilisateur connecté.

Il y a un 'NTUser.dat' pour 'Default User' qui sert de modèle pour les utilisateurs à créer dans le futur. Par conséquent, les patchs sont préparés pour eux aussi.

La syntaxe de la section Registry reste inchangé. Mais les chemins des clés sont interprétés relativement. Cela signifie *ne pas toucher les clé principales*

Dans l'exemple suivant l'entrée de registre pour la variable 'FileTransferEnabled' est définie de facto pour tous les 'HKEY_Users\XX\Software...' successifs pour tous les XX (tous les utilisateurs) sur l'ordinateur:

[source,winst]
----
[Registry_AllUsers]
openkey [Software\ORL\WinVNC3]
set "FileTransferEnabled"=reg_dword:0x00000000
----

depuis la version 4.11.2 de '{opsi-winst}' vous pouvez donner la clé racine 'HKEY_CURRENT_USER' à la commande `openkey`. +
Exemple:
[source,winst]
----
[Registry_AllUsers]
openkey [HKEY_CURRENT_USER\Software\ORL\WinVNC3]
set "FileTransferEnabled"=reg_dword:0x00000000
----

Cela a les avantages suivants:

* La syntaxe est plus facile à comprendre.

* La même section du registre peut être utilisé avec '/AllNtuserdats' et dans un 'userLoginScript'

[[opsi-winst-registry-regedit]]
==== Sections Registry dans le format Regedit

Si la section Registry est appelée avec le paramètre `/regedit` la section n'est pas attendu dans le format standard '{opsi-winst}' mais dans le format produit par l'outil Windows regedit.
Les fichiers d'exportation générés par regedit ont - pas sur la ligne d'en tête - un format de fichier ini. Exemple:

[source,ini]
----
REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org]

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\general]
"bootmode"="BKSTD"
"windomain"=""
"opsiconf"=dword:00000001

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\shareinfo]
"user"="pcpatch"
"pcpatchpass"=""
"depoturl"="\\\\bonifax\\opt_pcbin\\install"
"configurl"="\\\\bonifax\\opt_pcbin\\pcpatch"
"utilsurl"="\\\\bonifax\\opt_pcbin\\utils"
"utilsdrive"="p:"
"configdrive"="p:"
"depotdrive"="p:"
----
Les sections dénotent des clés de registre à ouvrir. Chaque ligne décrit certains paramètres de variables comme la commande set dans une section registry de '{opsi-winst}'.

Mais, nous ne pouvons pas vraiment avoir une section interne '{opsi-winst}' qui est construite à partir d'une autre section. Par conséquent la section Registry avec le paramètre `/regedit` ne peut être donnée que comme section extérieure ou par l'appel de fonction loadTextFile, par exemple

[source,winst]
----
registry "%scriptpath%/opsiorgkey.reg" /regedit
----

Avec Windows XP l'éditeur de registre regedit ne produit pas le format Regedit4 mais un nouveau format qui est indiqué par la ligne d'en tête +
'"Windows Registry Editor Version 5.00"' +

Dans ce format, Windows offre certains types de valeur supplémentaires. Mais le plus important, le fichier d'exportation est désormais généré au format Unicode. Le traitement des sections '{opsi-winst}' est basé sur les bibliothèques Delphi qui utilisent des chaînes de 8 de bits. Pour travailler avec un fichier d'exportation regedit 5 le codage est donc convertie. Ceci peut être fait manuellement, par exemple par un éditeur approprié. Mais on peut aussi passer le fichier original à '{opsi-winst}' en utilisant la fonction de liste de chaînes `loadUnicodeTextFile`. Par exemple, si printerconnections.reg est une exportation basée unicode, nous pouvons appeler regedit dans la forme suivante ce qui fait la conversion de code nécessaire à la volée:

[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----
Un patch de registre utilisant le format regedit peut ainsi être exécutées "pour tous les utilisateurs NT" de la même façon que la section ordinaires '{opsi-winst}' registry . Un chemin comme 
'[HKEY_CURRENT_USER\Software\ORL]' est remplacé par le relatif '[Software\ORL].'


[[opsi-winst-registry-addreg]]
==== Registry Sections in AddReg Format

A Registry section can be called with parameter `/addReg`. Then its syntax follows the principles of the '[AddReg]' sections in inf files as used e.g. for driver installations.

E.g.: +
[source,ini]
----
[Registry_ForAcroread]
HKCR,".fdf","",0,"AcroExch.FDFDoc"
HKCR,".pdf","",0,"AcroExch.Document"HKCR,"PDF.PdfCtrl.1","",0,"Acr"
----

[[opsi-winst-opsiservicecall]]
=== OpsiServiceCall Sections


This type of section allows to retrieve information – or set data – via the opsi service. There are three options for determining a connection to an opsi service:

* Per default it is assumed that the script is executed in the standard opsi installation environment. I.e., we already have a connection to an opsi service and can use it.

* We set the url of the service to which we want to connect as a section parameter and supply as well the required username and password as section parameters.

* We demand an interactive login to the service (predefining only the service url and, optionally, the user name).

Retrieved data may be returned as a String list and then used for scripting purposes.

[[opsi-winst-opsiservicecall-params]]
==== Call Parameters

The call parameters determine which opsi service will be addressed and set the connection parameters if needed. 

Connection parameters can be defined via

* `/serviceurl` <url to the opsi web service>

* `/username` <web service user name>

* `/password` <web service user password>

If these parameters, at least the serviceurl, are given '{opsi-winst}' tries to open a connection to an opsi service which has the url.


The additional option 

* `/interactive` +

raises an interactive connect. The user will be asked for confirming the connection data and supplying the password. Of course, this option cannot be used in scripts which shall be executed fully automatically. 

If no connection parameters are supplied '{opsi-winst}' assumes that an existing connection shall be reused.

If no connection parameters are given and the interactive option is not specified (neither at this call nor at a call earlier in the script) it is assumed that we are in a standard opsi boot process and, already having a connection to an opsi service, we try to address it. 


* `/preloginservice` +
In the case that we had a connection to a secondary opsi service we may (re)set the connection to the standard opsi service via the option 


* `/opsiclientd` //depuis 4.11.2.1 +
calls the localhosts opsiclientd  

[[opsi-winst-opsiservicecall-syntax]]
==== Section Format

An `opsiServiceCall`, which uses an existing connection to an opsi-service, is defined by its method name and a list of parameters.

Both are defined in the section body. It has format +
[source,winst]
----
"method":<method name>
"params":[
	<params>
	]
----
'params' is a (possibly empty) list of strings (comma-seperated). Use the parameters as required by the specified method. 

E.g. we may have a section call where the required methodname and the (empty) list of parameters is set:

[source,winst]
----
[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

The section call produces the list of names (IDs) of all local opsi clients. 
If the list shall be exploited for other than test purposes the section call can be used in a string list expression:
E.g.: +
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")
----

The usage of `GetReturnListFromSection` is documented in the string list function chapter of this manual (see <<opsi-winst-stringlist-create-by-section>>).

A hash – in this case a string list, where each item is a pair name=value – is produced by the following opsi service call:

[source,winst]
----
[opsiservicecall_hostHash]
"method": "getHost_hash"
"params": [
	"pcbon8.uib.local"
	]
----

CAUTION: The sections opsiservicecall are developed for opsi 3.x methods. For opsi 4.x methods they are often not suitable. For example '*_getIdents' calls are possible, '*_getObjects' calls are not possible.  

[[opsi-winst-opsiservicecall-examples]]
==== Examples

For further examples watch the product 'opsi-winst-test' an there especially '$Flag_winst_opsiServiceCall$ = "on"'

[[opsi-winst-execpython]]
=== ExecPython Sections

'ExecPython' sections are basically Shell-Sections (like 'DosInAnIcon') which call the – on the system installed – python script interpreter. It takes the section content as python script, and the section call parameter as parameters for the script.

Example:

The following example demonstrates a execPython call with a list of parameters for that are printed by the python commands. 

The call may look like +
[source,winst]
----
execpython_hello -a "option a" -b "option b" "there we are"

[execpython_hello]
import sys
print "we are working in path: ", a
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"


print "hello"
----

The print command output will be caught and written to the log file. So we get in the log +
[source,winst]
----
output:
 --------------
-a
option a
-b
option b
there we are
       hello
----

Observe that the loglevel must be set at least to info (that is 1) if these outputs shall really find their way to the log file.

[[opsi-winst-execpython-combine]]
==== Interweaving a Python Script with the opsi-winst Script

An execPython section is integrated with the surrounding '{opsi-winst}' script by four kinds of shared data:

* A parameter list is transferred to the python script.

* Everything that is printed by the python script is written into the '{opsi-winst}' log.

* The '{opsi-winst}' script substitution mechanism for constants and variables when entering a section does its expected work for the execPython section.

* The output of an execPython section can be caught into a stringlist and then used in the ongoing '{opsi-winst}' script.

An example for the first two ways of interweaving the python script with the '{opsi-winst}' script is already given above. We extend it to retrieve the values of some '{opsi-winst}' constants or variables.

[source,winst]
----
[execpython_hello]
import sys
a = "%scriptpath%"
print "we are working in path: ", a
print "my host ID is ", "%hostID%"
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"

print "the current loglevel is ", "$loglevel$" 
print "hello"
----

Of course, the '$loglevel$' variable has to be set beforehand in the Actions section:
[source,winst]
----
DefVar $LogLevel$
set $loglevel$ = getLoglevel
----

Finally, in order to being able to use of some results of the section output, we produce it into a stringlist variable by calling the execPython section in the following way: +
[source,winst]
----
DefStringList pythonresult
Set pythonResult = GetOutStreamFromSection('execpython_hello -a "opt a“')
----

[[opsi-winst-execpython-examples]]
==== Examples

For further examples watch the product 'opsi-winst-test' and there especially 
'$Flag_compare_to_python$ = "on"'

[[opsi-winst-execwith]]
=== ExecWith Sections

'ExecWith' sections are more general than 'ExecPython' or 'DosBatch' sections: Which program interprets the section lines given is determined by a parameter of the section call.

E.g, if we have some call 

[source,winst]
----
execPython_hello -a "hello" -b "world"
----

where 

`-a "hello" -b "world"`

are parameters that are passed to the python script we get the following completely equivalent ExecWith call:

[source,winst]
----
execWith_hello "python" PASS -a "hello" -b "world" WINST /EscapeStrings
----

The option '/EscapeStrings' is automatically used in an ExecPython section and means that backslashes in String variables and constants are duplicated before interpretation by the the called program. 


==== Call Syntax

In general, we have the call syntax:
[source,winst]
----
ExecWith_SECTION PROGRAM PROGRAMPARAS pass PASSPARAS winst WINSTOPTS
----

Each of the expressions 'PROGRAM, PROGRAMPARAS, PASSPARAS, WINSTOPTS' may be an arbitrary String expression, or just a String constant (without citation marks). 

The key words PASS and WINST may be missing if the respective parts do not exist.

There are two '{opsi-winst}' options recognized:

* `/EscapeStrings`

* `/LetThemGo`

Like with ExecPython sections, the output of an ExecWith section may be captured into a String list via the function `getOutStreamFromSection`.

The first one declares that the backslash in '{opsi-winst}' variables and constants is C-like escaped. The second one has the effect (as for 'winBatch' calls) that the called program starts its work in new thread while '{opsi-winst}' is continuing to interpret its script.

[[opsi-winst-execwith-examples]]
==== More Examples

The following call is meant to refer to a section which is an autoit3 script that waits for some upcoming window (therefore the option /letThemGo is used) in order to close it:

[source,winst]
----
ExecWith_close "%SCRIPTPATH%\autoit3.exe" WINST /letThemGo 
----

A simple 
[source,winst]
----
ExecWith_edit_me "notepad.exe"  WINST /letThemGo
----

calls notepad and opens the section lines in it (but without any line that is starting with a semicolon since '{opsi-winst}' regards such lines as comments and eliminates them before handle).

For further examples watch the product 'opsi-winst-test' and there especially 
'$Flag_autoit3_test$ = "on"'

[[opsi-winst-ldapsearch]]
=== LDAPsearch Sections

A LDAPsearch section defines a search request to a LDAP directory, executes it and receives (and possibly caches) the response. 

Before dwelling on the '{opsi-winst}' commands we do some explanations.

In subsection we give an example of the most probable usage of a LDAPsearch.
The following subsections describe the syntax 

[[opsi-winst-ldapsearch-general]]
==== LDAP – Protocol, Service, Directory

LDAP, the "Lightweight Directory Access Protocol", is, as the name indicates, a defined way of communication to a directory. This directory is (or may be) hierarchically organized. That is, the directory is a hierarchical data base, or a tree of content. 

A *LDAP service* implements the protocol. A directory that can be accessed via a LDAP service is called a *LDAP directory*.

For instance, let's have a look at some part of the LDAP directory tree of an opsi server with LDAP backend (as shown by the Open Source tool JXplorer):

.View of some part of an opsi LDAP tree
image::../images/ldap-in-jxplorer.png["opsi LDAP tree",width=400]

A *LDAP search request* is a query to a LDAP directory via a LDAP service. The response returns some content from the directory.

Basically the search request has to describe the path in the directory tree which leads to the interesting piece of information. The path is the *distinguished name* (dn), composed of the names of the nodes (the "relative distinguished names"), which build the path, for instance:

'local/uib/opsi/generalConfigs/bonifax.uib.local'

Since each node is conceived as an instance of some structural object class, the path description is usually given in the following form: with indication of the classes (and starting with the last path element) :

'cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local'

The path in a query is not necessarily "complete", and not leading to a unique leaf of the tree. On the contrary, partial paths are common. 

But even if the path descends to a unique leaf, the leaf may contain several values. Each node of the tree has one or more classes as attribute types. To each one or may values may be associated. 

For a given query path, we therefore may be interested 

. in the node set whose elements – the so called LDAP objects – match the given path, 

. the set of attributes that belong the nodes,

. and the values that are associated to all of them.

Obviously, handling the amount of possibly returned response information is the main challenge when dealing with LDAP searches.

The following section shows the documentation of a LDAPsearch roughly corresponding to the screenshot above as executed by '{opsi-winst}'.

Example

Using the '{opsi-winst}' section `ldapsearch_generalConfigs`:
[source,winst]
----
[ldapsearch_generalConfigs] 
targethost: bonifax        
dn: cn=generalConfigs,cn=opsi,dc=uib,dc=local
----

we will get a answer like this:
[source,ini]
----
Result: 0
 Object: cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	generalConfigs
  Attribute: objectClass
	organizationalRole
Result: 1
  Object: cn=pcbon4.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	pcbon4.uib.local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: opsiKeyValuePair
	test2=test
	test=a b c d
Result: 2
  Object: cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: cn
	bonifax.uib.local
  Attribute: opsiKeyValuePair
	opsiclientsideconfigcaching=FALSE
	pcptchlabel1=opsi.org
	pcptchlabel2=uib gmbh
	button_stopnetworking=
	pcptchbitmap1=winst1.bmp
	pcptchbitmap2=winst2.bmp
	debug=on
	secsuntilconnectiontimeout=280
	opsiclientd.global.log_level=
----

There are several '{opsi-winst}' options to manage and reduce the complexity of the evaluation of such responses.

[[opsi-winst-ldapsearch-params]]
==== LDAPsearch Call Parameters

Two kinds of LDAPsearch parameters, 

* cache options
* output options

are defined for the call of LDAPsearch section.

The 'cache options' are:

* `/cache`

* `/cached`

* `/free`

* (no cache option)

If there is no cache option specified, the response of the LDAP search request is not saved for further usages.

By the `/cache` option, the response is cached for further evaluations, the `/cached` option refers to the last cached response which is reused instead of starting a new search, the `/free` option clears the cache explicitly (may only be useful for searches with extreme large responses).

The 'output options' are: 

* `/objects`

* `/attributes`

* `/values`

* (no output option)

The output options determine the String list that is produced when a LDAPsearch section is called via getReturnlistFromSection:

* If no output option is specified the returned list is the complete LDAP response.

* The options objects, attributes and values restrict the output to object, attribute or value lines of the LDAP response respectively. 

Observe that in the produced lists the object an attribute belongs to is only identifiable if only one object is returned in the object list, and likewise the object and the attribute to which a value is subsumed are only identifiable if there is only attribute remaining in the attributes list.

Such the proceeding is, that the LDAPsearch is specified up to that degree, that at most one object and one attribute is returned. This can be checked by a count call on the objects and the attributes return list. Then any value found belongs to the dn and the attribute specified. 

The repeated utilization of the same LDAP response can be done without relevant time costs by using the cache/cached options. 

[[opsi-winst-ldapsearch-narrow-search]]
==== How to Narrow the Search

An example may show how we can narrow the search to pin down a specific result from a LDAP directory.

We start with the call of 'ldapsearch_generalConfigs' as above, only adding the cache parameter.

`ldapsearch_generalconfigs /cache`

executes the query and caches the response for further utilization.

Then, the call

`getReturnlistFromSection("ldapsearch_generalconfigs /cached /objects")`

produces the list
[source,ini]
----
cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=pcbon4.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----
If we narrow the tree selection by 

[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
----
and start again, then in the objects list, we indeed retain just 
[source,ini]
----
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----

The corresponding attributes list contains three elements:
[source,ini]
----
objectclass
cn
opsikeyvaluepair
----
In order to get the values associated to a single attribute we have to confine the query once more:

[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
attribute: opsiKeyValuePair
----
The result now produced is an attributes list containing only one element. The corresponding values list looks like

[source,ini]
----
opsiclientsideconfigcaching=false
pcptchlabel1=opsi.org
pcptchlabel2=uib gmbh
button_stopnetworking=
pcptchbitmap1=winst1.bmp
pcptchbitmap2=winst2.bmp
debug=on
secsuntilconnectiontimeout=280
opsiclientd.global.log_level=6
----
There are no LDAP means to reduce this result furthermore!

(But the '{opsi-winst}' function `getValue (key, list)` (cf. <<opsi-winst-stringlist-getstring>>) may help in this case: E.g. +
`getValue ("secsuntilconnectiontimeout", list)` +
would produces the requested number).

By the function `count (list)` we can check if we succeeded with the narrowing of the search request. In most circumstances, we would like that its result be "1".

[[opsi-winst-ldapsearch-syntax]]
==== LDAPsearch Section Syntax

A LDAPsearch section comprises the specifications:

* `targethost:` +
The server hosting the LDAP directory (service) must be named.

* `targetport:` +
If the port of the LDAP service is not the default (389), it can be declared at this place. If the specification is missing, the default port is used.

* `dn:` +
Here, the distinguished name, the "search path", for the search request can be given.

* `typesonly:` +
Default "false", that is, values are retrieved.

* `filter:` +
A filter for LDAP search has a LDAP specific syntax that is not checked by '{opsi-winst}'. Default is "(objectclass=*)"

* `attributes:` +
A comma separated list of attribute names may be given. The default is to take any attribute.

[[opsi-winst-ldapsearch-examples]]
==== Examples

A short and rather realistic example shall end this section:

'$founditems$' be a StringList variable and '$opsiClient$' a String variable. The call of 'getReturnlistFromSection' fetches the results of the section 'ldapsearch_hosts'. The following code fragment returns the unique result for $opsiDescription$ if it exists. It reports an error if the search produces an unexpected result:
[source,winst]
----
set $opsiClient$ = "test.uib.local"
set $founditems$ = getReturnlistFromSection("ldapsearch_hosts /values")

DefVar $opsiDescription$
set $opsiDescription$ = ""
if count(founditems) = "1"
  set $opsiDescription$ = takeString(0, founditems)
else
  if count(founditems) = "0"
    comment "No result found")
  else
    logError "No unique result for LdAPsearch for client " + $opsiclient$ 
  endif
endif


[ldapsearch_hosts]  
targethost: opsiserver
targetport:               
dn: cn=$opsiclient$,cn=hosts,cn=opsi,dc=uib,dc=local
typesOnly: false
filter: (objectclass=*)
attributes: opsiDescription
----

For further examples watch the product 'opsi-winst-test' and there especially 
'$Flag_winst_ldap_search$ = "on"'

[[opsi-winst-64bit]]
== 64 Bit Support

The '{opsi-winst}' is a 32 bit program. In order to make it easy for 32 bit programs to run on 64 bit systems there are special 32 bit areas in the registry as well in the file system. Some accesses from 32 bit programs will be redirected to these special areas to avoid access to areas that reserved for 64 bit programs.

A access to `c:\windows\system32` will be redirected to `c:\windows\syswow64`

But a access to `c:\program files` will be *not* redirected to `c:\program files (x86)`

A registry access to '[HKLM\software\opsi.org]' will be redirected to '[HKLM\software\wow6432node\opsi.org]'

Therefore '{opsi-winst}' installs as 32 bit program scripts, that run on 32 bit system fine, on 64 bit system correct without any change.

For the installation of 64 bit programs some constants like `%ProgramFilesDir%` returns the wrong values. Therefore we have since '{opsi-winst}' 4.10.8 some new features:

Normally you may (and should) tell explicit to which place you want to write or from where you want to read. Here we have three variants:

32:: explicit 32 bit

64:: explicit 64 bit; if not on a 64 bi system like 'sysnative'

SysNative::	according to the architecture on which the script runs

Following this idea, we have some additional constants:

.Constants
[options="header"]
|=======================
|Constant|32 Bit|64 Bit
|`%ProgramFilesDir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles32Dir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles64Dir%`|c:\program files|c:\program files
|`%ProgramFilesSysnativeDir%`|c:\program files|c:\program files
|=======================


`%ProgramFilesDir%`:: you should avoid this in future...

`%ProgramFiles32Dir%`:: should be used in the context of installing 32 bit Software.

`%ProgramFiles64Dir%`:: should be used in the context of installing 64 bit Software.

`%ProgramFilesSysnativeDir%`:: should be used if you need architecture specific information

For a reading access to the different aereas of registry and filesystem we have now the following new functions:

* `GetRegistrystringvalue32`
* `GetRegistrystringvalue64`
* `GetRegistrystringvalueSysNative`
* `FileExists32`
* `FileExists64`
* `FileExistsSysNative`

A simple call to Registry-section results in writing to the 32 bit registry regions. Also a simple call to Files-section results in writing to the 32 bit file system regions.

For 'Registry' and 'Files' section we have now the additional calling options:

* `/32Bit` +
This is the default. Any access will be redirected to the 32 bit regions.

* `/64Bit` +
Any access will be redirected to the 64 bit regions. If there are no 64 bit regions the architecture specific regions will be ussed.

* `/SysNative` +
 Any access will be redirected to the architecture specific regions

In addition to these '{opsi-winst}' functions, we copy at the installation of the opsi-client agent the (64 bit) file `c:\windows\system32\cmd.exe` to `c:\windows\cmd64.exe`. Using this `cmd64.exe` with 'ExecWith' sections you may call any 64 bit operations on the command line.

Examples:

File handling:
[source,winst]
----
if $INST_SystemType$ = "64 Bit System"
	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "64 Bit redirection"
	Files_copy_test_to_system32
	if FileExists("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 'cmd.exe' /C
	Files_copy_test_to_system32 /64Bit
	if FileExists64("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 '%SystemRoot%\cmd64.exe' /C
endif
----

Registry Handling:
[source,winst]
----
message "Write to 64 Bit Registry"
if ($INST_SystemType$ = "64 Bit System")
	set $ConstTest$ = ""
	set $regWriteValue$ = "64"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "%systemroot%\cmd64.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
else
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
endif

if ($INST_SystemType$ = "64 Bit System")
	set $regWriteValue$ = "64"
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
else
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
endif
----

[[opsi-winst-cookbook]]
== Cook Book

This chapter contains a growing collection of examples showing real world problems that can be mastered by simple or sophisticated pieces '{opsi-winst}' scripting.

[[opsi-winst-cookbook-recursive-delete]]
=== 9.1. Delete a File in all Subdirectories

Since '{opsi-winst}' 4.2 there is an easy solution for this task: To remove a file alt.txt from all subdirectories of the user profile directory the following Files call can be used:
[source,winst]
----
files_delete_Alt /allNtUserProfiles

[files_delete_Alt]
delete "%UserProfileDir%\alt.txt"
----
Neverthelesse we document a workaround which could be used in older '{opsi-winst}' versions. It demonstrates some techniques which may be helpful for other purposes.

The following ingredients are needed:

* A DosInAnIcon section which produces a list of all directory names.
* A Files section which deletes the file alt.txt in some directory.
* A String list processing that puts the parts together.

The complete script should look like:

[source,winst]
----
[Actions]

; variable for file name
DefVar $deleteFile$
set $deleteFile$ = "alt.txt"

; String list declarations
DefStringList list0
DefStringList list1

; capture the lines produced by the dos dir command
Set list0 = getOutStreamFromSection ('dosbatch_profiledir')

; Loop through the lines. Call a files section for each line.
for $x$ in list0 do files_delete_x

; Here are the two special sections
[dosbatch_profiledir]
@dir "%ProfileDir%" /b

[files_delete_x]
delete "%ProfileDir%\$x$\$deleteFile$"
----

[[opsi-winst-cookbook-service-running]]
=== Check if a specific service is running

If we want to check if a specific service (exemplified with "opsiclientd") is running, and, e.g., if it is not running, start it, we may use the following script.

In order to get the list of running services we launch the command 

`net start`

in a DosBatch section, capturing its output in list0. We trim the list, and iterate through its elements, thus seeing if the specified service is in it. If not, we do something for it.
[source,winst]
----
[Actions]
DefStringList $list0$
DefStringList $list1$
DefStringList $result$
Set $list0$=getOutStreamFromSection('DosBatch_netcall')
Set $list1$=getSublist(2:-3, $list0$)

DefVar $myservice$
DefVar $compareS$
DefVar $splitS$
DefVar $found$
Set $found$ ="false"
set $myservice$ = "opsiclientd"


comment "============================"
comment "search the list"
; for developping loglevel = 7
; setloglevel=7
; in normal use we dont want to log the looping
setloglevel = 5
for %s% in $list1$ do sub_find_myservice
setloglevel=7
comment "============================"

if $found$ = "false"
   set $result$ = getOutStreamFromSection ("dosinanicon_start_myservice")
endif


[sub_find_myservice]
set $splitS$ = takeString (1, splitStringOnWhiteSpace("%s%"))
Set $compareS$ = $splitS$ + takeString(1, splitString("%s%", $splitS$))
if $compareS$ = $myservice$
   set $found$ = "true"
endif


[dosinanicon_start_myservice]
net start "$myservice$"


[dosbatch_netcall]
@echo off
net start 
----

[[opsi-winst-cookbook-local-admin]]
=== Script for Installations in the Context of a Local Administrator

Sometimes it is necessary to run an installation script as an ordinary local user and not in the context of the opsi service. For example, there are installations that require a user context or use other services that are started after a user login. 

MSI installations which seem to need a local user can sometimes be configured by the option 'ALLUSERS=2' to proceed without such a user:
[source,winst]
----
[Actions]
DefVar $LOG_LOCATION$
Set $LOG_LOCATION$ = "c:\tmp\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb ALLUSERS=2 /l* $LOG_LOCATION$ /i %SCRIPTPATH%\files\myproduct.msi
----
In other case it is necessary to create a temporary administrative user in whose context the installation takes place. This can be done as follows:

* Create a directory 'localsetup' in the product directory (i.e. in 'install\productId').

* Move all installation files into this directory.

* Rename the installation script from '<productname>.ins' to 'local_<productname>.ins'

* Create a new '<produktname>.ins' in 'install\productId' and write the statements as below documented (with variables values adapted to your situation) into it . 

* Make sure that the script that is now named 'local_<produktname>.ins' finishes with a reboot call: The last executed command in the Actions section has to be the line +
`ExitWindows /Reboot`

* Insert a call at the beginning of the script 'local_<produktname>.ins' that removes the password of the temporary local administrator:
[source,winst]
----
[Actions]
Registry_del_autologin
;....

[Registry_del_autologin]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"=""
set "DefaultPassword"=""
----

The '{opsi-winst}' script template temporarily generates a user context, executes an installation in it, then removes it. Before using the template the following values are to be set adequately:

* the value for the variable '$Productname$'
* the value of the variable '$ProductSize$'
* $LockKeyboard$ to "true".

The script proceeds as follows:

* It creates a local administrator opsiSetupAdmin;
* saves the autologon state;
* inserts opsiSetupAdmin as autologon user;
* copies the installation files to the client (as defined in $localFilesPath$); among them the installation script that is to be executed in the local user context;
* creates a RunOnce entry in the registry that calls '{opsi-winst}' with the local script as argument;
* reboots in order to make the registry change work;
* when '{opsi-winst}' runs again, it calls an ExitWindows /ImmediateLogout, and the second scripting level begins to work:
* By autologon , opsiSetupAdmin is logged on without user interaction.
* Windows calls the RunOnce command, that is the '{opsi-winst}' call.
* The '{opsi-winst}' script should now regularly proceed. But at its end, there must be a ExitWindows /ImmediateReboot command. Otherwise the desktop would of the administratrive user opsiSetupAdmin who is already logged at the moment would be accessible.
* after the reboot, the main script works again cleaning everything (writing back the old autologon state, deleting the local setup files, removing the opsiSetupAdmin profile)

We call the two involved '{opsi-winst}' scripts master script and local script . The first one runs in a system service context, the second which does the specific software installation runs in the context of a local administrator.


CAUTION: If the local script requires internal reboots then the master script must be adapted to produce them. As long as the local script is not finished the master script hands over control to the local script by an `ExitWindows /ImmediateLogout`. Of course the RunOnce entry has to be created for each run. Since username and password for the autologon are removed at the beginning of the local script they have to be reset each time as well.

There is no direct access from the local script to the product properties (usually via the String function `GetProductProperty`) . If there are values needed the master script must retrieve them and e.g. save them temporarily in the registry.

There may be product installations by external setup program calls which change registry entries which are saved by the master script and usually written back at the end of the installation. In this case the master script must be adapted to avoid writing back.

The local script runs with an administrator logged in. You have to lock the keyboard when testing is done. Otherwise anybody sitting at the client could stop script execution and take over the session.

In the following example, the password of the tempory opsiSetupAdmin user is set via the function RandomStr, which is strongly recommended.

In order to avoid logging of passwords the loglevel is temporarily set to -2.

IMPORTANT: Please do not use the script as printed below, but use the opsi product: opsi-template-with-admin.

[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.

; TEMPLATE for
; Skript fuer Installationen im Kontext eines temporaeren lokalen Administrators
; installations as temporary local admin
; see winst_manual.pdf / winst_handbuch.pdf

; !!! requires winst32.exe version 4.2.x !!!

;
; !!! Das lokale Installations-Skript, das durch den temporaeren lokalen Admin ausgefuehrt wird
; !!! (sein Name steht in $LocalSetupScript$), muss mit dem Befehl  
; !!! exitWindows /Reboot
; !!! enden
; 

; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; Vorarbeiten/Voraussetzungen/Doku pruefen wie in Winsthandbuch
; 8.3 Skript fuer Installationen im Kontext eines lokalen Administrators
; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


[Actions]
requiredWinstVersion >= 4.10.6
setLogLevel=7
DefVar $ProductName$
DefVar $ProductSizeMB$
DefVar $LocalSetupScript$
DefVar $LockKeyboard$
DefVar $OpsiAdminPass$
DefVar $OS$
DefVar $MinorOS$
DefVar $MsVersion$
DefVar $RebootFlag$
DefVar $ShutdownRequested$
DefVar $WinstRegKey$
DefVar $RebootRegVar$
DefVar $AutoName$
DefVar $AutoPass$
DefVar $AutoDom$
DefVar $AutoLogon$
DefVar $AutoBackupKey$
DefVar $LocalFilesPath$
DefVar $LocalWinst$
DefVar $SystemType$
DefVar $platform_cmdexe$
DefVar $DefaultLoglevel$
DefVar $PasswdLogLevel$
DefVar $AdminGroup$
DefVar $SearchResult$

DefStringlist $ResultList$
DefStringlist $ResultList2$
DefStringlist $ResultList3$

comment "set $LockKeyboard$ to true to prevent user hacks while admin is logged in"
Set $LockKeyboard$="true"
Set $LockKeyboard$="false"
Set $ProductName$ = "opsi-template-with-admin"
Set $ProductSizeMB$ = "1"

Set $LocalSetupScript$ = "local_setup.ins"
set $OS$ = GetOS
set $MinorOS$ = GetNTVersion
Set $SystemType$ = GetSystemType
Set $MsVersion$ = GetMsVersionInfo
set $DefaultLoglevel$ = "7"
comment " set $PasswdLogLevel$ to 0 for production"
Set $PasswdLogLevel$="7"
SetLogLevel=$DefaultLoglevel$

if not (fileExists ("%Scriptpath%\psgetsid.exe"))
	LogError "psgetsid.exe is missing. Please install it from http://download.sysinternals.com/Files/PsTools.zip to %Scriptpath%"
	isFatalError
endif

if not(($SystemType$ = "64 Bit System") or ($SystemType$ = "x86 System"))
	LogError "Unknown Systemtype: "+$SystemType$+" - aborting"
	isFatalError
endif

if $SystemType$ = "64 Bit System"
	set $platform_cmdexe$ = "%SystemRoot%\cmd64.exe"
else
	set $platform_cmdexe$ = "%System%\cmd.exe"
endif

comment "handle Rebootflag"
Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
Set $RebootFlag$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"RebootFlag")
Set $ShutdownRequested$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"ShutdownRequested")

sub_test_autologon_data

comment "some paths required"
Set $AutoBackupKey$ = $WinstRegKey$+"\AutoLogonBackup"
Set $LocalFilesPath$ = "C:\opsi_local_inst"
Set $LocalWinst$ = "c:\opsi\utils\winst32.exe"
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\preloginloader\utils\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\preloginloader\opsi-winst\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\opsi-client-agent\opsi-winst\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	LogError "No opsi-winst found. Abborting."
	isFatalError
endif

comment "show product picture"
ShowBitmap /3 "%scriptpath%\localsetup\"+$ProductName$+".png" $ProductName$

if not (($RebootFlag$ = "1") or ($RebootFlag$ = "2") or ($RebootFlag$ = "3"))
	comment "Part before first Reboot"
	comment "just reboot - this must be done if this is the first product after OS installation"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "1"
	Registry_SaveRebootFlag
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2 or 3)

if $RebootFlag$ = "1"
	comment "Part before second Reboot"

	if not(HasMinimumSpace ("%SYSTEMDRIVE%", ""+$ProductSizeMB$+" MB"))
		LogError "Not enough space on drive C: . "+$ProductSizeMB$+" MB on C: required for "+$ProductName$
		isFatalError
	endif
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 1..."
	sub_Prepare_AutoLogon

	comment "we need to reboot now to be sure that the autologon work"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "2"
	Registry_SaveRebootFlag
	sub_test_autologon_data
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2)

if ($RebootFlag$ = "2")
	comment "Part after first Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "3"
	Registry_SaveRebootFlag
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 2..."
	Registry_enable_keyboard /64bit
	comment "now let the autologon work"
	comment "it will stop with a reboot"
	ExitWindows /ImmediateLogout
endif ; Rebootflag = 2

if ($RebootFlag$ = "3")
	comment "Part after second Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "0"
	Registry_SaveRebootFlag
	
	comment "Lets work..."
	Message "Cleanup "+$ProductName$+" install (step 3)..."
	sub_Restore_AutoLogon
	set $SearchResult$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce] opsi_autologon_setup")
	if $SearchResult$ = $LocalWinst$+" "+$LocalFilesPath$+"\"+$LocalSetupScript$+" /batch"
		LogError "Localscript did not run. We remove the RunOnce entry and abort"
		Registry_del_runonce /64Bit
		isFatalError
	endif
	comment "This is the clean end of the installation"
endif ; Rebootflag = 3
ExitWindows /Reboot

[sub_Prepare_AutoLogon]
comment "copy the setup script and files"
Files_copy_Setup_files_local
comment "read actual Autologon values for backup"
set $AutoName$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultUserName")
comment "if AutoLogonName is our setup admin user, something bad happend"
comment "then let us cleanup"
if ($AutoName$="opsiSetupAdmin")
	set $AutoName$=""
	set $AutoPass$=""
	set $AutoDom$=""
	set $AutoLogon$="0"
else
	set $AutoPass$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
	set $AutoDom$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
	set $AutoLogon$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")
endif

comment "backup AutoLogon values"
Registry_save_autologon

comment "prepare the admin AutoLogon"
SetLogLevel=$PasswdLogLevel$
set $OpsiAdminPass$= randomstr
Registry_autologon /64Bit

comment "get the name of the admin group"
comment "using psgetsid from sysinernals pstools"
set $ResultList$ = getOutStreamFromSection("DosInAnIcon_get_admin_group")
set $AdminGroup$ = takeString(6,$ResultList$)
set $AdminGroup$ = takeString(1,splitstring($AdminGroup$,"\"))
comment "create our setup admin user"
DosInAnIcon_makeadmin
SetLogLevel=$DefaultLoglevel$

comment "remove c:\tmp\winst.bat with password"
Files_remove_winst_bat

comment "store our setup script as run once"
Registry_runOnce /64Bit

comment "disable keyboard and mouse while the autologin admin works"
if ($LockKeyboard$="true")
	Registry_disable_keyboard /64Bit
endif

[sub_test_autologon_data]
set $AutoPass$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
set $AutoDom$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
set $AutoLogon$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")

[sub_Restore_AutoLogon]
comment "read AutoLogon values from backup"
set $AutoName$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultUserName")
set $AutoPass$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultPassword")
set $AutoDom$= GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultDomainName")
set $AutoLogon$= GetRegistryStringValue("["+$AutoBackupKey$+"] AutoAdminLogon")

comment "restore the values"
SetLogLevel=$PasswdLogLevel$
Registry_restore_autologon /64Bit
SetLogLevel=$DefaultLoglevel$
comment "delete our setup admin user"
DosInAnIcon_deleteadmin
comment "cleanup setup script, files and profiledir"
Files_delete_Setup_files_local
comment "delete profiledir"
DosInAnIcon_deleteprofile

[Registry_save_autologon]
openkey [$AutoBackupKey$]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[Registry_restore_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[DosInAnIcon_deleteadmin]
NET USER opsiSetupAdmin  /DELETE

[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$RebootFlag$"

[Files_copy_Setup_files_local]
copy -s %ScriptPath%\localsetup\*.* $LocalFilesPath$

[Files_delete_Setup_files_local]
delete -sf $LocalFilesPath$
; folgender Befehl funktioniert nicht vollständig, deshalb ist er zur Zeit auskommentier
; der Befehl wird durch die Sektion "DosInAnIcon_deleteprofile" ersetzt (P.Ohler)
;delete -sf "%ProfileDir%\opsiSetupAdmin"

[DosInAnIcon_deleteprofile]
rmdir /S /Q "%ProfileDir%\opsiSetupAdmin"

[DosInAnIcon_get_admin_group]
@echo off
"%ScriptPath%\psgetsid.exe" /accepteula S-1-5-32-544

[DosInAnIcon_makeadmin]
NET USER opsiSetupAdmin $OpsiAdminPass$ /ADD
NET LOCALGROUP $AdminGroup$ /ADD opsiSetupAdmin

[Registry_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="opsiSetupAdmin"
set "DefaultPassword"="$OpsiAdminPass$"
set "DefaultDomainName"="localhost"
set "AutoAdminLogon"="1"

[Registry_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
set "opsi_autologon_setup"='"$LocalWinst$" "$LocalFilesPath$\$LocalSetupScript$" /batch'

[Registry_del_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
DeleteVar "opsi_autologon_setup"

[Registry_disable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x4
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x4

[Registry_enable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x1
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x1

[Files_remove_winst_bat]
delete -f c:\tmp\_winst.bat
----

[[opsi-winst-cookbook-patchxml]]
=== XML File Patching: Setting Template Path for OpenOffice.org 2

Setting the template path can be done by the following script extracts

[source,winst]
----
[Actions]
; ....

DefVar $oooTemplateDirectory$
;----------------------------------------------------------------------
;set path here:

Set $oooTemplateDirectory$ = "file://server/share/verzeichnis"
;----------------------------------------------------------------------
;...

DefVar $sofficePath$
Set $sofficePath$= GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\OpenOffice.org\OpenOffice.org\2.0] Path")
DefVar $oooDirectory$
Set $oooDirectory$= SubstringBefore ($sofficePath$, "\program\soffice.exe")
DefVar $oooShareDirectory$
Set $oooShareDirectory$ = $oooDirectory$ + "\share"

XMLPatch_paths_xcu $oooShareDirectory$+"\registry\data\org\openoffice\Office\Paths.xcu"
; ...


[XMLPatch_paths_xcu]
OpenNodeSet
- error_when_no_node_existing false
- warning_when_no_node_existing true
- error_when_nodecount_greater_1 false
- warning_when_nodecount_greater_1 true
- create_when_node_not_existing true
- attributes_strict false

documentroot
all_childelements_with:
elementname: "node"
attribute:"oor:name" value="Paths"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="Template"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="InternalPaths"
all_childelements_with: 
elementname: "node"

end

SetAttribute "oor:name" value="$oooTemplateDirectory$"
----

[[opsi-winst-cookbook-readxml]]
=== Retrieving Values From a XML File

As treated in <<opsi-winst-cookbook-patchxml>> , '{opsi-winst}' can evaluate and modify XML files. 

An example shall demonstrate how a value can be retrieved from a XML file. We assume that the following XML file is:
[source,winst]
----
<?xml version="1.0" encoding="utf-16" ?>
<Collector xmlns="http://schemas.microsoft.com/appx/2004/04/Collector" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:schemaLocation="Collector.xsd" UtcDate="04/06/2006 12:28:17" LogId="{693B0A32-76A2-4FA0-979C-611DEE852C2C}"  Version="4.1.3790.1641" >
   <Options>
      <Department></Department>
      <IniPath></IniPath>
      <CustomValues>
      </CustomValues>
   </Options>
   <SystemList>
      <ChassisInfo Vendor="Chassis Manufacture" AssetTag="System Enclosure 0" SerialNumber="EVAL"/>
      <DirectxInfo Major="9" Minor="0"/>
   </SystemList>
   <SoftwareList>
      <Application Name="Windows XP-Hotfix - KB873333" ComponentType="Hotfix" EvidenceId="256" RootDirPath="C:\WINDOWS\$NtUninstallKB873333$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x4235b909">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873333" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873333$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873333" UninstallString="C:\WINDOWS\$NtUninstallKB873333$\spuninst\spuninst.exe" OsComponent="true" UniqueId="256"/>
         </Evidence>
      </Application>
      <Application Name="Windows XP-Hotfix - KB873339" ComponentType="Hotfix" EvidenceId="257" RootDirPath="C:\WINDOWS\$NtUninstallKB873339$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x9c550c9c">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873339" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873339$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873339" UninstallString="C:\WINDOWS\$NtUninstallKB873339$\spuninst\spuninst.exe" OsComponent="true" UniqueId="257"/>
         </Evidence>
      </Application>
   </SoftwareList>
</Collector>
----

To read the elements and get the values of all „Application“ nodes we may use these extracts of code:
[source,winst]
----
[Actions]
DefStringList $list$

...

set $list$ = getReturnListFromSection ('XMLPatch_findProducts '+$TEMP$+'\test.xml')
for $line$ in $list$ do Sub_doSomething

[XMLPatch_findProducts]
openNodeSet
	; Node „Collector“ is  documentroot
	documentroot
	all_childelements_with:
	  elementname:"SoftwareList"
	all_childelements_with:
	  elementname:"Application"
end
return elements

[Sub_doSomething]
set $escLine$ = EscapeString:$line$
; now we can work on the content of $escLine$
----
We encapsulate the retrieved Strings by setting their values as a whole into an variable via an EscapeString call. Since the loop variable %line% is not a common variable but behaves like a constant all special characters in it (as < > $ % “ ') may cause difficulties. 

[[opsi-winst-cookbook-xmlnamespace]]
=== Inserting a Name Space Definition Into a XML File

The '{opsi-winst}' XMLPatch section requires fully declared XML name spaces (as is postulated in the XML RFC). But there are XML configuration files which do not declare „obvious“ elements (and the interpreting programs insist that the file looks this way). Especially patching the lots of XML/XCU configuration files of OpenOffice.org proved to be a hard job. For solving this task, A. Pohl (many thanks!) the functions XMLaddNamespace and XMLremoveNamespace. Its usage is demonstrated by the following example:
[source,winst]
----
DefVar $XMLFile$
DefVar $XMLElement$
DefVar $XMLNameSpace$
set $XMLFile$ = "D:\Entwicklung\OPSI\winst\Common.xcu3" 
set $XMLElement$ = 'oor:component-data'
set $XMLNameSpace$ = 'xmlns:xml="http://www.w3.org/XML/1998/namespace"'

if XMLAddNamespace($XMLFile$,$XMLElement$, $XMLNameSpace$) 
  set $NSMustRemove$="1" 
endif 
;
; now the XML Patch should work
; (commented out since not integrated in this example)
;
; XMLPatch_Common $XMLFile$ 
;
; when finished we rebuild the original format 
if $NSMustRemove$="1" 
  if not (XMLRemoveNamespace($XMLFile$,$XMLElement$,$XMLNameSpace$)) 
    LogError "XML-Datei konnte nicht korrekt wiederhergestellt werden"    
    isFatalError
  endif 
endif 
----

Please observe that the XML file must be formatted such that the element tags do not contain line breaks. 

[[opsi-winst-special-errors]]
== Special Error Messages

* No Connection with the opsi Service +
The '{opsi-winst}' logs: "... cannot connect to service".

The information which is shown additionally may give a hint to the problem:

Socket-Fehler #10061, Connection refused::
Perhaps the opsi service does not run. 

Socket-Fehler #10065, No route to host::
No network connection to server

HTTP/1.1. 401 Unauthorized::
The service responds but the user/password combination is not accepted.

