////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; Until we found a better license:
; All rights reserved.
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Date:      05.05.2011
:Revision:  4.0.1
:toclevels: 6


include::../common/opsi_terms.asciidoc[]

[[opsi-manual-clientagent]]
== opsi-client-agent

[[opsi-manual-clientagent-overview]]
=== Overview

To make Software distribution manageable for the system administrator, a client computer has to notice that new software-packets or updates are available and install them without user interaction. It is important to make user-interaction completely obsolete as the installation can run unattended this way and a user cannot stop the installation during the installation process.

These requirements are implemented in opsi by the '{opsi-client-agent}': 

On the client side the service 'opsiclientd' usally at boot time before the user logs in examines whether an update has to be installed for this client. 

If there are software to be installed on the client, the script processing program 'opsi-winst' is being started to do the installation job. The server provides all the installation scripts and software files on a file share. At this time the user has no chance to interfere with the installation process. 

As an additional option the module 'loginblocker' can be installed to prevent a user login before the end of the installation process is reached.

Before a software can be installed with the 'opsi-winst' program, they have to be prepared as '{opsi-product-package}'. For details see Chapter 'Integration of new software packets into the opsi software deployment' at the 'getting started' manual.

[[opsi-manual-clientagent-directories]]
=== Directories of the opsi-client-agent

The '{opsi-client-agent}' is installed at `%ProgramFiles%\opsi.org\opsi-client-agent`.


This directory contains all programs of the '{opsi-client-agent}' like e.g. the '{opsiclientd}', the '{opsiclientd-notifier}' the '{opsi-winst}' and some needed libraries. Also we will find here the configuration files and graphical templates (skins) of the mentioned programs.

The directory `%ProgramFiles%\opsi.org\opsi-client-agent` is protected against manipulation by users without administartor priviliges. +
The directory `%ProgramFiles%\opsi.org\opsi-client-agent\opsiclientd` contains the configuration file of the '{opsiclientd}' and you need administrator privilges to read it.

There is a other directory `c:\opsi.org`.

This directory is used (at the moment) for caching installation files and data (see WAN-Extension). In future it will have some more function like containig log files. +
You need administrator privilges to read the directory `c:\opsi.org`.

The log files of the '{opsi-client-agent}' you will find at `c:\tmp`.

[[opsi-manual-clientagent-service]]
=== The service: opsiclientd

The '{opsiclientd}' is the core of the '{opsi-client-agent}'. The '{opsiclientd}' starts at boot time and runs with administrative privileges.

The important features are:

* Event based control: +
The activity of the opsi client agent (opsiclientd) may be triggered by different events in the client system. According to this fact the start of the installation is not fixed at the system start up any more.

* Control via web service: +
This interface is used for 'push' installations and for maintenance purpose as well.

* Remote configuration: +
The configuration data for the clients may be changed (globally or client specific) at the server by editing the 'Host parameter'.

The '{opsi-client-agent}' consists of multiple components :

* '{opsiclientd}': the central service
* '{opsiclientd-notifier}': information and communication window
* '{opsi-login-blocker}': block the login until the installation has finished

[[opsi-manual-clientagent-installation]]
==== Installation

In case of automatic OS-Installation with opsi (not image based), the '{opsi-client-agent}' will be installed automatically.

You may set the action request 'unstall' to uninstall the '{opsi-client-agent}'.

For a subsequent installation on a existing Windows system or for repair purposes see at the 'getting started' manual.
////
<<opsi-manual-clientagent-subsequent-installation>>.
////

[[opsi-manual-clientagent-opsiclientd]]
==== opsiclientd

Core component of the '{opsi-client-agent}' is the service '{opsiclientd}'. This service starts at the boot time.

The '{opsiclientd}' has the following tasks:

* while the system is booting and the '{opsiclientd}' is waiting for the GUI to come up the 'block_login_notifier' is started wich shows a padlock at the righit upper corner of the screen.

* Getting active if the configuration event takes place. If it geat active the '{opsiclientd}' contacts the opsi server via web service (JSON-RPC) and ask for configuration data and required actions. +
The default event is 'gui_startup' which will fire at boot time and before login.

* Creates a named pipe which is used by the '{opsi-login-blocker}' to ask via JSON-RPC the '{opsiclientd}' when to unblock the login.

* Starting the '{opsiclientd-notifier}' as thread for information and interaction with the user.

* If needed, it connects to the '{opsi-depot}', update and start of the '{opsi-winst}' and start this program to process the '{action-requests}' (installations).

[[opsi-manual-clientagent-opsiclientd-notifier]]
==== opsiclientd notifier

The '{opsiclientd-notifier}' implements the interaction with the user. They displays status messages and may give the possibility to interact with the process.

There are different situations where the '{opsiclientd-notifier}' will become active in different ways:

blocking notifier::
Indicates that the '{opsi-login-blocker}' is blocking

.opsiclientd blocklogin notifier
image::../images/opsiclientd-blocklogin-notifier.png["opsiclientd blocklogin notifier",width=80]

event notifier::
Give information to a started event.

.opsiclientd event notifier
image::../images/opsiclientd-event-notifier.png["opsiclientd event notifier",width=150]

action notifier::
Shows state of the event processing

.opsiclientd action notifier
image::../images/opsiclientd-action-notifier.png["opsiclientd action notifier",width=150]

shutdown notifier::
Gives information about a requested reboot / shutdown 
(if shutdown_warning_time > 0)

.opsiclientd shutdown notifier
image::../images/opsiclientd-shutdown-notifier.png["opsiclientd shutdown notifier",width=150]

CAUTION: The names and functionality of the notifier has changed from opsi 4.0 to opsi 4.0.1. +
The opsi 4.0 event notifier doesn't exist's anymore. +
The opsi 4.0.1 event notifier is equal to the opsi 4.0 action notifier. +
The opsi 4.0.1 action notifier has nearly the same functionality like the opsi 4.0 event notifier, but it will only be activated if there is a '{action-request}'.


[[opsi-manual-clientagent-loginblocker]]
==== {opsi-login-blocker}
Der '{opsi-login-blocker}' für NT5 Win2K/WinXP ist als 'GINA' implementiert ('opsigina.dll').
Diese 'GINA' wartet bis zum Abschluss der '{product-actions}' oder dem Timeout (Standard-Wert: 120 Sekunden) bei nicht erreichbarem '{opsiclientd}'.
Danach wird die Kontrolle an die nächste 'GINA' übergeben (in der Regel an die msgina.dll).

Der '{opsi-login-blocker}' für NT6 (Vista/Win7) ist als 'credential provider filter' realisiert ('OpsiLoginBlocker.dll').
Er blockiert alle 'credential provider' bis zum Abschluss der '{product-actions}' oder dem Timeout (Standard-Wert: 120 Sekunden) bei nicht erreichbarem '{opsiclientd}'.

[[opsi-manual-clientagent-event-flow]]
==== Event-Ablauf

Der Ablauf der Aktionen, die in einem Event stattfinden, ist vielfältig konfigurierbar.
Um die Konfigurations-Möglichkeiten zu verstehen, ist ein Verständnis der Ablauf-Logik notwendig.
Es folgt zunächst ein Überblick über den Ablauf eines "Standard-Events" bei dem der {opsi-configserver} gefragt wird,
ob Aktionen auszuführen sind (z.B. 'event_gui_startup').

.Ablauf eines Standard-Events
image::../images/eventflowchsrt.png["Abbildung: Ablauf eines Standard-Events",height=400]

Die wichtigsten Parameter wirken hier wie folgt zusammen:

. Tritt ein Event ein, wird der +event_notifier_command+ ausgeführt. +
Nun wird versucht die konfigurierten '{opsi-configserver}' über deren URLs zu erreichen. +
Konnte nach +user_cancellable_after+ Sekunden keine Verbindung hergestellt werden, so wird im '{opsiclientd-notifier}'
der Button aktiviert, der das Abbrechen der Verbindungsaufnahme ermöglicht.
Sobald die Verbindung zum '{opsi-configserver}' hergestellt ist, ist ein Abbrechen nicht mehr möglich. +
Kann innerhalb von +connection_timeout+ Sekunden keine Verbindung zum '{opsi-configserver}' hergestellt werden,
so wird das laufende Event mit einem Fehler beendet.
Soll der User keine Möglichkeit zum Abbrechen haben, muss +user_cancellable_after+ auf einen Wert größer oder gleich +connection_timeout+ gesetzt werden.

TIP: Tritt bei der Verbindungsaufnahme zum '{opsi-configserver}' ein Fehler auf, kann natürlich auch keine Log-Datei
zum '{opsi-configserver}' übertragen werden.
Die genaue Fehlerbeschreibung ist jedoch in der `opsiclientd.log` im Log-Verzeichnis auf dem Client festgehalten.

. Wird der '{opsi-configserver}' erreicht, wird geprüft, ob Aktionen gesetzt sind.
Sollen Aktionen ausgeführt werden wird der +action_notifier_command+ ausgeführt. +
Dieser '{opsiclientd-notifier}' zeigt die Liste der Produkte an, für die Aktionen gesetzt sind und ist +action_warning_time+ Sekunden sichtbar.
Ist die +action_warning_time+ = 0 (Standard-Wert) wird kein +action_notifier_command+ ausgeführt. +
Zusätzlich kann dem Anwender ermöglicht werden, das Bearbeiten der Aktionen auf einen späteren Zeitpunkt zu verschieben.
Die Aktionen können hierbei +action_user_cancelable+ mal verschoben werden. +
Nach Erreichen der maximalen Abbrüche oder im Fall von +user_cancelable+ = 0 kann der Anwender die Aktionen nicht verhindern. +
In jedem Fall wird ein Button angezeigt, mit dem die Wartezeit abgebrochen und die Bearbeitung der Aktionen ohne weitere Verzögerung begonnen werden kann.
Der Hinweis-Text, der im '{opsiclientd-notifier}' erscheint, ist über die Option +action_message+ bzw +action_message[lang]+ konfigurierbar. +
Innerhalb dieses Textes können die Platzhalter +%action_user_cancelable%+ (Gesamtanzahl der möglichen Abbrüche)
und +%action_cancel_counter%+ (Anzahl der bereits erfolgten Abbrüche) verwendet werden. +
Wurden die Aktionen nicht vom User abgebrochen, wird der +action_cancel_counter+ zurückgesetzt und der '{opsi-winst}' startet mit deren Bearbeitung.

. Beendet sich der '{opsi-winst}' mit einer Reboot-/Shutdown-Anforderung so wird geprüft ob ein +shutdown_notifier_command+ gesetzt ist
und ob sie +shutdown_warning_time+ > 0 ist.
Sind diese Bedingungen erfüllt, wird der +shutdown_notifier_command+ ausgeführt. +
Der standardmäßig startende '{opsiclientd-notifier}' verhält sich analog zum '{opsiclientd-notifier}', der die Aktionen ankündigt
und ist +shutdown_warning_time+ Sekunden sichtbar. +
Die maximale Anzahl, wie oft ein Reboot/Shutdown vom Benutzer verschoben werden kann, wird hierbei über +shutdown_user_cancelable+ konfiguriert. +
In jedem Fall bietet der '{opsiclientd-notifier}' die Möglichkeit, den Shutdown/Reboot sofort auszuführen. +
Bei einem Verschieben der Reboot-/Shutdown-Anforderung durch den Benutzer erscheint der '{opsiclientd-notifier}' nach +shutdown_warning_repetition_time+ Sekunden wieder. +
Der Hinweis-Text ist über +shutdown_warning_message+ bzw. +shutdown_warning_message[lang]+ konfigurierbar.
Innerhalb dieses Textes können die Platzhalter +%shutdown_user_cancelable%+ (Gesamtanzahl der möglichen Abbrüche)
und +%shutdown_cancel_counter%+ (Anzahl der bereits erfolgten Abbrüche) verwendet werden. +
Nach erfolgtem Shutdown oder Reboot wird der +shutdown_cancel_counter+ zurückgesetzt.

TIP: Der Ablauf des Event und auch die Aktionen des Benutzers sind in der Timeline auf der Info-Seite des '{opsiclientd}s' sichtbar (siehe <<opsi-manual-clientagent-infopage>>).

.Vollständiges Ablaufdiagramm eines Events
image::../images/opsiclientd-event-processing-flow.png["Abbildung: Vollständiges Ablaufdiagramm eines Events",height=650]

[[opsi-manual-clientagent-configuration]]
==== Konfiguration

[[opsi-manual-clientagent-configuration-events]]
===== Konfiguration unterschiedlicher Events

Um den vielen unterschiedlichen Situationen gerecht zu werden, in denen der '{opsi-client-agent}' aktiv werden kann, sind die Konfigurations-Möglichkeiten vielfältig. +
In der Konfiguration des '{opsiclientd}' leitet eine Sektion in der Form +[event_<config-id>]+ eine neue Event-Konfiguration ein. +
Eine Event-Konfiguration kann über das Setzen der Option +active = false+ deaktiviert werden.
Existiert zu einem Event-Typ keine Event-Konfiguration (oder sind diese deaktiviert), wird der entsprechende Event-Typ komplett deaktiviert. +
Es gibt verschiedene Typen von Event-Konfigurationen (+type+).

* Es gibt 'Event-Konfigurations-Vorlagen' (type = template) +
Event-Konfigurationen können voneinander "erben". Ist über die Option +super+ die Id einer anderen Event-Konfiguration gesetzt,
erbt die Event-Konfiguration alle Optionen (bis auf +active+) der Parent-Konfiguration.
Geerbte Optionen können jedoch überschrieben werden. +
Das Deaktivieren von Events beeinflusst die Vererbung nicht.

* Alle weiteren Event-Konfigurationen gelten für einen gewissen Event-Typ (type). +
Verfügbare Event-Typen sind:
  - +gui startup+ +
Ein Event vom Typ +gui startup+ tritt beim Start des Clients (der GUI) auf. +
Es ist das gängigste Event und ist in der Standard-Konfiguration aktiv.

  - +custom+ +
Event-Konfigurationen vom Typ +custom+ können selbst festlegen, wann ein solches Event erzeugt wird.
Hierfür kann über die Option +wql+ ein 'WQL'-Ausdruck angegeben werden.
Sobald dieser 'WQL'-Ausdruck ein Ergebnis liefert, wird ein +custom+-Event mit der jeweiligen Konfiguration gestartet. +
Wird bei einem +custom+-Event die Option +wql+ leer angegeben, tritt dieses Event praktisch nie auf,
kann aber über die Webservice-Schnittstelle des '{opsiclientd}' bei Bedarf ausgelöst werden.

  - +user login+ +
Wird ausgelöst, wenn sich ein Benutzer am System anmeldet.

  - +timer+ +
Tritt in festen Intervallen auf (alle +interval+ Sekunden).

  - +sync completed+ +
Wird ausgelöst, wenn die Synchronisation von Konfigurationen (+sync_config_from_server+) oder von Produkten (+cache_products+) erfolgt.

  - +sw on demand+ +
Tritt auf, wenn ein Benutzer bei Verwendung des 'Software-On-Demand-Moduls' 'Aktionen sofort ausführen' wählt.

* Es gibt 'Preconditions' (Vorbedingungen) +
'Preconditions' geben bestimmte Systemzustände vor (z.B. ob gerade ein Benutzer am System angemeldet ist).
In der Konfiguration des '{opsiclientd}' leitet eine Sektion in der Form +[precondition_<precondition-id>]+ die Deklaration einer 'Precondition' ein.
Eine 'Precondition' ist dann erfüllt, wenn alle angegebenen Optionen erfüllt sind.
Eine nicht angegebene Option gilt hierbei als erfüllt.
Mögliche Optionen für 'Preconditions' sind:
  - +user_logged_in+: ist erfüllt, wenn ein Benutzer am System angemeldet ist.
  - +config_cached+: ist erfüllt, wenn das Cachen von Konfigurationen abgeschlossen ist (siehe: +sync_config_from_server+).
  - +products_cached+: ist erfüllt, wenn das Cachen von Produkten abgeschlossen ist (siehe: +cache_products+).

* Einer Event-Konfiguration kann eine 'Precondition' zugewiesen werden. +
Einer Event-Konfiguration kann eine 'Precondition' zugewiesen werden, indem diese bei der Deklaration in geschweiften Klammern angegeben wird (z.B. +[event_on_demand{user_logged_in}]+). +
Zu einer Event-Konfiguration mit 'Precondition' muss immer eine entsprechende Event-Konfiguration ohne 'Precondition' existieren.
Existiert z.B. eine Event-Konfiguration +event_on_demand{user_logged_in}+ muss auch die Event-Konfiguration +event_on_demand+ existieren!
Hierbei erbt die Event-Konfiguration mit 'Precondition' automatisch von der Event-Konfiguration ohne 'Precondition'. +
Beim Auftreten eines Events wird nun entschieden welche 'Preconditions' erfüllt sind.
Ist keine der 'Preconditions' erfüllt, gilt die Event-Konfiguration ohne 'Precondition'.
Ist eine der 'Preconditions' erfüllt, gilt die Event-Konfiguration die mit dieser 'Precondition' verknüpft ist.
Sind mehrere 'Preconditions' erfüllt, so wird die 'Precondition' bevorzugt, die am genauesten definiert ist (die meisten Optionen besitzt).


Ein Beispiel zur Erläuterung: +
Im Rahmen einer Installation kann es notwendig sein den Rechner zu rebooten.
Ist gerade ein Benutzer am System angemeldet, sollte dieser über den anstehenden Reboot informiert werden.
Hierbei ist eine angemessene Wartezeit vor dem Ausführen des Reboots angebracht.
Zusätzlich kann es sinnvoll sein, dem Benutzer die Entscheidung zu überlassen, ob der Reboot besser zu einem späteren Zeitpunkt ausgeführt werden soll. +
Ist zum Zeitpunkt des benötigten Reboots jedoch kein Benutzer angemeldet, ist es sinnvoll, den Reboot ohne weitere Wartezeit sofort durchzuführen. +
Dieses Problem wird am Beispiel von +event_on_demand+ wie folgt konfiguriert:

* Es wird eine 'Precondition' +user_logged_in+ definiert, die erfüllt ist, wenn ein Benutzer am System angemeldet ist (+user_logged_in = true+).
* In der Event-Konfiguration +event_on_demand+ (ohne 'Precondition') wird +shutdown_warning_time = 0+ gesetzt (sofortiger Reboot ohne Meldung).
* In der Event-Konfiguration +event_on_demand{user_logged_in}+ wird +shutdown_warning_time = 300+ gesetzt (300 Sekunden Vorwarnzeit).


[[opsi-manual-clientagent-configuration-file]]
===== Konfiguration über die Konfigurationsdatei

Die Konfigurationsdatei ist: +
`c:\program files\opsi.org\opsi-client-agent\opsiclientd\opsicliend.conf`

CAUTION: Diese Konfigurationsdatei ist UTF-8 kodiert. +
Änderungen mit Editoren, die diese Kodierung nicht beherrschen (z.B. notepad.exe), zerstören die Umlaute in dieser Datei.

Die hier festgelegte Konfiguration kann nach erfolgreicher Verbindung zum '{opsi-configserver}' durch die dort festgelegte '{opsi-config-object}' überschrieben werden.
Beispiel `opsiclientd.conf`:
[source,ini]
----
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
; =     configuration file for opsiclientd                              =
; = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =


; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     global settings                                                 -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[global]

# Location of the log file.
log_file = c:\\tmp\\opsiclientd.log

# Set the log (verbosity) level
# (0 <= log level <= 9)
# 0: nothing, 1: essential, 2: critical, 3: errors, 4: warnings, 5: notices
# 6: infos, 7: debug messages, 8: more debug messages, 9: passwords
log_level = 4

# Client id.
host_id = 

# Opsi host key.
opsi_host_key = 

# Verify opsi server certs
verify_server_cert = false

# On every daemon startup the user login gets blocked
# If the gui starts up and no events are being processed the login gets unblocked
# If no gui startup is noticed after <wait_for_gui_timeout> the login gets unblocked
# Set to 0 to wait forever
wait_for_gui_timeout = 120

# Application to run while blocking login
block_login_notifier = %global.base_dir%\\notifier.exe -s notifier\\block_login.ini

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     config service settings                                         -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[config_service]
# Service url.
# http(s)://<opsi config server address>:<port>/rpc
url = https://opsi.uib.local:4447/rpc

# Conection timeout.
connection_timeout = 30

# The time in seconds after which the user can cancel the connection establishment
user_cancelable_after = 30

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     depot server settings                                           -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[depot_server]

# Depot server id
depot_id =

# Depot url.
# smb://<depot address>/<share name>/<path to products>
url =

# Local depot drive
drive =

# Username that is used for network connection [domain\]<username>
username = pcpatch

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     cache service settings                                          -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[cache_service]
# Maximum product cache size in bytes
product_cache_max_size = 5000000000

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     control server settings                                         -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[control_server]

# The network interfaces to bind to.
# This must be the IP address of an network interface.
# Use 0.0.0.0 to listen to all interfaces
interface = 0.0.0.0

# The port where opsiclientd will listen for HTTPS rpc requests.
port = 4441

# The location of the server certificate.
ssl_server_cert_file = %global.base_dir%\\opsiclientd\\opsiclientd.pem

# The location of the server private key
ssl_server_key_file = %global.base_dir%\\opsiclientd\\opsiclientd.pem

# The location of the static files
static_dir = %global.base_dir%\\opsiclientd\\static_html

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     notification server settings                                    -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[notification_server]

# The network interfaces to bind to.
# This must be the IP address of an network interface.
# Use 0.0.0.0 to listen to all interfaces
interface = 127.0.0.1

# The first port where opsiclientd will listen for notification clients.
start_port = 44000

# Port for popup notification server
popup_port = 45000

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     opsiclientd notifier settings                                   -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[opsiclientd_notifier]

# Notifier application command
command = %global.base_dir%\\notifier.exe -p %port% -i %id%

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     opsiclientd rpc tool settings                                   -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[opsiclientd_rpc]

# RPC tool command
command = %global.base_dir%\\opsiclientd_rpc.exe "%global.host_id%" "%global.opsi_host_key%" "%control_server.port%"

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     action processor settings                                       -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[action_processor]
# Locations of action processor
local_dir = %global.base_dir%\\opsi-winst
remote_dir = \\install\\opsi-winst\\files\\opsi-winst
filename = winst32.exe
# Action processor command
command = "%action_processor.local_dir%\\%action_processor.filename%" /opsiservice "%service_url%" /clientid %global.host_id% /username %global.host_id% /password %global.opsi_host_key%

; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
; -     events                                                          -
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
[event_default]
; === Event configuration
# Type of the event (string)
type = template
# Interval for timer events in seconds (int)
interval = -1
# Maximum number of event repetitions after which the event will be deactivated (int, -1 = forever)
max_repetitions = -1
# Time in seconds to wait before event becomes active (int, 0 to disable delay)
activation_delay = 0
# Time in seconds to wait before an event will be fired (int, 0 to disable delay)
notification_delay = 0
# Event notifier command (string)
event_notifier_command = %opsiclientd_notifier.command% -s notifier\\event.ini
# The desktop on which the event notifier will be shown on (current/default/winlogon)
event_notifier_desktop = current
# Block login while event is been executed (bool)
block_login = false
# Lock workstation on event occurrence (bool)
lock_workstation = false
# Logoff the current logged in user on event occurrence (bool)
logoff_current_user = false
# Get config settings from service (bool)
get_config_from_service = true
# Store config settings in config file (bool)
update_config_file = true
# Transmit log file to opsi service after the event processing has finished (bool)
write_log_to_service = true
# Shutdown machine after action processing has finished (bool)
shutdown = false
# Reboot machine after action processing has finished (bool)
reboot = false

; === Sync/cache settings
# Sync configuration from local config cache to server (bool)
sync_config_to_server = false
# Sync configuration from server to local config cache (bool)
sync_config_from_server = false
# Sync configuration from local config cache to server after action processing (bool)
post_sync_config_to_server = false
# Sync configuration from server to local config cache after action processing (bool)
post_sync_config_from_server = false
# Work on local config cache
use_cached_config = false
# Cache products for which actions should be executed in local depot cache (bool)
cache_products = false
# Maximum transfer rate when caching products in byte/s (int, 0 = no limit)
cache_max_bandwidth = 0
# Dynamically adapt bandwith to other network traffic (bool)
cache_dynamic_bandwidth = false
# Work on local depot cache
use_cached_products = false

; === Action notification (if product actions should be processed)
# Time in seconds for how long the action notification is shown (int, 0 to disable)
action_warning_time = 0
# Action notifier command (string)
action_notifier_command = %opsiclientd_notifier.command% -s notifier\\action.ini
# The desktop on which the action notifier will be shown on (current/default/winlogon)
action_notifier_desktop = current
# Message shown in the action notifier window (string)
action_message = Starting to process product actions. You are allowed to cancel this event a total of %action_user_cancelable% time(s). The event was already canceled %state.action_processing_cancel_counter% time(s).
# German translation (string)
action_message[de] = Starte die Bearbeitung von Produkt-Aktionen. Sie können diese Aktion insgesamt %action_user_cancelable% mal abbrechen. Die Aktion wurde bereits %state.action_processing_cancel_counter% mal abgebrochen.
# Number of times the user is allowed to cancel the execution of actions (int)
action_user_cancelable = 0

; === Action processing
# Should action be processed by action processor (bool)
process_actions = true
# Type of action processing (default/login)
action_type = default
# Update the action processor from server before starting it (bool)
update_action_processor = true
# Command which should be executed before start of action processor
pre_action_processor_command =
# Action processor command (string)
action_processor_command = %action_processor.command%
# The desktop on which the action processor command will be started on (current/default/winlogon)
action_processor_desktop = current
# Action processor timout in seconds (int)
action_processor_timeout = 10800
# Command which should be executed before after action processor has ended
post_action_processor_command =

; === Shutdown notification (if machine should be shut down or rebooted)
# Process shutdown requests from action processor
process_shutdown_requests = true
# Time in seconds for how long the shutdown notification is shown (int, 0 to disable)
shutdown_warning_time = 0
# Shutdown notifier command (string)
shutdown_notifier_command = %opsiclientd_notifier.command% -s notifier\\shutdown.ini
# The desktop on which the action notifier will be shown on (current/default/winlogon)
shutdown_notifier_desktop = current
# Message shown in the shutdown notifier window (string)
shutdown_warning_message = A reboot is required to complete software installation tasks. You are allowed to delay this reboot a total of %shutdown_user_cancelable% time(s). The reboot was already delayed %state.shutdown_cancel_counter% time(s).
# German translation (string)
shutdown_warning_message[de] = Ein Neustart wird benötigt um die Software-Installationen abzuschliessen. Sie können diesen Neustart insgesamt %shutdown_user_cancelable% mal verschieben. Der Neustart wurde bereits %state.shutdown_cancel_counter% mal verschoben.
# Number of times the user is allowed to cancel the shutdown (int)
shutdown_user_cancelable = 0
# Time in seconds after the shutdown notification will be shown again after the user has canceled the shutdown (int)
shutdown_warning_repetition_time = 3600

[event_gui_startup]
super = default
type = gui startup
name = gui_startup
block_login = true

[event_gui_startup{user_logged_in}]
name = gui_startup
shutdown_warning_time = 300
block_login = false

[event_gui_startup{cache_ready}]
use_cached_config = true
use_cached_products = true
action_user_cancelable = 3
action_warning_time = 60

[event_on_demand]
super = default
type = custom
name = on_demand

[event_on_demand{user_logged_in}]
name = on_demand
shutdown_warning_time = 300

[event_software_on_demand]
super = default
type = sw on demand

[event_sync]
super = default
type = template
process_actions = false
event_notifier_command = 
sync_config_to_server = true
sync_config_from_server = true
cache_products = true
cache_dynamic_bandwidth = true

[event_timer]
super = sync
type = timer
active = false
interval = 300

[event_net_connection]
super = sync
type = custom
active = false
wql = SELECT * FROM __InstanceModificationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_NetworkAdapter' AND TargetInstance.NetConnectionStatus = 2

[event_sync_completed]
super = default
type = sync completed
event_notifier_command = 
process_actions = false
get_config_from_service = false
write_log_to_service = false

[event_sync_completed{cache_ready_user_logged_in}]
reboot = true
shutdown_user_cancelable = 10
shutdown_warning_time = 300

[event_sync_completed{cache_ready}]
reboot = true

[event_user_login]
super = default
type = user login
action_type = login
active = false
message = Starting to process user login actions.
message[de] = Beginne mit der Verarbeitung der Benutzer-Anmeldungs-Aktionen.
block_login = false
process_shutdown_requests = false
get_config_from_service = false
update_config_file = false
write_log_to_service = false
update_action_processor = false
action_notifier_command = %opsiclientd_notifier.command% -s notifier\\userlogin.ini
action_notifier_desktop = default
action_processor_command = %action_processor.command% /usercontext %event.user%
action_processor_desktop = default
action_processor_timeout = 300

[precondition_user_logged_in]
user_logged_in = true

[precondition_cache_ready]
config_cached = true
products_cached = true

[precondition_cache_ready_user_logged_in]
user_logged_in = true
config_cached = true
products_cached = true
----

[[opsi-manual-clientagent-configuration-webservice]]
===== Konfiguration über den Webservice ({opsi-config-object})

Die Konfiguration kann auch zentral gesteuert werden. Hierzu dienen Einträge in der '{opsi-config-object}' des '{opsi-configserver}s'.

Diese Einträge müssen dem folgenden Muster folgen: +
`opsiclientd.<name der section>.<name der option>`

Ein Beispiel: +
`opsiclientd.event_gui_startup.action_warning_time = 20` +
setzt in der Konfigurationsdatei `opsiclientd.conf` in der Sektion +[global]+ den Wert von +action_warning_time+ auf 20.

Die folgende Abbildung zeigt, wie diese Werte als Defaults für alle Clients über den '{opsi-configed}' gesetzt werden können.

.Serverweite Konfiguration des {opsiclientd} über den {opsi-configed}
image::../images/opsiclientd-configuration-via-configed-serverdefault.png["Abbildung: Serverweite Konfiguration des {opsiclientd} über den {opsi-configed}",width=400]

Hier kann über das Kontextmenü +Property hinzufügen+ ein neuer Wert gesetzt werden.

Um einen {opsi-config-object} zu löschen, verwenden Sie das Werkzeug '{opsi-admin}'.
Beispiel:
[source,prompt]
----
opsi-admin -d method config_delete "opsiclientd.event_gui_startup.action_warning_time"
----

Eine Client-spezifische Änderung über den '{opsi-configed}' führen Sie über den 'Hosts-Parameter' Tab in der Client-Konfiguration aus.
Um Client-spezifische Einträge zu löschen, verwenden Sie das Werkzeug '{opsi-admin}'.
Beispiel:
[source,prompt]
----
@opsi-admin> method configState_delete "opsiclientd.event_gui_startup.action_warning_time" "myclient.uib.local"
----

.Client-spezifische Konfiguration des {opsiclientd} über den {opsi-configed}
image::../images/opsiclientd-configuration-via-configed.png["Abbildung: Client spezifische Konfiguration des {opsiclientd} über den {opsi-configed}",width=400]


[[opsi-manual-clientagent-logging]]
==== Logging

Die Log-Datei des '{opsiclientd}' ist standardmäßig `c:\tmp\opsicliend.log`.

Die Log-Informationen werden auch an den '{opsi-configserver}' übertragen.
Dort liegen sie unter '/var/log/opsi/clientconnect/<ip-bzw.-name-des-clients>.log'.
Sie sind auch im '{opsi-configed}' über Logdateien => Clientconnect einsehbar.

Jede Zeile in der Logdatei folgt dem Muster: +
+[<log level>] [<datum zeit>] [Quelle der Meldung] Meldung   (Quellcode-Datei|Zeilennummer).+

Dabei gibt es die folgenden Log-Level:
....
# Set the log (verbosity) level
# (0 <= log level <= 9)
# 0: nothing, 1: essential, 2: critical, 3: errors, 4: warnings, 5: notices
# 6: infos, 7: debug messages, 8: more debug messages, 9: passwords
....

Beispiel:
[source,opsilog]
----
(...)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed{cache_ready}' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup{cache_ready}' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'on_demand' added to event generator 'on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed{cache_ready_user_logged_in}' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'gui_startup{user_logged_in}' added to event generator 'gui_startup'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'sync_completed' added to event generator 'sync_completed'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'software_on_demand' added to event generator 'software_on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Event config 'on_demand{user_logged_in}' added to event generator 'on_demand'   (Events.pyo|1107)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] Updating config file: 'C:\Program Files (x86)\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf'   (Config.pyo|287)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] No need to write config file 'C:\Program Files (x86)\opsi.org\opsi-client-agent\opsiclientd\opsiclientd.conf', config file is up to date   (Config.pyo|318)
[5] [Mar 22 10:17:46] [ event processing gui_startup  ] No product action requests set   (EventProcessing.pyo|591)
[5] [Mar 22 10:17:49] [ event processing gui_startup  ] Writing log to service   (EventProcessing.pyo|247)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] shutdownRequested: 0   (Windows.pyo|340)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] rebootRequested: 0   (Windows.pyo|326)
[5] [Mar 22 10:17:49] [ opsiclientd                   ] Block login now set to 'False'   (Opsiclientd.pyo|111)
[6] [Mar 22 10:17:49] [ opsiclientd                   ] Terminating block login notifier app (pid 1620)   (Opsiclientd.pyo|148)
[6] [Mar 22 10:17:49] [ event processing gui_startup  ] Stopping notification server   (EventProcessing.pyo|225)
[6] [Mar 22 10:17:51] [ control server                ] client connection lost   (Message.pyo|464)
[6] [Mar 22 10:17:52] [ event processing gui_startup  ] Notification server stopped   (Message.pyo|651)
[5] [Mar 22 10:17:52] [ event processing gui_startup  ] ============= EventProcessingThread for event 'gui_startup' ended =============   (EventProcessing.pyo|1172)
[5] [Mar 22 10:17:52] [ opsiclientd                   ] Done processing event '<ocdlib.Events.GUIStartupEvent object at 0x023CE330>'   (Opsiclientd.pyo|405)
[5] [Mar 22 10:19:41] [ opsiclientd                   ] Session 'HSzMB1wtOiBS6vHl7mh3ro5r6s3TanFu' from ip '127.0.0.1', application 'opsi jsonrpc module version 4.0.1' expired after 120 seconds   (Session.pyo|184)
[6] [Mar 22 10:19:41] [ opsiclientd                   ] Session timer <_Timer(Thread-20, started daemon 2636)> canceled   (Session.pyo|120)
[5] [Mar 22 10:19:41] [ opsiclientd                   ] Session 'HSzMB1wtOiBS6vHl7mh3ro5r6s3TanFu' from ip '127.0.0.1', application 'opsi jsonrpc module version 4.0.1' deleted   (Session.pyo|207)
[6] [Mar 22 10:27:55] [ control pipe                  ] Creating pipe \\.\pipe\opsiclientd   (ControlPipe.pyo|253)
[5] [Mar 22 10:27:55] [ event generator wait_for_gui  ] -----> Executing: getBlockLogin()   (JsonRpc.pyo|123)
[5] [Mar 22 10:27:55] [ opsiclientd                   ] rpc getBlockLogin: blockLogin is 'False'   (ControlPipe.pyo|428)
[6] [Mar 22 10:27:55] [ event generator wait_for_gui  ] Got result   (JsonRpc.pyo|131)
'
----


Die Log-Datei des '{opsi-login-blocker}s' befindet sich unter NT6 (Vista/Win7) als auch unter NT5 (Win2k/WinXP) in `c:\tmp\opsi_loginblocker.log`.

[[opsi-manual-clientagent-infopage]]
==== {opsiclientd} infopage

Da bei den Abläufen im '{opsiclientd}' vielfältige Komponenten zusammenwirken, welche zum Teil gleichzeitig aktiv sind, wird die Logdatei leicht unübersichtlich.

Daher verfügt der '{opsiclientd}' über eine eigene 'infopage' welche die Abläufe auf einer Zeitachse grafisch darstellt.
Diese 'infopage' kann mit dem Browser über die URL https://<adresse-des-clients>:4441/info.html aufgerufen werden.

.Info-Page des {opsiclientd} nach einer Push-Installation mit aktiviertem Produkt-Caching
image::../images/opsiclientd_infopage_event_on_demand.png["Abbildung: Info-Page des {opsiclientd} nach einer Push-Installation mit aktiviertem Produkt-Caching",width=400]

[[opsi-manual-clientagent-control]]
==== Fernsteuerung des {opsi-client-agent}

Der '{opsiclientd}' verfügt über eine Webservice-Schnittstelle.
Diese ermöglicht es, dem {opsi-client-agent} Anweisungen zu übermitteln und Vieles mehr.
Sie lassen sich momentan grob in drei Bereiche aufteilen:

* Nachrichten (Popup) versenden

* 'Push'-Installationen durch auslösen von Events (z.B. 'on_demand')

* Sonstige Wartungsarbeiten

Dies kann auch auf der Kommandozeile mittels Aufrufs einer 'hostControl_*'-Methode über '{opsi-admin}' geschehen.
Bei Verwendung der 'hostControl_*'-Methoden +
`opsi-admin -d method hostControl_xx *hostIds` kann der Parameter +*hostIds+

* entfallen, dann gilt der Aufruf für alle Clients

* einen Client enthalten (z.B. "myclient.uib.local")

* eine Liste von Clients enthalten ["<client1>", "<client2>", ...]
+
z.B. ["client1.uib.local", "client2.uib.local"]

* eine Wildcard enthalten, wobei +*+ als Platzhalter dient
+
z.B. "client.\*" oder "\*.uib.*"

Werden Rechner nicht erreicht (z.B. weil sie aus sind), wird für diese Rechner eine Fehlermeldung ausgegeben.

[[opsi-manual-clientagent-control-messages]]
===== Nachrichten per Popup senden

Über den '{opsi-configed}' lassen sich Nachrichten an einen oder mehrere Clients versenden.

Siehe dazu Kapitel <<opsi-manual-configuration-tools-opsi-configed-client-editing-send-message>>

Auf der Kommandozeile lässt dich dies ebenfalls mittels '{opsi-admin}' durchführen:
[source,prompt]
----
opsi-admin -d method hostControl_showPopup message *hostid
----

Beispiel:
[source,prompt]
----
opsi-admin -d method hostControl_showPopup "Ein Text..." "myclient.uib.local"
----

[[opsi-manual-clientagent-control-fire-event]]
===== 'Push'-Installationen: Event 'on demand' auslösen

Vom '{opsi-server}' aus kann der Client aufgefordert werden, die gesetzten '{product-actions}' auszuführen.

Das Auslösen des Events kann vom '{opsi-configed}' aus erfolgen.
////
und ist Kapitel  'on_demand' Ereignis auslösen (Push-Installation) auf Seite 30 beschrieben.
////

Auf der Kommandozeile lässt sich dies ebenfalls mittels '{opsi-admin}' durchführen:
[source,prompt]
----
opsi-admin -d method hostControl_fireEvent event *hostIds
----

Beispiel:
[source,prompt]
----
opsi-admin -d method hostControl_fireEvent "on_demand" "myclient.uib.local"
----

[[opsi-manual-clientagent-control-misc]]
===== Sonstige Wartungsarbeiten (shutdown, reboot, ...)

Über den Webservice des '{opsiclientd}' ist es möglich, steuernd auf den '{opsi-client-agent}' einzuwirken.
Dazu muss man sich an diesem Webservice authentifizieren.
Dies geschieht entweder mittels des lokalen Administrator-Accounts (ein leeres Passwort ist unzulässig)
oder mittels der '{opsi-host-id}' (FQDN / vollständiger Host-Name inkl. DNS-Domain) als Benutzername und des '{opsi-host-key}s' als Passwort.

Vom '{opsi-configed}' aus geht dies über das Menü 'OpsiClient' oder aus dem Kontextmenü des 'Client'-Tabs.

.Webservice des {opsiclientd}
image::../images/opsiclientd-control-server-web-interface.png["Abbildung: Webservice des {opsiclientd}",width=400]

Auch auf der Kommandozeile gibt es hierfür Entsprechungen:

shutdown:
[source,prompt]
----
opsi-admin -d method hostControl_shutdown *hostIds
----

reboot:
[source,prompt]
----
opsi-admin -d method hostControl_reboot *hostIds
----

[[opsi-manual-clientagent-loginblock]]
=== Sperrung des Anwender Logins mittels {opsi-login-blocker}

Um zu verhindern, dass sich ein Anwender schon vor dem Abschluss der Installation am System anmeldet, kann zusätzlich der {opsi-login-blocker} installiert werden.
Dieser gibt den Zugriff auf den Login erst frei, wenn der Installations-Prozess beendet ist.

Ob der '{opsi-login-blocker}' währen der '{opsi-client-agent}'-Installation installiert bzw. aktiviert wird,
kann über das '{product-property}' +loginblockerstart+ konfiguriert werden.

[[opsi-manual-clientagent-loginblock-nt5]]
==== {opsi-login-blocker} unter NT5 (Win2k/WinXP)
Der {opsi-login-blocker} (`opsigina.dll`) ist als 'GINA' realisiert.
Die 'opsigina' wartet bis zum Abschluss der '{product-actions}' oder dem Timeout (standard-Wert: 120 Sekunden) bei nicht erreichbarem '{opsiclientd}'.
Danach wird die Kontrolle an die nächste 'GINA' übergeben (in der Regel an die msgina.dll).
'GINA' steht hierbei für „Graphical Identification and Authentication“ und stellt die seitens Microsofts offiziell unterstützte Möglichkeit dar,
in den Login-Prozess von Windows einzugreifen.
Gelegentlich ist es der Fall, dass bereits andere Softwareprodukte (z.B. Client für Novell-Netzwerke) eine 'GINA' auf dem System installiert haben
und empfindlich auf Eingriffe reagieren.
Generell sind mehrere ,nacheinander aufgerufene 'GINAs' ('GINA-chaining') durchaus möglich.
Auch die 'opsigina.dll' des {opsi-login-blocker} ist für das genannte 'GINA-chaining' vorbereitet.
Sollte der beschriebene Fall bei Ihren Clients eintreten, informieren Sie sich bitte auf dem freien Supportforum (https://forum.opsi.org)
nach bestehenden Anpassungsmöglichkeiten oder kontaktieren Sie die Firma 'uib'.

[[opsi-manual-clientagent-loginblock-nt6]]
==== {opsi-login-blocker} unter NT6 (Vista/Win7)
Der '{opsi-login-blocker}' für NT6 (Vista/Win7) ist als 'credential provider filter' realisiert ('OpsiLoginBlocker.dll').
Er blockiert alle 'credential provider' bis zum Abschluss der '{product-actions}' oder dem Timeout (Standard-Wert: 120 Sekunden) bei nicht erreichbarem '{opsiclientd}'.

[[opsi-manual-clientagent-subsequent-installation]]
=== Nachträgliche Installation des opsi-client-agents
Die Anleitung zur nachträglichen Installation des '{opsi-client-agent}s' finden Sie im Handbuch 'opsi-getting-started' im Kapitel 'Erste Schritte'.

[[opsi-manual-clientagent-image-installation]]
==== Installation des opsi-client-agent in einem Master-Image oder als Exe
### has to be written ###




