////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; http://creativecommons.org/licenses/by-sa/3.0/de/
; http://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; http://creativecommons.org/licenses/by-sa/3.0/
; http://creativecommons.org/licenses/by-sa/3.0/legalcode
; 
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Date:      12.10.2011
:Revision:  4.0.1
:toclevels: 6


include::../common/opsi_terms.asciidoc[]

[[opsi-manual-roamingprofiles]]
== opsi Extension for Roaming Profiles


[[opsi-manual-roamingprofiles-preconditions]]
=== Preconditions for the extension

This extension is at the moment a co-funding project which means that until the complete development costs are payed by co-funders, they are only allowed to use by the co-funders or for evaluation purposes. If we have earned the development cost we will give these modules for everybody for free. +
see also <<opsi-manual-modules>> +
and +
http://uib.de/en/opsi_cofunding/index.html
http://www.opsi.org/en/statistics

So as precondition to use this extension you need as first an activation file.
For evaluatuon purpose you will get a temporary activation file if you ask for it in a mail at info@uib.de.

Technical precondions are opsi 4.0.1 with the following package and product versions:

.Needed product and package versions
[options="header"]
|==========================
|opsi-Paket|Version
|opsi-client-agent|>=4.0.1-22
|'{opsi-winst}'|>=4.11.2.1
|==========================


[[opsi-manual-roamingprofiles-introduction]]
=== Introduction

The '{opsi-winst}' has some special commands to manipulate profiles. These commands act at the local stored profiles. If you are using 'Roaming Profiles' this feature of the '{opsi-winst}' does not help you because all modifications at the profiles will be overwritten by the server stored profile while login.

The opsi extension for 'Roamin Profiles' gives you the possibility to do the needed Profile manipulation after the login of the user, at the correct profile. This is done by starting the '{opsi-winst}' after the user login again and run some special 'userLoginScripts'.


[[opsi-manual-roamingprofiles-concept]]
=== Concept

If you can't do the profile manipulation while installing the software on the machin, you have to separate the 'machine part' of the software installation from the 'profile part'. This can be done inside of a script and also by putting the 'profile part' into a separate script. Many admins still use the second idea by integrating 'profile parts' into a domain login script.

According to the method you use the 'profile part' of your opsi products are part of the opsi installation scripts for installation and deinstallation or they are separated for example as part of the domain login scripts. +
The goal of this opsi extension is to provide the possibillity to integrate both variants of scripts easily.

The core concepts of this opsi extension are:

* Executing special 'userLoginScripts' scripts at the user login +
At the user login the opsiclientd uses the 'event_user_login' to startup the '{opsi-winst}' in a special login script mode. In this special mode the '{opsi-winst}' executes only the 'userLoginScripts' which are assigned to the opsi products. 

* Executing these scripts with adminitrative priviliges inside the context of the logged in user +
Domain login scripts may be used to execute 'profile parts'. But they run only with user priviliges. opsi 'userLoginScripts' run with adminitrative priviliges. They run with these high priviliges in the user context, so that is easy to manipulate file and registry parts of the profile using the same commands you may use in a domain login script. 

*  Executing these scripts inside of the opsi service context +
The opsi 'userLoginScripts' run inside the opsi service context, so that they know all details about at which opsi product name, version and package version they are just working. They have the complete access to product properties and other information that can be requested by opsi service calls.

Restrictions:

* The opsi 'userLoginScripts' will be always executed online and not from a local cache. Even if your client runs with the opsi WAN extension.


[[opsi-manual-roamingprofiles-winst]]
=== New and extended '{opsi-winst}' functions
 
* Command line parameter `/allloginscripts` +
If you are calling '{opsi-winst}' in the opsi service context with the additional parameter '/allloginscripts' this will lead to the following actions:

** All products which have a 'userLoginScript' will be detected. Only for these products will be the 'userLoginScripts' executed.

** The logged in user will be identified. All global constants to user specific directories like +%CurrentAppdataDir%+ will be directed to the directories of the loggedin user. Also the registry operatoins  (`Registry` sections and `GetRegistryString`) which going to +HKCU+ will be executed in a way that they read or write to the current_user hive of the loggedin user.

* Command line parameter `/silent` +
The command line parameter `/silent` switchs of the '{opsi-winst}' standard window in order to not disturb the user.

* Function `GetScriptMode` +
In order to detected if a script runs as 'userLoginScript' or for example as installation script the function `GetScriptMode` gives you two possible values:
** 'Machine' +
The script is  *not* executed as 'userLoginScript' (but e.g. as setup or uninstall script).
** 'Login' +
The script is executed as 'userLoginScript'.

* Registry sections +
** Registry Sektionen welche auf 'HKCU' bzw. 'HKEY_CURRENT_USER' arbeiten werden lim Loginscript mode so ausgeführt, dass die Änderungen im Zweig des eingeloggten users landen. Entsprechendes gilt für die Funktionen `GetRegistryStringValue*`.
** Registry Sektionen welche im Normalen Modus ('Machine') mit dem Modifier '/AllNtUserDats' aufgerufen werden, dürfen jetzt in der `openkey` Anweisung den Root 'HKCU' bzw. 'HKEY_CURRENT_USER' enthalten. Dies ermöglicht es die selbe Registry Sektion in den unterschiedlichen Modi auszuführen.

* Vermeidung unnötiger Läufe: +
Mit den Befehl `saveVersionToProfile` kann im aktuelle Profil hinterlegt werden, das das userLoginscript zu diesem Produkt in dieser Version gelaufen ist. Mit der Stringfunktion `readVersionFromProfile` bzw. der boolschen Funktion `scriptWasExecutedBefore` kann überprüft werden ob das userLoginscript zu diesem Produkt in dieser Version schonmal zuvor gelaufen ist und eine erneute ausführung unnötig ist. Weiterhin liefert die Stringlistenfunktion `getProductMap` eine Infomap aus der entnommen werden kann ob das aktulelle Produkt installiert oder deinstalliert usw. ist.

* Logging +
Die Logs von userLoginScripten werden geschrieben nach: +
`c:\opsi.org\log\<login user name>_login.log` +
Diese Logdateien werden auch an den opsi-server übertragen. Dabei wird eine neue Logdatei an eine existierende angehängt. Der opsi-server sorgt dafür, dass diese Dateien in der Größe beschränkt bleiben (max. 5 MB). Auf dem opsi server liegen diese logs unter +/var/log/opsi/userlogin/<clientid>.log+ +
Im opsi Managementinterface (opsi-configed) werden diese Logs in einem zusätzliche Untertab in dem Tab 'Logdateien' angezeigt.

[[opsi-manual-roamingprofiles-scripts]]
=== Beispiele von Userloginscripten

Zunächst zwei Beispiele die so aufgebaut sind, wie sie auch in Domainloginscripten eingestzt werden könnten.

Ein sehr einfaches allgemeines Beispiel:

[source,winst]
----
[Actions]
Message "Example Profile Patch ...."

Files_profile_copy
Registry_currentuser_set

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%CurrentAppdataDir%\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"
----

Ein Beispiel zur Firefoxkonfiguration:

[source,winst]
----
[Actions]
Message "Firefox Profile Patch ...."

DefVar $akt_profile_ini$
DefVar $rel_prefs_path$

comment "check for existing profile ..."
Set $akt_profile_ini$ = "%CurrentAppdataDir%\Mozilla\Firefox\profiles.ini"
if FileExists($akt_profile_ini$)
	Set $rel_prefs_path$ = GetValueFromInifile($akt_profile_ini$,"Profile0","Path","")
	if FileExists("%CurrentAppdataDir%\Mozilla\Firefox\\"+$rel_prefs_path$)
		comment "We found the profile and will now patch it ....."
	endif
else
	comment "no firefox profile found for user"
endif
----

Als nächstes zeigen wir ein Beispiel welches das erste erweitert um die Möglichkeit Dinge aus dem Profil auch wieder zu entfernen. Je nachdem ob das Produkt auf dem Rechner installiert oder deinstalliert wird ein anderer Scriptteil ausgeführt:

[source,winst]
----
[Actions]
Message "Example Profile Patch ...."

if getValue("installationstate", getProductMap) = "installed"
	comment "Product is installed"
	Files_profile_copy
	Registry_currentuser_set
endif

if getValue("lastactionrequest", getProductMap) = "uninstall"
	comment "Product was uninstalled"
	Files_profile_del
	Registry_currentuser_del
endif

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%CurrentAppdataDir%\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"

[Files_profile_del]
del -s -f "%CurrentAppdataDir%\ACME"

[Registry_currentuser_del]
deletekey [HKCU\Software\ACME]
----

Nun ein Beispiel welches das Setup Skript (setup32.ins und delsub32.ins) nutzt um unnötige Verdopplung des Codes zu vermeiden:

setup32.ins:
[source,winst]
----
[Actions]
requiredWinstVersion >= "4.11.2"

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $ProductId$  
DefVar $InstallDir$

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
Set $ProductId$       = "ACME"
Set $InstallDir$      = "%ProgramFiles32Dir%\ACME"
; ----------------------------------------------------------------
	comment "Show product picture"
	ShowBitmap "%ScriptPath%\\" + $ProductId$ + ".png" $ProductId$

	if FileExists("%ScriptPath%\delsub32.ins")
		comment "Start uninstall sub section"
		Sub "%ScriptPath%\delsub32.ins"
	endif

if GetScriptMode = "Machine"
	Message "Installing " + $ProductId$ + " ..."
	
	comment "Start setup program"
	Winbatch_install
	
	comment "Patch the local Profiles ..."
	Registry_currentuser_set /AllNtUserDats
	Files_profile_copy /AllNtUserProfiles
endif

if GetScriptMode = "Login"
	comment "login part"
	Files_profile_copy
	Registry_currentuser_set
endif


[Winbatch_install]
"%ScriptPath%\setup.exe" /sp- /silent /norestart

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%UserProfileDir%\Appdata\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"
----

delsub32.ins:
[source,winst]
----
Message "Uninstalling " + $ProductId$ + " ..."

if GetScriptMode = "Machine"
	comment "The machine part ..."
	Set $UninstallProgram$ = $InstallDir$ + "\uninstall.exe"
	if FileExists($UninstallProgram$)
		comment "Uninstall program found, starting uninstall"
		Winbatch_uninstall
	endif
	; does not work: Registry_currentuser_del /AllNtUserDats
	Files_profile_del /AllNtUserProfiles
endif

if GetScriptMode = "Login" 
	comment "The profile part ..."
	Files_profile_del
	Registry_currentuser_del
endif

[Winbatch_uninstall]
"$UninstallProgram$" /silent /norestart

[Files_profile_del]
del -s -f "%UserProfileDir%\Appdata\ACME"

[Registry_currentuser_del]
deletekey [HKCU\Software\ACME]
----

Nun eine Variante, welche sich im Profil merkt ob das Skript für dieses Produkt in dieser Version und diesen User schon mal ausgeführt wurde.

[source,winst]
----
[Actions]
Message "Example Profile Patch ...."

comment "Did we run this script before ?"
if not (scriptWasExecutedBefore)
	comment "loginscript was not run yet "	
	Files_profile_copy
	Registry_currentuser_set
	comment "set version stamp in profile ..."
	saveVersionToProfile
endif

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%CurrentAppdataDir%\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"
----




[[opsi-manual-roamingprofiles-configuration]]
=== Konfiguration

Um die Roaming Profiles Erweiterung zu nutzen muss in der Konfiguration des opsiclientd das Loginevent aktiviert werden und dann der '{opsi-winst}' mit dem ergänzenden Parameter '/allloginscripts' gestartet werden. Damit der '{opsi-winst}' erfolgreich in den Kontext des eingloggten users wechseln kann muss er selbt im 'SYSTEM' Account gestartet werden.

Diese notwendigen Konfigurationen können Sie auf der Kommandozeile wie folgt einrichten:

[source, prompt]
----
opsi-admin -d method config_createBool opsiclientd.event_user_login.active "user_login active" true

opsi-admin -d method config_createUnicode opsiclientd.event_user_login.action_processor_command "user_login action_processor" "%action_processor.command% /allloginscripts"

opsi-admin -d method config_createUnicode opsiclientd.action_processor.run_as_user "action_processor run_as_user" "SYSTEM"
----

Als weiterer '{opsi-winst}' Parameter kann zusätzlich auch noch der Parameter '/silent' verwendet werden, welcher die Anzeige des '{opsi-winst}' Fensters unterbindet.

[source, prompt]
----
opsi-admin -d method config_createUnicode opsiclientd.event_user_login.action_processor_command "user_login action_processor" "%action_processor.command% /allloginscripts /silent"
----

Die so eingerichteten Einstellungen können Sie im opsi Managementinterface im Tab 'Hostparameter' Server- oder Clientspezifisch modifizieren.

[[opsi-manual-roamingprofiles-notification]]
=== Notification

Wenn Sie (wie oben beschrieben) das Loginevent aktiviert haben, so sehen Sie nach jedem Login den user_login_nofier:

.User Login Notifier
image::../images/login-action-notifier.png["User Login Notifier", width=100]







