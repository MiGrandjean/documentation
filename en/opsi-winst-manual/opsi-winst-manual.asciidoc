//// 
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; Until we found a better license:
; All rights reserved.
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Date:      21.07.2011
:Revision:  4.0.1

// Include common opsi terms
include::../common/opsi_terms.asciidoc[]


opsi-winst Manual
===================

[[opsi-winst-introduction]]
== Introduction

The open source program '{opsi-winst}' serves in the context of opsi – open pc server integration (cf. www.opsi.org) – as the central function for initiating and performing the automatic software installation. It may also be used stand alone as a tool for setup programs for any piece of software. 

'{opsi-winst}' is basically an interpreter for a specific, rather simple script language which can be used to express all relevant elements of a software installation. 

A software installation that is described by a '{opsi-winst}' script and performed by executing the script has several advantages compared with installations that are managed by a bunch of shell commands (e. g. copy etc.):

'{opsi-winst}' offers to log very thoroughly all operations of the installation process. The support team can check the log files, and can easily detect when errors occured or other problematic circumstances are evolving.

* Copy actions can be configured with a great variety of options if existing files shall be overwritten

* Especially, it may be configured that files are copied depending on their internal version.

* There are different modi for writing to the Windows registry (overwrite existing values/ write only when no value exists/ append a value to an existing value).

* The Windows registry can be patched for all users which exist on a work station (including the default user, who is used as prototype for further users).

* There is a sophisticated syntax for an integrated patching of  XML configuration files.


[[opsi-winst-cliparams]]
== Command Line Parameters

'{opsi-winst}' can be started with different sets of parameters depending on context and purpose of use. 

There are the following syntactical schemata:

(1) Show usage:

`opsi-winst /?` +
`opsi-winst /h`[elp]

(2 ) Execute a script 

`opsi-winst` <script file> +
      [`/logfile` <log file> ] +
      [`/batch` | `/histolist` <opsi-winst config file path>] +
      [`/usercontext` <[domain\]user name> ] +
      [`/parameter` parameter string]

(3) Execute a list of scripts (separated by semicolons) one by one:

`opsi-winst` `/scriptfile` <scriptfile> [;<script file>]* [ `/logfile` <log file> ] +
      [`/batch` | `/silent` ] +
      [`/usercontext` <[domain\]user name> ] +
      [`/parameter` <parameter string>] +

4) Read the PC configuration from the opsi service and act accordingly, since '{opsi-winst}' 4.3

`opsi-winst /opsiservice` <opsiserviceurl> +
     [`/clientid` <clientname>] +
     [`/username` <username>] +
     [`/password` <password>] +
     [`/logfile` <logfile>] +
     [`/usercontext` <[domain\]user name> ] +
     [`/parameter` <parameterstring>]
   
Some explanations:

* Default name of the log file is `c:\tmp\instlog.txt`

* The parameterstring, which is marked by the option `/parameter`, is accessible for every called wInst script (via the string function `ParamStr`).

* When called with option `/usercontext` wInst can do configurations for a specified logged in user (particularly in a Windows Terminal Server or Roaming Profile context).


Explanations to (2) and (3) :

* If option `/batch` is used, then wInst shows only its "batch surface" offering no user dialogs. By option `/silent` event the batch surface is suppressed. Without using option `/batch` we get into the interactive mode where script file and log file can be chosen interactively (mainly for testing purposes). 

* The `winstconfigfilepath` parameter which is designated by `/histofile` refers to a file in ini file format that holds the (in interactive mode) last used script file names. The dialogue surface presents a list box that presents these file names for choosing the next file to interpret. If `winstconfigfilepath` ends with "\" it is assumed to be a directory name and `WINST.INI` serves as file name.

Explanations to (4):

* The default for `clientid` is the full qualified computer name

The not interactive mode is implied.
     
[[opsi-winst-logpath]]
=== Log Paths

By default log files are written into the directory `c:\tmp` which  wInst tries to create. If wInst has no access to this directory it uses the user-TEMP directory. 

The default log file name is `instlog.txt`. The log file name and location will be overwritten via the specific command line option. 

In the case, that wInst executes a script in `/batch` mode and with a specified (and working) usercontext, the default logging path is the `opsi/tmp` in the appdata directory of the user. This will be overwritten by an explicit given log path.

In addition, wInst uses the logging directory for saving certain temporary files.

[[opsi-winst-configuration-options]]
== Additional Configurations 

[[opsi-winst-central-logging]]
=== Central Logging of Error Messages

If wanted, wInst writes the error data to a second file on a network drive or sends them to a syslog demon.

The feature can be configured in the Windows registry:

In HKEY_LOCAL_MACHINE, we have in a standard installation the key  \SOFTWARE\opsi.org.  We can create a subkey syslogd with a variable  remoteerrorlogging. Its value determines if and, if yes, by which method a central logging shall take place.

Furthermore, in +
'HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\syslogd' +
we have to observe three up to three variables:

* If remoteerrorlogging has value 0, no extra central logging takes place (default). 

////
* If remoteerrorlogging has value 1, wInst tries to open a $pcname$.err in the configshare, subdirectory pcpatch\pclog, and write the data to it. 
////

* If remoteerrorlogging has value 2, the error reports are sent to syslog demon. The demon host name is read from the variable sysloghost (default localhost) , the syslog channel number can be set from the value of the variable syslogfacility (default 18, that is local2).

The following table shows the possible values for the facility:

[source,ini]
----
ID_SYSLOG_FACILITY_KERNEL     = 0;  // kernel messages
ID_SYSLOG_FACILITY_USER       = 1;  // user-level messages
ID_SYSLOG_FACILITY_MAIL       = 2;  // mail system
ID_SYSLOG_FACILITY_SYS_DAEMON = 3;  // system daemons
ID_SYSLOG_FACILITY_SECURITY1  = 4;  // security/authorization messages (1)
ID_SYSLOG_FACILITY_INTERNAL   = 5;  // messages generated internally by syslogd
ID_SYSLOG_FACILITY_LPR        = 6;  // line printer subsystem
ID_SYSLOG_FACILITY_NNTP       = 7;  // network news subsystem
ID_SYSLOG_FACILITY_UUCP       = 8;  // UUCP subsystem
ID_SYSLOG_FACILITY_CLOCK1     = 9;  // clock daemon (1)
ID_SYSLOG_FACILITY_SECURITY2  = 10; // security/authorization messages (2)
ID_SYSLOG_FACILITY_FTP        = 11; // FTP daemon
ID_SYSLOG_FACILITY_NTP        = 12; // NTP subsystem
ID_SYSLOG_FACILITY_AUDIT      = 13; // log audit
ID_SYSLOG_FACILITY_ALERT      = 14; // log alert
ID_SYSLOG_FACILITY_CLOCK2     = 15; // clock daemon (2)
ID_SYSLOG_FACILITY_LOCAL0     = 16; // local use 0  (local0)
ID_SYSLOG_FACILITY_LOCAL1     = 17; // local use 1  (local1)
ID_SYSLOG_FACILITY_LOCAL2     = 18; // local use 2  (local2)
ID_SYSLOG_FACILITY_LOCAL3     = 19; // local use 3  (local3)
ID_SYSLOG_FACILITY_LOCAL4     = 20; // local use 4  (local4)
ID_SYSLOG_FACILITY_LOCAL5     = 21; // local use 5  (local5)
ID_SYSLOG_FACILITY_LOCAL6     = 22; // local use 6  (local6)
ID_SYSLOG_FACILITY_LOCAL7     = 23; // local use 7  (local7)
----

[[opsi-winst-skins]]
=== Skinnable {opsi-winst}

Since version 3.6  wInst has an adaptable skin. Its elements are located in a subdirectory winstskin of the directory of the executed  wInst. The definition file which you may edit is skin.ini. 

[[opsi-winst-script]]
== The '{opsi-winst}' Skript

On principle:  wInst is an interpreter for a specific, easy to use scripting language which is tailored for the requirements of software installations. A script should be an integrated description, and a means of control, for the installation of one piece of software.

The following section sketches the structure of a wInst script. The purpose is to identify the book marks of a script: in which way we to have to look into it to understand its processing.

All elements shall be described more in detail in the further section. The purpose then will be to show how scripts can be modified or developed.

[[opsi-winst-script-first-example]]
=== An Example

wInst scripts are roughly derived from .INI files. They are composed of  sections, which are marked by a title (the section name) which is written in brackets []. 

Schematically a wInst script looks like this one (here with a check which operating system is installed):

[source,winst]
----
[Actions]
Message "Installation of Mozilla"
SetLogLevel=6

;which Windows-Version?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
  

[sub_install_win7]
Files_copy_win7
WinBatch_Setup

[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP

[Files_copy_win7]
copy "%scriptpath%\files_win7\*.*" "c:\temp\installation"

[Files_copy_winxp]
copy "%scriptpath%\files_winxp\*.*" "c:\temp\installation"

[WinBatch_Setup]
c:\temp\installation\setup.exe

[WinBatch_SetupXP]
c:\temp\installation\install.exe
-----

How can we read the sections of this script?

[[opsi-winst-kinds-of-sections]]
=== Primary and Secondary Subprograms of a wInst script

The script as a whole serves as a program, an instruction for an installation process. Therefore each of its sections can be seen as a a subprogram (or "procedure" or "method").  The script is a collection of subprograms.

The human reader as well as an interpreting software has to know at which element in this collection reading must start.

Execution of a wInst script begins with working on the sections[Initial] and [Actions] (in this order). All other sections are called as subroutines from  these two sections. This process is only recursive for Sub sections: Sub sections have the same syntax as Initial and Actions sections and may contain calls for further subroutines.

This gives reason to make the distinction between primary and secondary subprograms:

The primary or general control sections comprise 

* the optional *Initial* section (by convention the beginning of the script),

* the *Actions* section (should follow to *Initial* section), and 

* *Sub* sections (0 to n subroutines called by the *Actions* section which are  syntactical and logical extensions of the calling section).

The procedural logic of the script is determined by the sequence of  calls in these sections. 

The secondary or specific sections can be called from any primary section but have a different syntax. The syntax is derived from the functional requirements and library conditions and conventions for the specific purposes. Therefore no further section can be called from a secondary section.

At this moment there are the following types of  secondary sections:

* Files sections, 
* WinBatch sections,
* DosBatch/DosInAnIcon/ShellInAnIcon sections,
* Registry sections
* Patches sections,
* PatchHosts sections,
* PatchTextFile sections,
* XMLPatch sections,
* LinkFolder sections,
* opsiServiceCall sections,
* ExecPython sections,
* ExecWith sections,
* LDAPsearch sections.

Meaning and syntax of the different section types are treated in chapters
<<opsi-winst-prim-section>>
and
<<opsi-winst-secsections>>.

[[opsi-winst-stringvalues]]
=== String Expressions in a wInst Script

Textual values (string values) in the primary sections can be given in different ways:

* A value can be directly cited, mostly by writing in into (double) citation marks. Examples: +
'"Installation 0f Mozilla"' +
'"n:\home\user name"'

* A value can be given by a String variable or a String constant, that "contains" the value: +
The variable '$MsVersion$' may stand for "6.1"  –  if it has been assigned beforedhand with this value.

* A function retrieves or calculates a value by some internal procedure. E. g.
`EnvVar ("Username")` +
fetches a value from the system environment, in this case the value of the environment variable 'Username'.  Functions may have any number of parameters, including zero: +
'GetMsVersionInfo' +
On a win7 system, this function call yields the value "6.1" (not as with a variable this values has to be produced at every call again). 

* A value can be constructed by an additive expression, where string values and partial expressions are concatenated - theoretically "plus" can be seen as a function of two parameters: +
'$Home$ + "\mail"'


(More on this in section <<opsi-winst-string>>)

There is no analogous way of using string expressions in the secondary sections. They follow there domain specific syntax. e.g. for copying commands similar to the windows command line copy command. Up to this moment it is no escape syntax implemented for transporting primary section logic into secondary sections. 

The only way to transport string values into secondary sections is the use of  the names of variables and constants as value container in these sections. Lets have a closer look at the variables and constants of a  wInst script:

[[opsi-winst-var-const]]
== Definition and Use of Variables and Constants in a wInst Script 

[[opsi-winst-var-const-general]]
=== General

In a wInst  script, variables and constants appear as "words", that are interpreted by   wInst and "contain" values. "Words"  are  sequences of  characters consisting of letters, numbers and some special characters (in particular ".", "-", "_", "$", "%"), but not blanks, but no brackets, parentheses, or operator signs ("+") . 

wInst  variables and constants are not case-sensitive.

There exist the following types of variables or constants:

* Global text constants, shortly constants, +
contain values which are present by the wInst  program and cannot be changed in a script. Before interpreting the script wInst  replaces each occurrence of  the pure constant name with its value in the whole script (textual substitution). +
An example will make this clear: +
The constant `%ScriptPath%` is the predefined name of the location where wInst  found and read the script that it just executes. This location may be, e.g.,  `p:\product`. Then we have to write +
`"%ScriptPath%"` +
in the script when we want do get the value 
+`"p:\product"`. +
- observe the citations marks which include the constant delimiter.

* Text or String variables, shortly variables, +
have an appearance very much like any (String) variables in a common programming language. They must be declared by a  `DefVar` statement before they can be used. In primary sections, values can be assigned to variables (once ore more times). They can be used as elements in composed expressions (like addition of strings) or as function arguments.  +
But they freeze in a  secondary section to a phenomenon that behaves like a constant. There, they appear as a non-syntactical foreign element. Their value is fixed and is inserted by textual substitution for their pure names (when a section is called, whereas the textual substitution for real constants take place before starting the execution of the whole script).

* Stringlist variables +
are declared by a `DefStringList` statement. In primary sections they can be used for many purposes, e.g. collecting strings, manipulating strings, building sections. 

In detail:

[[opsi-winst-global-const]]
=== Global Text Constants

Scripts shall work in a different contexts without manual changes. The contexts can be characterized by system values as OS version or certain paths. wInst  introduces such values as  constants into the script. 

[[opsi-winst-global-const-usage]]
==== Usage

The fundamental characteristics of a text constant is the way how the values which it represents come intro the script interpretation process:

The name of the constant, that is the pure sequences of chars, is substituted by its fixed value in the whole script before starting the script execution.

The replacement does not take into account any syntactical context in which the name possibly occur (exactly like with variables in secondary sections).

[[opsi-winst-global-const-exmple]]
==== Example
wInst implements constants %ScriptPath%  for the location of the momentarily interpreted script and %System% for the name of the windows system directory. The following (Files) subsection defines a command that copies all files from the script directory to the windows system directory:
[source,winst]
----
[files_do_my_copying]
copy "%ScriptPath%\system\*.*" "%System%" 
----

At this moment the following constants are implemented:

[[opsi-winst-global-const-list]]
[[opsi-winst-global-const-list-system1]]
==== System paths

[[opsi-winst-global-const-list-system-base]]
===== Base system directories

`%ProgramFilesDir%`:	'c:\program files'

`%ProgramFiles32Dir%`:	'c:\Program Files (x86)'

`%ProgramFiles64Dir%`:	'c:\program files'

`%ProgramFilesSysnativeDir%` :	'c:\program files'

`%Systemroot%` :  	'c:\windows'

`%System%` :  	 	'c:\windows\system32'

`%Systemdrive%` :       	'c:'

`%ProfileDir%` :	        'c:\Documents and Settings'

[[opsi-winst-global-const-list-commondir]]
===== Common (AllUsers) directories

`%AllUsersProfileDir%` or `%CommonProfileDir%` : 'c:\Documents and Settings\All Users'

`%CommonStartMenuPath%` or `%CommonStartmenuDir%` : 'c:\Documents and Settings\All Users\Startmenu'

`%CommonAppdataDir%` : 'c:\Documents and Settings\All Users\Application Data'

`%CommonDesktopDir%`

`%CommonStartupDir%`

`%CommonProgramsDir%`

[[opsi-winst-global-const-list-currentuser]]
===== Current (logged in or usercontext) user directories

`%AppdataDir%` or `%CurrentAppdataDir%` : 'c:\Documents and Settings\%USERNAME%\Application Data'

`%CurrentStartmenuDir%` 

`%CurrentDesktopDir%`

`%CurrentStartupDir%`

`%CurrentProgramsDir%`

`%CurrentSendToDir%`

[[opsi-winst-global-const-list-allntuser]]
===== /AllNtUserProfiles directory constants

In 'Files' sections that are called with option `/AllNtUserProfiles` there is a pseudo variable  +
`%UserProfileDir%` +
When the section is executed for each user that exists on a work station this variable represents the name of the profile directory of  the user just treated. 

[[opsi-winst-global-const-list-winst]]
==== '{opsi-winst}' Paths

`%ScriptPath%` or `%ScriptDir%` : represents the path of the current wInst script (without closing backslash). Using this variable we can build path and file names in scripts that are relative to the location of the script. So, everything can be copied, called from the new place, and all works as before.

`%ScriptDrive%` : he drive where the just executed wInst script is located (including the colon).

`%WinstDir%` : The location (without closing backslash) of the running wInst.

`%WinstVersion%` : Versionsstring des laufenden Winst.

`%Logfile%` : The name of the logfile which  wInst is using.

Example: +
The code:
[source,winst]
----
	comment "Testing: "
	message "Testing constants: "+"%"+"winstversion" +"%"
	set $ConstTest$ = "%WinstVersion%"
	set $InterestingFile$ = "%winstdir%\winst.exe"
	if not (FileExists($InterestingFile$))
		set $InterestingFile$ = "%winstdir%\winst32.exe"
	endif
	set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
	set $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----
	
results to the following log:
[source,winst]
----
comment: Testing: 
message Testing constants: %winstversion%

Set  $ConstTest$ = "4.10.8.3"
  The value of the variable "$ConstTest$" is now: "4.10.8.3"

Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable "$InterestingFile$" is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]

Set  $CompValue$ = getValue("file version with dots", $INST_Resultlist$ )
    retrieving strings from $INST_Resultlist$ [switch to loglevel 7 for debugging]
  The value of the variable "$CompValue$" is now: "4.10.8.3"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed

Else
EndIf
----

[[opsi-winst-global-const-list-network]]
==== Network Information

`%Host%` :	(Deprecated) The value of a environmental variable host (traditionally meaning the opsi server name, not to confuse with  %HostID%  (meaning the client network name).

`%PCName%`:	The value of the environmental variable +PCName+, when existing. Otherwise the value of  the environmental variable +computername+. (Should be the netbios name of the PC) 

`%IPName%` : The dns name of the pc. Usually identical with the netbios name and therefore with `%PCName%` besides that the netbios names uses to be uppercase. 

`%Username%` :	Name of the logged in user.

[[opsi-winst-global-const-list-service]]
==== Data for and from opsi service

`%HostID%` :	Should be the fully qualified domain name of the opsi client as it is supplied from the command line or otherwise. 

`%opsiserviceURL%` : The (usually https://) URL of the opsi service.

`%opsiServer%` : The server name derived from the `%opsiserviceURL%`.

`%opsiserviceUser%` : The user ID for which there is a connection to the opsi service.

`%opsiservicePassword%` : The user password used for the connection to the opsi service. The password is eliminated when logging by the standard wInst logging functions.

`%installingProdName%`: 	The 'productid' of the product that is actually installed via call by the opsi-service. Empty if the Script ist not started by the opsi-service.

`%installingProdVersion%`:	A String combinated from +<productversion>-<packageversion>+ for the product that is actually installed via call by the opsi-service. Empty if the Script ist not started by the opsi-service.

`%installingProduct%` :	(Deprecated) The name (productId) of the product for which the service has called the running script. In case that there the script is not run via the service the String is empty.

[[opsi-winst-strvar]]
=== String (or Text) Variables

[[opsi-winst-strvar-decl]]
==== Declaration

String variables must be declared before they can be used. The syntax for the  declaration reads

`DefVar` <variable name>

e.g.
[source,winst]
----
DefVar $MsVersion$
----

Explanation:

* Variable names do not necessarily start or end with a dollar sign, but this is recommended as a convention to understand their functioning in secondary sections.

* Variables can only be declared in primary sections (Initial section,  Actions section and sub sections).

*The declaration should not depend on a condition. That is it should not placed into a branch of an if – else  statement. Otherwise, it could happen that the DefVar statement is not executed for a variable, but an evaluation of the variable is tried in some if clause (such producing a syntax error).
The variables are initialized with an empty string (""). 

Recommendation:

* The first and last letter of the name should be '+$+'

* Define all variables at the beginning of the script

[[opsi-winst-strvar-set]]
==== Value Assignment

As it is appropriate for a variable, it can take on one value resp. a series of values while a script is progressing. The values are assigned by statements with syntax

`Set` <Variablenname> `=` <Value>

<Value> means any (String valued) expression. 

Examples (For Examples see <<opsi-winst-string>>):

[source,winst]
----
Set $OS$ = GetOS
Set $NTVersion$ = "nicht bestimmt"

if $OS$ = "Windows_NT"
  Set $NTVersion$ = GetNTVersion
endif

DefVar $Home$
Set $Home$ = "n:\home\user name"
DefVar $MailLocation$
Set $MailLocation$ = $Home$ + "\mail"
----

[[opsi-winst-strvar-usage]]
==== Use of variables in String expressions

In primary sections of a wInst script, a variable "holds" a value. When it is declared it is initialized with the empty String "".  When a new value is assigned to it via the `set` command, it represents this value. 

In a primary section a variable can replace any String expression resp. can be  a component of a String expression, e.g. 
[source,winst]
----
Set $MailLocation$ = $Home$ + "\mail"
----

In a primary section the variable name denotes an object that represents a string, If we add the variable we mean that the underlying string shall be added somehow.

This representational chain is shortcut in a secondary section. Just the variable name now stands for the string. 

[[opsi-winst-strvar-in-sections]]
==== Secondary vs. primary sections

When a secondary section is loaded and wInst starts its interpretation the sequence of chars of a variable name is directly replaced by the value of the variable.

Example: +
A `copy` command in a files section shall copy a file to +
"+n:\home\user name\mail\backup+" +
kopiert werden.

We first set `$MailLocation$` to the directory above it:
[source,winst]
----
DefVar $Home$
DevVar $MailLocation$
Set $Home$ = "n:\home\user name"
Set $MailLocation$ = $Home$ + "\mail"
----

$MailLocation$ is now holding +
"+n:\home\user name\mail+"

In a primary section we may now express the directory +
´"n:\home\user name\mail\backup"´ +
by +
´$MailLocation$ + "\backup"´


The same directory has to be designated in a secondary section as: +
`"$MailLocation$\backup"`

A fundamental difference between the thinking of variables in primary vs. secondary sections is that, in a primary section, we can form an assignment expression like +
`$MailLocation$ = $MailLocation$ + "\backup"`

As usual, this means that `$MailLocation$` first has some initial value  and takes on a new value by adding some string to the initial value. The reference from the variable is dynamic, and may have a history. 

In a secondary section any such expression would be worthless (and eventually  wrong), since `$MailLocation$` is bound to be replaced by some fixed string (at all occurrences virtually in the same moment).

[[opsi-winst-lstvar]]
=== Stringlist Variables

Variables for string lists must be declared in a DefStringList statement, e.g.
[source,winst]
----
DefStringList SMBMounts
----

A string list can serve e.g. as container for the captured output of a shell program. The collected strings can be manipulated in a lot of ways. In detail this will be treated in the section on string list processing (see section <<opsi-winst-stringlist>>).

CAUTION: Wenn (geschachtelte) Sub-Sektionen in externe Dateien ausgelagert werden, müssen die aufgerufenen Sekundären Sektionen üblicherweise in der Datei untergebracht werden, aus der sie aufgerufen werden. Je nach verwendeter Komplexität des Syntax müssen sie evtl. *zusätzlich* auch in der Hauptdatei untergebracht werden.


[[opsi-winst-prim-section]]
== Syntax and Meaning of Primary Sections of a  wInst Script 

As shortly presented in chapter 4 the Actions section of a script can be regarded as a the main method of the  wInst script and describes the global processing sequence. It may call subroutines - the  Sub sections which may then recursively call Sub sections themselves.

The following sections explain syntax and use of the primary sections of a wInst script.

[[opsi-winst-prim-section-kinds]]
=== Primary Sections

There are possibly three kinds of primary sections in a script

* an `Initial` section (may be omitted),

* an `Action` section, 

* any number of `Sub` sections

`Initial` and `Action` section are syntactically equivalent (but Initial has to keep the first place). By convention,  in the Initial section some parametrizations of the script execution (e.g. the loglevel) are made. The Action section can be regarded as the main program in a  wInst script. It contains the sequence of  actions that are controlled by the script.

Sub sections are as well syntactically equivalent. But they are a called from the Action section. Then, they can call themselves `Sub` sections. 

A `Sub` section is determined by creating a name that begins with "Sub", e.g.  `Sub_InstallBrowser`. By writing its name in the  Action section we produce a call to the  Sub section. The meaning of this call is defined by the content of the  section in the script that begins with the bracketed name, in the example  `[Sub_InstallBrowser]`

NOTE: Subsections of second and higher order cannot host internal sections. Instead, their procedure calls must refer to sections defined in the main script file or defined as external sections (cf. <<opsi-winst-commands-subcall>>).

CAUTION: If (nested) sub sections are externalized to external files, the called sections has to be in that file where they are called from. According to the complexity of the script they may sometimes have to be placed *also* in the main file.

[[opsi-winst-params]]
=== Parametrizing wInst

Typical entries of an Initial section set some the wInst execution attributes. The following example shows how error responses may be configured:

[[opsi-winst-params-example]]
==== Example
[source,winst]
----
[Initial]
SetLogLevel=5
ExitOnError=false
ScriptErrorMessages=on
TraceMode=off
----
This means that: 

* logging level is set to 5

* when an error occurs wInst shall try to continue script execution

* if a script syntax error occurs it shall be communicated (this will be in a special window)

* we don't want to activate the trace mode for script execution (which would mean that we are asked after each program step  if we want to continue).

The above values are the default values, wInst will assume them if these statements are missing.

To the details of syntax and meaning: 

[[opsi-winst-params-loglevel]]
==== Specification of Logging Level

CAUTION: The old function `LogLevel=` is deprecated since wInst version 4.10.3. For backward compatibility reasons Loglevels ste by this old function will be increased by 4 before they are used.

There are two syntactical variants for specifying  the logging level:

SetLogLevel = <number> 
SetLogLevel = <String expression> 
I.e. the number can be given as an integer value or as a string expression (cf. section 6.3). In the second case, wInst tries to evaluate the string expression as a number.
There exist ten levels from 0 up to  9. 

Es gibt zwei ähnliche Varianten, um den Loglevel zu spezifizieren:

`SetLogLevel =` <number> 

`SetLogLevel =` <String expression>

I.e. the number can be given as an integer value or as a string expression (cf. section <<opsi-winst-string>>). In the second case, wInst tries to evaluate the string expression as a number.

There exist ten levels from 0 up to  9. 
****
                0 = nothing (absolute nothing)
                1 = essential ("essential information")
                2 = critical (unexpected errors that my cause a program abort)
                3 = error (Errors that don't will abort the running program)
                4 = warning (you should have a look at this)
                5 = notice (Important statements to the program flow)
                6 = info (Additional Infos)
                7 = debug (important debug messages)
                8 = debug2 (a lot more debug informations and data)
                9 = confidential (passwords and other security relevant data)

****

[[opsi-winst-params-required-winst]]
==== Required '{opsi-winst}' Version

Die Anweisung 

`requiredWinstVersion`   <RELATIONSSYMBOL>   <ZAHLENSTRING>

e.g.
[source,winst]
----
requiredWinstVersion >= "4.3"
----

makes wInst check if  the desired version state is given. Otherwise an error message windows pops up. 

This feature exists since wInst version 4.3. For an earlier version, the statement is unknown, and the statement itsself is a syntactical error which will be indicated by syntax error window (cf. the following section). Therefore the statement can be used independently of the currently used  wInst version as long as the required version is at least version 4.3.

[[opsi-winst-params-errors]]
==== Reacting on Errors

There are two kinds of errors which are treated in different ways:

. illegal statements which cannot be interpreted by wInst (syntactical errors),

. failing statements which cannot be executed because of  external, objective reasons (execution errors).

In principal, syntactical errors are indicated by a pop up window for immediate correction, execution errors are logged in a log file to be analysed later.

The behaviour of wInst when it recognizes a syntactical error is defined by the configuration statement

* `ScriptErrorMessages =` <boolean value> +
If the value is true  (default), syntactical errors trigger a pop up window with some informations on the error. This kind of errors is not recorded in the log file. The log file shall keep informations on the real execution of  a syntactical correct script. +
The boolean value may be true or false. Delimiters  on or off can be used as well.

There two configuration options for execution errors.

* `ExitOnError =` <boolean value> +
This statement defines if  the script execution shall terminate when an error occurs. If the value is true or yes  the program will stop execution, otherwise errors are just logged (default).

* `TraceMode =` <boolean value> +
In  TraceMode (default  false) every log file entry will additionally be shown in message window with an O.K. button.

[[opsi-winst-params-stayontop]]
==== Staying On Top 

*  `StayOnTop =` <Wahrheitswert>

With StayOnTop = true (or  = on) we request, that  - in batch mode -  the wInst window be on top on the windows which share the screen. That means it should be visible in the "foreground" as long as no other window having the same status wins. 
 
CAUTION: According to the system manual the value cannot be changed while the program is running.  But it seems that we can give a new value to it once. 

`StayOnTop` has default false in order to avoid that some other process raises an error message which eventually can not be seen if  wInst keeps staying on top.

[[opsi-winst-string]]
=== String Expressions, String Values, and String Functions

A String expression can be

* an elementary String value
* a nested String value
* a String variable
* the concatenation of other String expressions
* a String valued function call

[[opsi-winst-string-elementary]]
==== Elementary String Values
An elementary String value is any sequence of characters that is enclosed in double or single citations marks, formally:

'"<sequence of characters>"'

or

''<sequence of characters>''

Example:
[source,winst]
----
DefVar $ExampleString$
Set $ExampleString$ = "my Text"
----

[[opsi-winst-string-nested]]
==== Strings in Strings (Nested String Values)

If the sequence of chars itself contains citation marks we have to use the other kind of citation marks to enclose it:
[source,winst]
----
DefVar $citation$
Set $citation$ = 'he said "Yes"'
----

If the sequence of  chars is containing both kinds of citation marks we must use the following special expression: +
`EscapeString:` <sequence of characters> +
E.g. we can write: +
[source,winst]
----
DefVar $Meta_citation$
Set $Meta_citation$ = EscapeString: Set $citation$ = 'he said "Yes"'
----
Then the variable `$Meta_citation$` will exactly contain the complete sequence of chars that follows the colon after "EscapeString" (including the blank). Such, `$Meta_citation$` will contain the complete statement: +Set $citation$ = 'he said "Yes"'+ 

[[opsi-winst-string-concat]]
==== String Concatenation 

String concatenation is  written using the addition sign ("+") 

<String expression> `+` <String expression>

Example:
[source,winst]
----
DefVar $String1$
DefVar $String2$
DefVar $String3$
DefVar $String4$
Set $String1$ = "my text"
Set $String2$ = "and"
Set $String3$ = "your text"
Set $String4$ =  $String1$ + " " + $String2$ + " " + $String3$
----

$String4$ then has value "my text and your text".

[[opsi-winst-string-expressions]]
==== String Variables

A String variable in a primary section "contains" a String value. In an String expression, it can always substitute an elementary string. For how to define and set String variables cf. section <<opsi-winst-strvar>>.

The following sections present the variety of string functions. 

[[opsi-winst-string-functions-os]]
==== String Functions which Return the OS Type

* GetOS +
The function tells which type of operating system is running. It returns one of the following values: +
"Windows_16" +
"Windows_95" (including Windows 98 and ME) +
"Windows_NT" (including Windows 2000 and XP) +
"Linux" +

* GetNtVersion +
A Windows NT operating system is characterized by a the Windows type number and a subtype number. GetNtVersion  returns the precise subtype name. Possible values are +
"NT3" +
"NT4" +
"Win2k" (Windows 5.0) +
"WinXP" (Windows 5.1) +
"Windows Vista" (Windows 6) +
If the NT operating system has higher versions as 6 or there are version not explicitly known the function returns "Win NT" and the complete version number (5.2, ... resp. 6.0 ..) . E.g. for Windows Server 2003 R2 Enterprise Edition, we get +
"Win NT 5.2" +
If the operating system is no Windows NT system the function returns the error value +
"No OS of Windows NT type"

* GetMsVersionInfo +
returns for systems of type Windows NT the Microsoft version info as indicated by the API, e.g. a Windows XP system produces the result + 
"5.1"

.Windows Versions
[options="header"]
|=======================
|GetMsVersionInfo|Windows Version
|5.0    |Windows 2000
|5.1    |Windows XP (Home, Prof)
|5.2    |XP 64 Bit, 2003, Home Server, 2003 R2
|6.0    |Vista, 2008
|6.1    |Windows 7, 2008 R2
|=======================
see also `GetMsVersionMap`

*  `GetSystemType` +
checks the installed Windows OS if it can be assumed that the system is 64 Bit. In this case the value is  '64 Bit System' otherwise 'x86 System'.

[[opsi-winst-string-functions-env]]
==== String Functions for Retrieving Environment or Command Line Data


The function reads and returns the momentary value of a system environment variable. 

E.g., we can retrieve which user is logged in by EnvVar ("Username").
ParamStr
The function passes the the parameter string of  the wInst command line i.e. the command line parameter which is indicated by /parameter. If there is no such parameter  ParamStr returns the empty string.
GetLastExitCode
returns the exit code (also called ErroLevel) of the last Winbatch call.
GetUserSID(<Windows Username>)
returns the SID for a given user (possibly with domain prefix in the form 
DOMAIN\USER).

*  `EnvVar (` <string>`)` +
The function reads and returns the momentary value of a system environment variable. E.g., we can retrieve which user is logged in by `EnvVar ("Username")`.

*  `ParamStr` +
The function passes the the parameter string of the wInst command line i.e. the command line parameter which is indicated by /parameter. If there is no such parameter  ParamStr returns the empty string.

*  `GetLastExitCode` +
returns the exit code (also called ErroLevel) of the last Winbatch call.

*  `GetUserSID(`<Windows Username>`)` +
returns the SID for a given user (possibly with domain prefix in the form 
DOMAIN\USER).

* `GetUsercontext` +
returns the string which was given to the wInst by the optional parameter `/usercontext`. IF this parameter was not userd the returned string is empty.

[[opsi-winst-string-functions-reg]]
==== Reading Values from the Windows Registry and Transforming Values into Registry Format

*  `GetRegistryStringValue (`<string>`)` +
tries to interpret the passed String value as an expression of format +
'[KEY] X' +
Then, the function tries to open the registry key `KEY`, and, in case it succeeds, to read and return the String value that belongs to the registry variable name `X` . 

E.g. 
[source,winst]
----
GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] Shell")
----

usually yields  "Explorer.exe", the default Windows shell program.

If there is no registry key `KEY` or the variable `X` does not exist the function produces a warning message in the log file and returns the empty string.

For example:
If we made a 'standard entry' with the value +standard entry+ at the key +HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0+, we will get with
[source,winst]
----
Set  $CompValue$ = GetRegistryStringValue32 ("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0]")
----

the following log:
[source,winst]
----
Registry started with redirection (32 Bit)
Registry key [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\test-4.0]  opened
Key closed
The value of the variable "$CompValue$" is now: "standard entry"
----


*  `GetRegistryStringValue32(`<string>`)` ->	siehe <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValue64(`<string>`)` ->	siehe <<opsi-winst-64bit,Chapter 64 Bit>>

*  `GetRegistryStringValueSysNative(`<string>`)` ->	siehe <<opsi-winst-64bit,Chapter 64 Bit>>


*  `RegString(`<string>`)` +
is useful for transforming path names into the format which is used in the Windows registry. That is, any backslash is duplicated. E. g., +
[source,winst]
----
RegString ("c:\windows\system\") 
----
yields +
'"c:\\windows\\system\\"'

[[opsi-winst-string-functions-ini]]
==== Reading Property Values

For historical reasons, there are three functions for reading values from configuration files which have ini file format. Since opsi 3.0 the specific product properties are retrieved from the opsi configuration demon (that may fetch it from a configuration file or from any other backend data container).

In detail: +
Ini file format means that the file is a text file and is composed of "sections" each containing key value pairs:
[source,winst]
----
[section1]
Varname1=Value1
Varname2=Value2
...
[section2]
...
----

The most general function reads the value belonging to some key in some section of some ini file. Any parameter can be given as an arbitrary String expression:

*  `GetValueFromInifile (`<FILE>, <SECTION>, <KEY>, <DEFAULTVALUE>`)` +
The function tries to open the ini file `FILE`, retrieve the requested `SECTION` and find the value belonging to the specified `KEY` which the function will return. If any of these operations fail `DEFAULTVALUE` is returned.

The second function borrows its syntax from the ini file format itself, and may sometimes be easier to use. But since this syntax turns complicated in more general circumstances it is deprecated. The syntax reads:

*  `GetIni (` <Stringausdruck> [ <character sequence> ] <character sequence> `)` +
(Deprecated) The <String expression> is interpreted as file name, the first <character sequence> as  section name, the second as key name.  

[[opsi-winst-string-functions-prodprop]]
==== Produkt Properties auslesen

*  `GetProductProperty (` <PropertyName>, <DefaultValue>`)` +
where  $PropertyName$ and $DefaultValue$ are String expressions. 
If wInst is connected to the opsi configuration service the product property is retrieved from the service. 
If the wInst is not connected to the service or for other reasons the the call fails, the given +<DefaultValue>+ will be returned.

The product properties can be used to configure variants of an installation.

E.g. the opsi UltraVNC network viewer installation may be configured using the options 

* viewer = <yes> | <no>

* policy = <factory_default> | 

The installation script branches according to the chosen values for these options which can be retrieved by 
[source,winst]
----
GetProductProperty("viewer", "yes")
GetProductProperty("policy", "factory_default")
----


*  `IniVar(`<PropertyName>`)` +
(deprecated: use GetProductProperty)

[[opsi-winst-string-functions-hosts]]
==== Retrieving Data from etc/hosts

*  `GetHostsName(`<string>`)` +
returns the host name to a given IP address as it is declared in the local hosts file. If  the operating system is "Windows_NT" (according to environment variable OS)  "%systemroot%\system32\drivers\etc\"  is assumed as host file location, otherwise  "C:\Windows\".

*  `GetHostsAddr(`<string>`)` +
tells the IP address to a given host or alias name.

[[opsi-winst-string-functions-handling]]
==== String processing

*  `ExtractFilePath(`<string>`)` +
interprets the passed String value as file or path name and returns the path part (the string up to the last "\", including it).

*  `StringSplit (`STRINGWERT1, STRINGWERT2, INDEX`)` +
(deprecated: use `splitString` / `takestring`)

*  `takeString(`<index>,<list>`)` +
returns from a string list <list> the string with the index <index>. +
Often used in combination with `splitstring`:
`takeString(`<index>, `splitString(`<string1>, <string2>`)` +
(see also <<opsi-winst-stringlist>>). +
The result is produced by slicing <string1> where each slice is delimited by an occurrence of <string2>, and then taking the slice with index <index> (where counting starts with 0).

Example:
[source,winst]
----
takeString(3, splitString ("\\server\share\directory",  "\"))
----

returns '"share"', +
the given string slpitted at "\" returns the string list: +
Index 0 - "" (empty string), because there is nothing before the first "\" +
Index 1 - "" (empty string), because there is nothing before the second "\" +
Index 2 - "server" +
Index 3 - "share" +
Index 4 - "directory"

`takestring` counts downward, if the index is negative, starting with the number of elements. Therefore,
[source,winst]
----
takestring(-1, $list1$)
----

denotes the last element of String list $list1$.

*  `SubstringBefore(`<string1>, <string2>`)` +
(deprecated: use `splitString` / `takestring`)
yields the sequence of characters of stringValue1 up to the beginning of stringValue2. +
Example:
[source,winst]
----
SubstringBefore ("C:\programme\staroffice\program\soffice.exe", "\program\soffice.exe")
----
returns '"C:\programme\staroffice"'.

*  `takeFirstStringContaining(`<list>,<search string>`)` +
returns the first string from <list> which contains <search string>. +
Retruns a empty string if no matching string is found.

*  `Trim(`<string>`)` +
cuts leading and trailing white space from <string>.

*  `HexStrToDecStr(`<string>`)` +
returns the decimal representation of the input string if this was the hexadecimal representation of an integer. Leading chars like '0x' or '$' will be ignored. In case of a converting error the function returns a empty string.

*  `DecStrToHexStr(`<string>`)`+
returns the hexadecimal representation of the input string if this was the decimal representation of an integer. In case of a converting error the function returns a empty string.

*  `base64EncodeStr(`<string>`)` +
returns the base64 encoded value of <string>.

*  `base64DecodeStr(`<string>`)` +
returns the base64 decoded value of <string>.

==== Weitere String-Funktionen

*  `RandomStr` + 
returns a random String of  length 10 where upper case letters, lower case letters and digits are mixed (for creating passwords). More exactly: 2 lower case chars, 2 upper case chars, 2 special chars and 4 digits. The possible special chars are: +
'!','$','(',')','*','+','/',';','=','?','[',']','{','}','ß','~','§','°'

*  `CompareDotSeparatedNumbers(`<string1>, <string2>`)` +
compares two strings of the form <number>.<number>[.<number>[.<number>]] +
It returns "0" if the strings are equal, "1" if <string1> is higher and "-1" if <string1> is lower than <string2>.

Example: +
The Code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedNumbers"
	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.31.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

leads to the following log:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedNumbers

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is equal to 1.2.3.4.5

Else
EndIf

Set  $string1$ = "1.2.31.4.5"
  The value of the variable "$string1$" is now: "1.2.31.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.31.4.5 is higher then 1.2.13.4.5

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedNumbers($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is lower then 1.2.13.4.5

Else
EndIf
----

*  `CompareDotSeparatedStrings (`<string1>, <string2>`)` +
compares two strings of the form <string>.<string>[.<string>[.<string>]] +
It returns "0" if the strings are equal, "1" if <string1> is higher and "-1" if <string1> is lower than <string2>. The function is not case sensitive.

Example: +
The Code:
[source,winst]
----
	comment "Testing: "
	message "CompareDotSeparatedStrings"
	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.b.c.3"
	set $string2$ = "1.A.B.C.3"
	set $ConstTest$ = "0"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is equal to "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.cb.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.a.ab.c.3"
	set $string2$ = "1.a.b.c.3"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
	
	set $string1$ = "1.2.13.4.5"
	set $string2$ = "1.2.3.4.5"
	set $ConstTest$ = "-1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is lower then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif

	set $string1$ = "1.2.3.4.5"
	set $string2$ = "1.2.13.4.5"
	set $ConstTest$ = "1"
	set $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
	if ($ConstTest$ = $CompValue$)
		comment "passed"
		comment $string1$+" is higher then "+$string2$
		comment "using CompareDotSeparatedStrings give wrong results on numbers"
	else
		set $TestResult$ = "not o.k."
		LogWarning "failed"
	endif
----

leads to the following log:
[source,winst]
----
comment: Testing: 
message CompareDotSeparatedStrings

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.b.c.3"
  The value of the variable "$string1$" is now: "1.a.b.c.3"

Set  $string2$ = "1.A.B.C.3"
  The value of the variable "$string2$" is now: "1.A.B.C.3"

Set  $ConstTest$ = "0"
  The value of the variable "$ConstTest$" is now: "0"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "0"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.b.c.3 is equal to 1.A.B.C.3

Else
EndIf

Set  $string1$ = "1.a.cb.c.3"
  The value of the variable "$string1$" is now: "1.a.cb.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.cb.c.3 is higher then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.a.ab.c.3"
  The value of the variable "$string1$" is now: "1.a.ab.c.3"

Set  $string2$ = "1.a.b.c.3"
  The value of the variable "$string2$" is now: "1.a.b.c.3"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.a.ab.c.3 is lower then 1.a.b.c.3

Else
EndIf

Set  $string1$ = "1.2.13.4.5"
  The value of the variable "$string1$" is now: "1.2.13.4.5"

Set  $string2$ = "1.2.3.4.5"
  The value of the variable "$string2$" is now: "1.2.3.4.5"

Set  $ConstTest$ = "-1"
  The value of the variable "$ConstTest$" is now: "-1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "-1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.13.4.5 is lower then 1.2.3.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf

Set  $string1$ = "1.2.3.4.5"
  The value of the variable "$string1$" is now: "1.2.3.4.5"

Set  $string2$ = "1.2.13.4.5"
  The value of the variable "$string2$" is now: "1.2.13.4.5"

Set  $ConstTest$ = "1"
  The value of the variable "$ConstTest$" is now: "1"

Set  $CompValue$ = CompareDotSeparatedStrings($string1$, $string2$)
  The value of the variable "$CompValue$" is now: "1"

If
  $ConstTest$ = $CompValue$   <<< result true
  ($ConstTest$ = $CompValue$)   <<< result true
Then
  comment: passed
  comment: 1.2.3.4.5 is higher then 1.2.13.4.5
  comment: using CompareDotSeparatedStrings give wrong results on numbers

Else
EndIf
----

[[opsi-winst-string-functions-license]]
==== (String-) Functions for Licence Management

*  `DemandLicenseKey(`poolId [, productId [,windowsSoftwareId]]`)` +
asks the opsi service via the function getAndAssignSoftwareLicenseKey for a reservation of a licence for the client. +
The pool from which the licences is taken may be explicitly given by its ID or is identified via an associated product ID or Windows Software Id (possible, if these associations are defined in the licences configuration). +
'poolId', 'productId', 'windowsSoftwareId' are Strings (resp. String expressions). +
If no 'poolId' is explicitly given, the first parameter has to be an empty String  "". The same procedure is done with other not explicit given Ids. +
The function returns the licence key that is taken from the pool.

Examples:
[source,winst]
----
set $mykey$ = DemandLicenseKey ("pool_office2007")
set $mykey$ = DemandLicenseKey ("", "office2007")
set $mykey$ = DemandLicenseKey ("", "", "{3248F0A8-6813-11D6-A77B}")
----

*  `FreeLicenseKey (`poolId [, productId [,windowsSoftwareId]]]`)` +
asks the opsi service via the function freeSoftwareLicenseKey to release the current licence reservation.
The syntax is analogous to the syntax for `DemandLicenseKey`

Example:
[source,winst]
----
DefVar $opsiresult$
set $opsiresult$ = FreeLicenseKey ("pool_office2007")
----

'$opsiresult$' becomes the empty String, if no error occurred, and, if an error occurred, the error info text.

[[opsi-winst-string-functions-serviceerrors]]
==== Retrieving Error Infos from Service Calls

*  `getLastServiceErrorClass` +
returns, as its name says, the class name of the error information of the last service call. If the last service call did not produce an error the function returns the value "None".

*  `getLastServiceErrorMessage` +
returns the message String of the last error information resp. "None". +
Since the message String is more likely to be changed, it is recommended to base script logic on the class name.

Example:
[source,winst]
----
if getLastServiceErrorClass = "None"
    comment "kein Fehler aufgetreten"
endif
----

[[opsi-winst-stringlist]]
=== String List Functions and String List Processing

A String list (or a String list value) is a sequence of String values. For this kind  of values we have the variable of type String list. They are defined by the statement

`DefStringList` <VarName>

A String list value may be assigned to String list variable:

`Set` <VarName> `=` <StringListValue>

String list values can be given only as results of String expressions. There are many ways to create or capture String lists, and many options for  processing them, often yielding new String lists. They are presented in the following subsections. 

For the following examples we declare a String list variable '$list1$':

[source,winst]
----
DefStringList $list1$
----

If we refer to variables named like  String0, StringVal, .. it is meant that these represent any String expressions.

We start with a special and rather useful kind of String lists: 'maps' – also called hashes or associative arrays – which consist of a lines of the form 'KEY'='VALUE'. In fact, each map should establish a function which associates a 'VALUE' to a 'KEY', and any 'KEY' should occur at most once as the first part of a line (whereas different 'KEY's may be associated with identical 'VALUE' parts).

[[opsi-winst-stringlist-maps]]
==== Info Maps

*  `getMSVersionMap` +
get OS informations and wrties them to hash map string list. +
There are the folowinging keys:
* major_version
* minor_version
* build_number
* platform_id
* csd_version
* service_pack_major
* service_pack_minor
* suite_mask
* product_type_nr
* 2003r2

The Results from  'suite_mask' and 'product_type_nr' are integers that can be build by 'or' operations of the following values.

product_type_nr
****
    0x0000001 (VER_NT_WORKSTATION)
    0x0000002 (VER_NT_DOMAIN_CONTROLLER)
    0x0000003 (VER_NT_SERVER)
****

SuiteMask
****
    0x00000001 (VER_SUITE_SMALLBUSINESS)
    0x00000002 (VER_SUITE_ENTERPRISE)
    0x00000004 (VER_SUITE_BACKOFFICE)
    0x00000008 (VER_SUITE_COMMUNICATIONS)
    0x00000010 (VER_SUITE_TERMINAL)
    0x00000020 (VER_SUITE_SMALLBUSINESS_RESTRICTED)
    0x00000040 (VER_SUITE_EMBEDDEDNT)
    0x00000080 (VER_SUITE_DATACENTER)
    0x00000100 (VER_SUITE_SINGLEUSERTS)
    0x00000200 (VER_SUITE_PERSONAL)
    0x00000400 (VER_SUITE_SERVERAPPLIANCE)
****

Example: +
The Code
[source,winst]
----
DefStringList $INST_Resultlist$
DefStringList $INST_Resultlist2$

message "getMSVersionMap"
comment "get value by winst function"
set $INST_Resultlist$ = getMSVersionMap
----

produces the following log:
[source,winst]
----
message getMSVersionMap
comment: get value by winst function

Set  $INST_Resultlist$ = getMSVersionMap
    retrieving strings from getMSVersionMap [switch to loglevel 7 for debugging]
        (string   0)major_version=5
        (string   1)minor_version=1
        (string   2)build_number=2600
        (string   3)platform_id=2
        (string   4)csd_version=Service Pack 3
        (string   5)service_pack_major=3
        (string   6)service_pack_minor=0
        (string   7)suite_mask=256
        (string   8)product_type_nr=1
        (string   9)2003r2=false
----

[NOTE]
==============================
Background infos for getMSVersionMap

* http://msdn.microsoft.com/en-us/library/ms724385%28VS.85%29.aspx
* http://msdn.microsoft.com/en-us/library/dd419805.aspx
* http://msdn.microsoft.com/en-us/library/ms724833%28VS.85%29.aspx

==============================

*  `getFileInfoMap(`<FILENAME>`)` +
retrieves the version infos built into the file  FILENAME and writes it to a Stringlist map.

At this moment, there exist the keys,

* Comments
* CompanyName
* FileDescription
* FileVersion
* InternalName
* LegalCopyright
* LegalTrademarks
* OriginalFilename
* PrivateBuild
* ProductName
* ProductVersion
* SpecialBuild
* Language name <index>
* Language ID <index>
* file version with dots
* file version
* product version

Usage: If we define and call
[source,winst]
----
DefStringList FileInfo
DefVar $InterestingFile$
Set $InterestingFile$ = "c:\program files\my program.exe"
set  FileInfo = getFileInfoMap($InterestingFile$)
----

we get the value associated with key "FileVersion" from the call 
[source,winst]
----
DefVar $result$
set $result$ = getValue("FileVersion", FileInfo)
----

(for the function getValue cf. section <<opsi-winst-stringlist-getstring>>).

Example: +
The code:
[source,winst]
----
set $InterestingFile$ = "%winstdir%\winst.exe"
if not (FileExists($InterestingFile$))
	set $InterestingFile$ = "%winstdir%\winst32.exe"
endif
set $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
----

produce the log:
[source,winst]
----
Set  $InterestingFile$ = "N:\develop\delphi\winst32\trunk\winst.exe"
  The value of the variable is now: "N:\develop\delphi\winst32\trunk\winst.exe"

If
    Starting query if file exist ...
  FileExists($InterestingFile$)   <<< result true
  not (FileExists($InterestingFile$))   <<< result false
Then
EndIf

Set  $INST_Resultlist$ = getFileInfoMap($InterestingFile$)
    retrieving strings from getFileInfoMap [switch to loglevel 7 for debugging]
        (string   0)Language name 0=Deutsch (Deutschland)
        (string   1)Language ID 0=1031
        (string   2)file version=1125942857039872
        (string   3)file version with dots=4.10.8.0
        (string   4)product version=1125942857039872
        (string   5)Comments=
        (string   6)CompanyName=uib gmbh (www.uib.de)
        (string   7)FileDescription=opsi.org
        (string   8)FileVersion=4.10.8.0
        (string   9)InternalName=
        (string  10)LegalCopyright=uib gmbh under GPL
        (string  11)LegalTrademarks=opsi
        (string  12)OriginalFilename=
        (string  13)PrivateBuild=
        (string  14)ProductName=opsi-winst
        (string  15)ProductVersion=4.0
        (string  16)SpecialBuild=
----

*  `getLocaleInfoMap` +
retrieves the system informations on the locale and writes it to a Stringlist map.

At this moment, there exist the keys:

* language_id_2chars (two-letter version of the system default language name)
* language_id (three-letter version of it, including subtype of language) inklusive der Sprachenuntertypen)
* localized_name_of_language
* English_name_of_language
* abbreviated_language_name
* native_name_of_language
* country_code
* localized_name_of_country
* English_name_of_country
* abbreviated_country_name
* native_name_of_country
* default_language_id
* default_language_id_decimal
* default_country_code
* default_oem_code_page
* default_ansi_code_page
* default_mac_code_page
* system_default_language_id	Hexadecimal Windows locale Id
* system_default_posix		Language_Region (Posix Style)
* system_default_lang_region	Language-Region (BCP 47 Style)

The system_default keys gives information about the language of the installed OS. The other keys give information about the locale of the GUI.

Example: +
The code:
[source,winst]
----
message "Locale Infos"
set  $INST_Resultlist$ = getLocaleInfoMap
----

produces e.g the log:
[source,winst]
----
message Locale Infos

Set  $INST_Resultlist$ = getLocaleInfoMap
    retrieving strings from getLocaleInfoMap [switch to loglevel 7 for debugging]
        (string   0)language_id_2chars=DE
        (string   1)language_id=DEU
        (string   2)localized_name_of_language=Deutsch (Deutschland)
        (string   3)English_name_of_language=German
        (string   4)abbreviated_language_name=DEU
        (string   5)native_name_of_language=Deutsch
        (string   6)country_code=49
        (string   7)localized_name_of_country=Deutschland
        (string   8)English_name_of_country=Germany
        (string   9)abbreviated_country_name=DEU
        (string  10)native_name_of_country=Deutschland
        (string  11)default_language_id=0407
        (string  12)default_language_id_decimal=1031
        (string  13)default_country_code=49
        (string  14)default_oem_code_page=850
        (string  15)default_ansi_code_page=1252
        (string  16)default_mac_code_page=10000
        (string  17)system_default_language_id=0407
        (string  18)system_default_posix=de_DE
        (string  19)system_default_lang_region=de-DE
----

Usage: If we define and call
[source,winst]
----
DefStringList $languageInfo$
set  $languageInfo$ = getLocaleInfoMap
----

we get the value associated with key "language_id_2chars" from the call 
[source,winst]
----
DefVar $result$
set $result$ = getValue("language_id_2chars", $languageInfo$)
----

(for the function getValue cf. section <<opsi-winst-stringlist-getstring>>). We may now write scripts using a construct like
[source,winst]
----
if getValue("language_id_2chars", languageInfo) = "DE"
    ; installiere deutsche Version
else 
   if getValue("language_id_2chars", languageInfo) = "EN"
    ; installiere englische Version
   endif
endif 
----

[NOTE]
==============================

Background infos for getLocaleInfoMap:

* http://msdn.microsoft.com/en-us/library/cc233968.aspx
* http://msdn.microsoft.com/en-us/library/0h88fahh.aspx
* bcp 47 validator: +
http://schneegans.de/lv/?tags=de-de-1996&format=text

* http://www.iana.org/assignments/language-subtag-registry
* http://www.the-localization-tool.com/?p=698

==============================

*  `getLocaleInfo` +
(deprecated): use `GetLocaleInfoMap` .

[[opsi-winst-stringlist-create-by-value]]
==== Producing String Lists from Strings

*  `createStringList (`String0, String1 ,... `)` +
forms a String list from the values of the listed String expressions. For example, by
[source,winst]
----
set $list1$ = createStringList ('a','b', 'c', 'd')
----

we get a list of the first four letters of the alphabet. 

The following two functions produce a String list by splitting some string:

*  `splitString (`<string1>, <string2>`)` +
generates the list of partial strings of <string1> (including empty strings) before resp. between the occurences of <string2>.  E.g., 
[source,winst]
----
set $list1$ = splitString ("\\server\share\directory",  "\")
----
defines the list  +
'"", "", "server", "share", "directory"'

*  `splitStringOnWhiteSpace (`<string>`)` +
slices StringVal by the "white spots" in it. E. g. 
[source,winst]
----
set $list1$ = splitString ("Status   Lokal     Remote         Netzwerk")
----
produces the list +
'"Status", "Lokal", "Remote", "Netzwerk"' +
no matter how many blanks or tabs constitute the white space between the words.

[[opsi-winst-stringlist-create-by-file]]
==== Loading Lines of a Text File into a String List

*  `loadTextFile (`<file name>`)` +
reads the file <file name> and generates the string list, that contains all lines of the file.


*  `loadUnicodeTextFile (`<file name>`)` +
reads the unicode text file <file name> and generates the string list, that contains all lines of the file. +
By this call, the strings are converted into the system default 8 bit code.

*  `getSectionNames (`<file name>`)` +
interprets the specified file as an inifile, looks for list of all lines of form +
'[<SectionName>]' +
and returns the pure section names (without brackets).

[[opsi-winst-stringlist-getstring]]
==== Simple String Values generated from String Lists
 
*  `composeString (`<string list>, <link string>`)` +
With this function, the elements of any String list can be glued to one another, mediated by a "glue string". +
E.g. if '$list1$' represents the list 'a', 'b', 'c', 'd', 'e' +
by 
[source,winst]
----
$line$ = composeString ($list1$, " | ")
----
we assign  the value  '"a | b | c | d | e".' to '$line$'.

*  `takeString(`<index>,<list>`)` +
E. g., if  $list1$ represents the list of the first five letters of the alphabet by +
[source,winst]
----
takeString (2, $list1$)
----
we get string "c" (since list counting starts with 0). +
Negative values of  index go downwards from the list count value. E.g., 
[source,winst]
----
takeString (-1, $list1$)
----
return the last list element, that is  "e".

*  `takeFirstStringContaining(`<list>,<search string>`)` +
returns the first string of the list which contains the <search string>. +
Returns an empty string if no matching string was found.

*  `getValue (`<key>, <list>`)` +
This function tries to interpret a String list as list of lines of the form 
'key=value' +
It looks for the first line, where the string <key> is followed by the equality sign, and returns the remainder of the line (the 'value', the string that starts after the equality sign). If there is no fitting line, it returns the string 'NULL'. +
The function is required for using the `getLocaleInfoMap` and `getFileVersionMap` string list functions (cf. Section <<opsi-winst-stringlist-maps>>).

*  `count (`<list>`)` +
returns the number of elements of the string list <list> as string. +
e.g. for $list1$ composed as +
'a', 'b', 'c', 'd', 'e' +
`count ($list1$)` has the value "5".

[[opsi-winst-stringlist-create-by-section]]
==== Producing String Lists from wInst Sections

*  `retrieveSection (`section name`)` +
gives the lines of the specified section as string list.

*  `getOutStreamFromSection (`section name`)` +
invokes the section and – at this moment implemented only for `DosInAnIcon` (`ShellInAnIcon`),`ExecWith` and `ExecPython` calls – captures the output to standard out and standard error of the invoked commands writing them into a string list. For example: +
[source,winst]
----
set $list$ = getOutStreamFromSection ('DosInAnIcon_netuse')

[DosInAnIcon_netuse]
net use
----
`$list1$` contains among some surrounding stuff the list of all mounted shares of a PC. 


*  `getReturnListFromSection (`section name`)` +
For some section types - at this moment implemented only for `XMLPatch` sections and `opsiServiceCall` sections -  there is a specific `return` statement which yields some result of the execution of the section (assumed to be of String list type).  +
E.g. we may use the statement 
[source,winst]
----
set list1 = getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----
to get a specific knot list of the XML file `mimetypes.rdf`. (More info to XMLPatch sections at <<opsi-winst-xmlpatch>> in this manual). +
Or the list of opsi clients is produced by the reference to a opsi service call: +
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")

[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

[[opsi-winst-stringlist-transform]]
==== Transforming String Lists

*  `getSubList (`<Startindex>, <Endindex>, <list> `)` +
returns a partial list of a given list. +
E.g., if list represents the list of letters 'a', 'b', 'c', 'd', 'e', by the statement:
[source,winst]
----
set $list1$ = getSubList(1 : 3, $list$)
----
we get the partial list 'b', 'c', 'd' . Begin index as well as end index have to be interpreted as the index of  the first and last included list elements. The counting starts with 0. +
Default start index is 0, default end index is the index of the last element of the list. +
Therefore, (for  the above defined  list1) the command +
[source,winst]
----
set $list1$ = getSubList(1 : , $list$)
----
yields the list 'b', 'c', 'd', 'e'. 
[source,winst]
----
set $list1$ = getSubList(:, $list$)
----
produces a copy of the original list. +
It is possible to count backwards in order to determine the last index: 
[source,winst]
----
set $list1$ = getSubList(1 : -1, $list$)
----
defines the list of elements starting with the first and ending with the second to last element of the list –  in the above example we again get list 'b', 'c', 'd'.

*  `getListContaining(`<list>,<search string>`)` +
returns the first string from <list> which contains <search string>. Returns empty string if <seach string> is not found.

*  `takeFirstStringContaining(`<list>,<search string>`)` +
Liefert den ersten String von <list> welcher den <search string> enthält. + Liefert einen Leerstring wenn <search string> nicht gefunden wird.

*  `addtolist(`<list>,<string>`)` +
Appends <string> to the list <list>.

*  `addlisttolist(`<list1>,<list2>`)` +
Appends the list <list2> to the list <list1>.

*  `reverse (`<list>`)` +
produces the inverted list, +
if  $list$ is 'a', 'b', 'c', 'd', 'e', by +
[source,winst]
----
set $list1$ = reverse ($list$)
----
we get the $list1$ 'e', 'd', 'c', 'b', 'a'.

[[opsi-winst-stringlist-iteration]]
==== Iterating through String Lists

An important usage of string lists is based on the possibility that the script runs through all elements of a list executing some operation on each string element.

The syntax to define this repetition is:

*  `for` %s% `in` <list> `do` <one statement | sub section>

This expression locally defines a string variable %s% that takes one by one the values of the list elements.
<one statement> can be any single statement that can exist in a primary section or (and most interestingly) it may be a subsection call. The locally defined iteration index %s% exists in the whole context of statement, in particular in the subsection if statement is a subsection call. 

CAUTION: The replacement mechanism for %s% always works like that for constants:  The name of the variable is replaced by the element values. If we iterate through a list 'a','b','c' and the iteration index is named %s%, we get for %s% one by one  a, b, c  –   not the String values. To reproduce the original list elements we have to enclose %s% in citation marks.

Example: Let $list1$ be the list  'a', 'b', 'c', 'd', 'e', and $line$ a String variable. The statement  
[source,winst]
----
for %s% in $list1$ do   set $line$ = $line$ + "%s%"
----
iterates through the list elements internally executing
[source,winst]
----
$line$ = $line$ + "a"
$line$ = $line$ + "b"
$line$ = $line$ + "c"
$line$ = $line$ + "d"
$line$ = $line$ + "e"
----
Such, finally  line  has value 'abcde' . If we omitted the citation marks around %s% we would get a syntax error for each iteration step.

Please note: The note variable is only valid in the directly called procedure. If it is needed in sub programs of it its value must be transferred to a global variable.

[[opsi-winst-special-commands]]
=== Special Commands

*  `Killtask` <process>
tries to stop all processes that execute the program named by the string expression. +
E.g.
[source,winst]
----
killtask "winword.exe"
----

[[opsi-winst-commands-information]]
=== Commands for User Information and User Interaction 

*   `Message` <string expression> +
bzw. +
`Message` = <sequence of characters> +
lets  wInst  display the value of the String expression resp. the  sequence of chars in the batch window in the top information line. The text is kept as long as no new `message` is set. +
Example:
[source,winst]
----
Message "Installation von "+$productid$
----

*  `ShowMessageFile` <file name> +
interprets the String expression as text file name, tries to read the text und  show it in a user information window. Execution stops until the user confirms reading.  E.g. by a command like 
[source,winst]
----
ShowMessageFile "p:\login\day.msg"
----
one can realize a "Message of the Day" mechanism.

*  `ShowBitMap` [<image name>] [<inscription>] +
places the image denoted by the <image name> (in BMP, JPEG or PNG format, size 160x160 pixel) and shows the inscription.  
<image name> and <inscription> are String expressions. +
Example: +
[source,winst]
----
ShowBitmap "%scriptpath%\" + $ProductId$ + ".png"  "$ProductId$"
----

*  `comment` <string> or `comment` = <const string> +
writes the value of the String expression resp. the sequence of  characters into the log file.

* `LogError` <string> or `LogError` = <const string> +
writes additional error messages to the log file and increments the error counter by one.

* `LogWarning` <string> or `LogWarning` = <const string> +
writes additional warning messages to the log file and increments the warning counter by one.

*  `Pause` <string> or `Pause` = <const string> +
display the text given as a String expression or as a sequence of chars in a information window waiting until the user confirms the continuation. 

*  `Stop` <string> or `stop` = <const string> +
halt program execution if the user confirms it. The String expression resp. the (possibly empty) sequence of chars explain to the user what is supposed to be stopped.

*   `sleepSeconds` <Integer> +
breaks the program execution for <Integer> seconds.

*   `markTime` +
sets a time stamp for the current system time and logs it. 

*  `diffTime` +
logs the time passed since the last `marktime`.

[[opsi-winst-commands-if-else]]
=== Conditional Statements (if Statements)

In primary sections, the execution of  a statement or a sequence of  statements can be made dependent on some condition.

Example
[source,winst]
----
;Which Windows version?
DefVar $MSVersion$

Set $MSVersion$ = GetMsVersionInfo
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----

[[opsi-winst-commands-if-else-syntax]]
==== General Syntax

The syntax of the complete `if` statement is: +
`if` <condition> +
  <sequence of statements> +
`else` +
  <sequence of statements> +
`endif`

The `else` part may be omitted.

`if` statements may be nested. That is, in the sequence of statements that depend  on an if clause (no matter if inside the if or the else part) another if statement may occur. 

<condition> is a <Boolean expression> . A Boolean (or logical) expression can be constructed as a (String) value comparison, by Boolean operators, or by certain function calls which evaluate to true or false. Up to now these Boolean values cannot be explicitly represented in a wInst script).

[[opsi-winst-commands-if-else-bool-functions]]
==== Boolean Expressions

The String comparison (which is a Boolean expression) has the form +
+<String expression> <comparison sign> <String expression>+ +
where <comparison sign> is one of the signs +
`<`  `<=`  `=`  `>=`  `>`

String comparisons in wInst are case independent. 

Inequality must be expressed by a `NOT()` expression which is presented below.

There is as well a comparison expression for comparing Strings as (integer) numbers. If any of them cannot be converted to a number an error will be indicated. +
This number comparison expression has the same form as the String comparison but for an INT prefix of the comparison sign: +
+<String expression> INT<comparison sign> <String expression>+ +
Such, we can build expressions as
[source,winst]
----
if $Name1$ INT<= $Name2$
----

or
[source,winst]
----
if $Number1$ INT>= $Number2$
----

Boolean operators are `AND`, `OR`, and `NOT()` (case does not matter). If  b1, b2 and b3 are Boolean expressions the combined expressions +
b1 `AND` b2 +
b1 `OR` b2 +
`NOT(` b3 `)` +
are Boolean expressions as well denoting respectively the conjunction (`AND`), the disjunction (`OR`) and the negation (`NOT`).

A Boolean expression can be enclosed in parentheses (such producing a new Boolean expression with the same value).

The common rules of Boolean operator priority ("and" before "or") are at this moment not implemented.  An expression with more than one operator is interpreted from left to right. For clarity, in a Boolean expression that combines `AND` and `OR` operators parentheses should be employed, e.g. we should explicitly write
b1 `OR` (b2 `AND` b3) +
or +
(b1 `OR` b2) `AND` b3 +
The second  example describes what would be executed if there were no parentheses - whereas the common interpretation would run as the other line indicates.

Boolean operators can be conceived as special Boolean valued functions (the negation operator demonstrates this very clearly).

There are some more Boolean functions implemented. Every call of such a  function constitutes a Boolean expression as well:

*   `FileExists`(<file name>) +
returns 'true' if the denoted file or directory exists otherwise 'false'.  

*  `FileExists32`(<file name>)	see <<opsi-winst-64bit,Chapter 64 Bit support>>

*  `FileExists64`(<file name>)	see <<opsi-winst-64bit,Chapter 64 Bit support>>

*  `FileExistsSysNative`(<file name>) see <<opsi-winst-64bit,Chapter 64 Bit support>>

*  `LineExistsIn`(<line>, <file name>) +
returns 'true' if the text file denoted by <file name> contains a line as specified in the first parameter where each parameter is a String expression. Otherwise (or if the file does not exist) it returns 'false'.

*  `LineBeginning_ExistsIn`(<string>, <file name>)  +
returns 'true' if there is line that begins with <string> in the text file denoted by filename (each parameter being a string expression). Otherwise (or if the file does not exist) it returns 'false'.

*  `XMLAddNamespace`(<XMLfilename>, <XMLelementname>, <XMLnamespace>) +
inserts a XML namespace definition into the first XML element with the given name (if not existing). It gives back if an insertion took place. (The wInst XML patch section need the definitions of namespace.) +
The file must be formatted that an element tag has no line breaks in it.  
For an example, cf. cookbook section <<opsi-winst-cookbook-xmlnamespace>>. 

*  `XMLRemoveNamespace`(<XMLfilename>, <XMLelementname>, <XMLnamespace>)  +
removes the XML namespace definition from the XML element. It gives back if an removal took place. We need this to simulate that an original file is unchanged. For an example, cf. cookbook section <<opsi-winst-cookbook-xmlnamespace>>.

*  `HasMinimumSpace`(<Laufwerksname>, <Kapazität>) +
returns true if at least a capacity capacity is left on drive  drivename.  capacity as well as  drivename syntactically are String expressions. The capacity may be given as a number without unit specification (then interpreted as bytes) or with unit specifications "kB", "MB", or "GB" (case independent). +
Example:
[source,winst]
----
if not (HasMinimumSpace ("%SYSTEMDRIVE%", "500 MB"))
  LogError "Not enough space on %SystemDrive%, 500MB on drive %SystemDrive% needed"
  isFatalError
endif
----

*  `opsiLicenseManagementEnabled` +
returns 'true' if the opsi license management module is enabled.

[[opsi-winst-commands-subcall]]
=== Subprogram Calls

Statements in primary sections which refer to instructions declared elsewhere are subprogram calls.,

[source,winst]
----
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----
In this example the statement:
[source,winst]
----
sub_install_winXP
----
the '[sub_install_winXP]', welche dann im Skript an anderer Stelle nachzulesen ist als
[source,winst]
----
[sub_install_winXP]
Files_Kopieren_XP
WinBatch_SetupXP
----

E.g., the statement 
sub_install_winXP
"calls" the section titled [sub_install_winXP] which is placed somewhere else in the script. E.g. we may have
[sub_install_winXP]
Files_copy_XP
WinBatch_SetupXP
Generally, there are three ways to place the referred instructions:
(1) The most common target of  a sub program call is some other internal section in the very script file where the calling statement is placed (as in the example).
(2) We may put the referred instructions into another file which serves as an external section.
(3) Any String list can be used as list of instructions for a sub program call.
We describe the syntax of sub program calls in detail:

Anweisungen in primären Sektionen, die auf einen Programmtext an anderer Stelle verweisen, sollen hier Unterprogramm- oder Prozeduraufrufe heißen.
[source,winst]
----
if ($MSVersion$>="6")
     sub_install_win7
else
  if ( $MSVersion$ = "5.1" )
    sub_install_winXP
  else
    stop "not a supported OS-Version"
  endif
endif
----
So "ruft" in obigem Beispiel die Anweisung in der `Actions`-Sektion
[source,winst]
----
sub_install_winXP
----
die Sektion '[sub_install_winXP]', welche dann im Skript an anderer Stelle nachzulesen ist als
[source,winst]
----
[sub_install_winXP]
Files_Kopieren_XP
WinBatch_SetupXP
----

Weil es sich in diesem Beispiel um eine `Sub`-Sektion handelt, also immer noch um eine primäre Sektion, kann in ihr wiederum auf weitere Sektionen verwiesen werden, in diesem Fall auf die Sektionen '[Files_Kopieren_XP]' und '[WinBatch_Setup_XP]'.

Generell gibt es drei Wege um die genannten Anweisungen zu platzieren:

. Der gebräuchlichste Ort für den Aufruf eines `Sub`-Sektion ist eine weitere interne Sektion im Skript, wo die aufgerufene Befehle platziert werden (wie in dem Beispiel).

. Die bezeichneten Befehle können auch in einer andere Datei untergebracht werden, welche als externe Sektion läuft.

. Jede String-Liste kann als eine Befehlsliste für einen Sub-Programm Aufruf benutzt werden.

Zur Syntax der Sub-Programm Aufrufe im einzelnen:

[[opsi-winst-commands-subcall-components]]
==== Komponenten eines Unterprogrammaufrufs

Formal kann die Syntax wie folgt aufgerufen werden +
'<proc. type>(<proc. name> | <External proc. file> | <Stringlisten Funktion> )'

Diese Ausdrücke können durch einen oder mehrere Parameter ergänzt werden (ist vom Ablauftyp abhängig). 

Das bedeutet:  Ein Ablauf besteht aus drei Hauptbereichen.

Der erste Teil ist der Unterprogramm Typnamen. +
Beispiele für Typennamen sind `Sub` (Aufruf einer primären Sektion bzw. eines Unterprogramms des primären Typs) sowie `Files` und `WinBatch` (diese Aufrufe sind speziell für die zweite Sektion). +
Den kompletten Überblick über die existierenden `Sub`-Programmtypen sind am Anfang von  <<opsi-winst-commands-subcall,Kapitel "Aufrufe von Unterprogrammen">> genauer beschrieben.

Der zweite Teil bestimmt, wo und wie die Zeilen des Subprogramms gefunden werden. Dazu gibt es zwei Möglichkeiten:

. Das Sub-Programm ist eine Zeilenabfolge, die im sich ausführbaren Bereich des '{opsi-winst}' Skripts als interne Sektion befindet. Es wird ein eindeutiger Sektionsname (bestehend aus Buchstaben, Zahlen und einigen Sonderzeichen) hinzugefügt, um den Programmtyp näher zu beschreiben (ohne Leerzeichen). +
z.B. +
'sub_install_winXP' +
oder +
'files_copy_winXP' +
Sektionsnamen sind case insensitive wie jeder andere String. 

. Wenn der Programmtyp alleine steht, wird eine String-Liste oder ein String-Ausdruck erwartet. Wenn der folgende Ausdruck nicht als String-Listenausdruck aufgelöst werden kann (vgl. 3.) wird ein String-Ausdruck erwartet. Der String wird dann als Dateiname interpretiert. Der '{opsi-winst}' versucht die Datei als Textdatei zu öffnen und interpretiert die Zeilen als eine externe Sektion des beschriebenen Typs. +
Bsp.: +
`sub` '"p:\install\opsiutils\mainroutine.ins"' +
Es wird versucht die Zeile mainroutine.ins als Anweisung der Subsektion auszulesen. 

. Wenn der Ausdruck auf eine alleinstehenden spezifizierten Sektionstyp folgt, kann dieser als ein String-Listenausdruck aufgelöst werden. Die String-Listenkomponenten werden dann als ein Sektionsausdruck interpretiert. +
Dieser Mechanismus kann bspw. dazu verwendet werden, um eine Datei mit Unicode-Format zu laden und dann mit den üblichen Mechanismen zu bearbeiten:
[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----

Syntaktisch hat diese Zeile die drei Bestandteile: +
*  `registry`, die eigentliche Anweisung, die den Sektionstyp spezifiziert. +
*  `loadUnicodeTextFile (..)`, ein String-Listenausdruck, in dem näher beschrieben ist, wie man eine Zeile der `registry` Sektion bekommt. +
*  `/regedit`, Option als 2. Parameter (typspezifisch, s. das Folgende).

In diesem Beispiel gibt der Aufrufparameter ein Beispiel an für den dritten Teil eines Subsektionsaufrufs:

Der dritte Part eine Aufrufs umfasst spezielle Aufrufsoptionen. 
Referenzen für die Aufrufsoptionen beziehungsweise für eine genauere Beschreibung der Sektionsaufrufe finden sich in siehe <<opsi-winst-secsections,Kapitel "Sekundäre Sektionen">>.

[[opsi-winst-commands-reboot]]
=== Reboot-Steueranweisungen

Die Anweisung  `ExitWindows` dient zur Steuerung von Reboot, Shutdowns, u.ä. Vorgängen welche erst nach Beendigung des '{opsi-winst}' selbst durchgeführt werden. Die Benennung des Befehls und die Tatsache, das es `ExitWindows` nicht ohne Modifier gibt, ist historisch bedingt: Unter Windows 3.1 konnte man Windows beenden und zur DOS-Ebene zurück wechseln.

*  `ExitWindows /RebootWanted` + 
Abgekündigt: vermerkt eine Rebootanfrage eines Skriptes in der Registry, lässt aber das '{opsi-winst}' Skript weiterlaufen und weitere Skripte abarbeiten und rebootet erst, wenn alle Skripte durchgelaufen sind.
Eigentlich wird dieses Kommando jetzt als `ExitWindows /Reboot` behandelt (da ansonsten eine Installation fehlschlagen könnte, weil ein benötigtes Produkt nicht komplett installiert wurde).

*  `ExitWindows /Reboot` +
unterbricht eine Skriptfolge durch die Auslösung des Reboots nachdem der '{opsi-winst}' die Bearbeitung des laufenden Skripts beendet hat.

*  `ExitWindows /ImmediateReboot` +
unterbricht die normale Ausführung eines Skripts, an der Stelle, an der er aufgerufen wird. Nach dem der Befehl aufgerufen wurde, werden (außer if-Anweisungen) keine Anweisungen mehr ausgeführt und der Rechner rebootet. Dabei bleibt in der opsi-Umgebung der Actionrequest der das Skript aufgerufen hat bestehen.Dadurch wird gewährleistet, dass nach dem Neustart der '{opsi-winst}' wieder das Skript, dass abgebrochen wurde, startet. Das Skript sollte daher so konzipiert sein, dass die Ausführung nach dem Punkt der Unterbrechung fortgesetzt wird (andernfalls erhalten wir möglicherweise eine Endlosschleife...) vgl. das Beispiel in diesem Abschnitt.

*  `ExitWindows /ImmediateLogout` +
funktioniert ähnlich wie der Aufruf /ImmediateReboot, aber beinhaltet ein Beenden des '{opsi-winst}' (Beenden des Skriptes) statt einen Reboot.
Dies ist dann sinnvoll, wenn nachfolgend ein automatisches Login (eines anderen Users) folgen soll. Beachten Sie hierzu <<opsi-winst-cookbook-local-admin,Kapitel "Skript für Installationen im Kontext eines lokalen Administrators">>.

*  `ExitWindows /ShutdownWanted` +  
sorgt dafür, dass der PC nach Abschluss der Installation aller angefragten Produkte heruntergefahren wird. 

Wie man eine Markierung setzt, um sicherzustellen, dass das Skript nicht in eine Endlosschleife läuft, wenn `ExitWindows /ImmediateReboot` aufgerufen wird, demonstriert folgendes Codebeispiel:
[source,winst]
----
DefVar $Flag$
DefVar $WinstRegKey$
DefVar $RebootRegVar$

Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
Set $Flag$ = GetRegistryStringValue32("["+$WinstRegKey$+"] "+"RebootFlag")

if not ($Flag$ = "1")
  ;========================= 
  ; Anweisungen vor Reboot 

  Files_doSomething 

  ; Reboot initialisieren ...
  Set $Flag$ = "1"
  Registry_SaveRebootFlag
  ExitWindows /ImmediateReboot

else 
  ;========================= 
  ; Anweisungen nach Reboot

  ; Rebootflag zurücksetzen
  Set $Flag$ = "0"
  Registry_SaveRebootFlag

  ; die eigentlichen Anweisungen

  Files_doMore

endif


[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$Flag$"

[Files_doSomething]
; eine Sektion, die vor dem Reboot ausgeführt wird 

[Files_doMore]
; eine Sektion, die nach dem Reboot ausgeführt wird 
----

[[opsi-winst-commands-isfatalerror]]
=== Fehlgeschlagene Installation anzeigen

Passieren bei einer Installation Fehler, die zum Fehlschlagen der Installation führen, so sollte dies an den Server zurückgemeldet werden.

Um in einem '{opsi-winst}' Skript, eine Installation als gescheitert zu erklären, gibt es eine Ausdruck namens  +
`isFatalError` +
unterbricht die normale Ausführung eines Skripts, an der Stelle, an der er aufgerufen wird. Nach dem der Befehl aufgerufen wurde, werden (außer if-Anweisungen) keine Anweisungen mehr ausgeführt und als Skriptergebnis wird 'failed' zurückgeliefert. Wird dieser Befehl nicht aufgerufen, so ist das Skriptergebnis 'success'.

Es gibt *keinen* Automatismus innerhalb eines Winst-Skriptes, um zu einen 'failed' Ergebnis zu kommen. Sie müssen skriptgesteuert den Fehler selbst feststellen. Hierzu gibt Ihnen der '{opsi-winst}' einige Hilfsmittel.

Ein „fataler Fehler“ sollte zum Beispiel ausgelöst werden, wenn der Plattenplatz für die Installation nicht ausreicht:
[source,winst]
----
DefVar $SpaceNeeded$"
Set $SpaceNeeded$" = "200 MB"

if not(HasMinimumSpace ("%SYSTEMDRIVE%", $SpaceNeeded$"))
  LogError "Nicht genügend Platz. Erforderlich sind "+$SpaceNeeded$
  isFatalError
  ; beendet die Skriptausführung und setzt den Produktstaus auf failed
else
  ; die Installation wird gestartet 
  ; ...
endif
----

Fehler die von Funktionen des '{opsi-winst}' zurückgeliefert werden, werden in die Logdatei geschrieben und erhöhen den Fehlerzähler des {opsi-winst}. Dieser Fehlerzähler kann ausgewertet werden. So besteht auch die Möglichkeit, in einem kritischen Abschnitt eines Skripts festzustellen, ob Fehler bzw. wie viele Fehler aufgetreten sind (und abhängig hiervon ggf. isFatalError aufzurufen).

Dafür ist die Fehlerzählung zu Beginn des entsprechenden Abschnittes – z.B. vor einer Files-Sektion – mit +
`markErrorNumber` +
zu initialisieren. Die Zahl der Fehler, die ab dieser Stelle aufgetreten sind, kann dann mit dem Ausdruck +
`errorsOccuredSinceMark` + 
abgefragt werden. Z.B. kann man die Bedingung „es kam in diesem Abschnitt mindestens ein Fehler vor“ so formulieren: +
`if errorsOccuredSinceMark > 0` +
und, wenn es sinnvoll erscheint, daraufhin +
	`isFatalError` +
feststellen.

Sofern die Skriptanweisungen nicht direkt einen Fehler produzieren, jedoch aufgrund bestimmter Umstände eine Situation trotzdem als Fehlersituation gewertet werden soll, kann auch mittels der Anweisung `logError` eine Fehlermeldung generiert werden.
[source,winst]
---- 
markErrorNumber
; Fehler, die nach dieser Marke auftreten werden gezählt
; und werden als fatale Fehler gewertet

logError "test error"
; wir schreiben einen Kommentar "test error" in die Logdatei
; und die Fehleranzahl wird um eins erhöht
; für Testzwecke kann man diese Zeile auskommentieren 

if errorsOccuredSinceMark > 0
    ; die Skriptausführung wird so bald wie möglich beendet
    ; und setzt den Produktstatus auf "failed"

    isFatalError
    ; Kommentare können  noch geschrieben werden 

    comment "error occured"

else
    ; kein Fehler aufgetreten, gibt folgendes aus:

    comment "no error occured"
endif
----

[[opsi-winst-secsections]]
== Sekundäre Sektionen

Sekundäre Sektionen können ebenso wie die primäre Sektion aufgerufen werden, haben aber eine andere Syntax. Die Syntax der verschiedenen Sektionstypen ist jeweils aufgabenbezogen und lehnt sich möglichst eng an bekannte Kommandoformen für den jeweiligen Aufgabentyp an.

Sekundäre Sektionen sind spezifiziert für einen eingegrenzten Funktionsbereich. Dies bezieht sich auf das Objekt der Funktion z.B. das Dateisystem im Allgemeinen, die Windows Registry oder XML-Dateien. Einen spezielle Bedeutung haben die verschiedenen Varianten der Batch-Sektionen, die dazu dienen (beliebige) externe Programme oder Skripte aufzurufen. 

[[opsi-winst-files]]
=== Files-Sektionen

Files-Sektion dienen zum Dateihandling (Kopieren, Löschen). Anders als bei Ausführung der vergleichbaren Kommandozeilen-Befehle, werden die ausgeführten Operationen bei Bedarf genau protokolliert. Zusätzlich kann beim Kopieren von Bibliotheksdateien (z.B. dll-Dateien) auch die Dateiversion geprüft werden, so dass nicht neuere Versionen durch ältere Versionen überschrieben werden.

[[opsi-winst-files-example]]
==== Beispiele 

Eine Files-Sektion könnte etwa lauten:
[source,winst]
----
[Files_do_some_copying]
copy -sV "p:\install\instnsc\netscape\*.*" "C:\netscape"
copy -sV "p:\install\instnsc\windows\*.*" "%SYSTEMROOT%"
----

Mit diesen Anweisungen werden alle Dateien des Verzeichnisses 'p:\install\instnsc\netscape' in das Verzeichnis 'C:\netscape' kopiert, sowie alle Dateien von 'p:\install\instnsc\windows' in das Windows-Systemverzeichnis (welches das jeweils Gültige ist, steht automatisch in der {opsi-winst}-Konstante %SYSTEMROOT%).
Die Option `-s` bedeutet dabei, das alle Subdirectories mit erfasst werden, `-V` steht für das Einschalten der Versionskontrolle von Bibliotheksdateien.

[[opsi-winst-files-params]]
==== Aufrufparameter (Modifier)

In der Regel benötigt eine Files-Sektion beim Aufruf keinen Parameter. 

Es gibt jedoch eine spezielle Anwendung der Files-Sektion, bei der Zielpfad von Kopieraktionen automatisch bestimmt oder modifiziert wird, bei denen die  betreffende Files-Sektion mit dem Parameter

*  `/AllNTUserProfiles` bzw.
*  `/AllNTUserSendTo`

aufgerufen wird. +
Beide Varianten bedeuten: +
Die betreffende Files-Sektion wird je einmal für jeden NT-User ausgeführt. 
Bei Kopieraktionen in dieser Files-Sektion wird automatisch ein User-spezifisches Verzeichnis als Zielverzeichnis eingesetzt. 

Für alle anderen Aktionen steht eine Variable `%UserProfileDir%` zur Verfügung, mit der Verzeichnisnamen konstruiert werden können.

Das User-spezifische Verzeichnis ist im Fall von `/AllNTUserProfiles` das User-Profilverzeichnis. Im Fall von `/AllNTUserSendTo` wird der Pfad zum User-spezifischen SendTo-Ordner vorgegeben (der dazu dient, im Windows-Explorer Kontextmenü-Verknüpfungen vorzugeben).

Die genaue Regel, nach der Zielpfade für copy-Anweisungen automatisch gebildet werden, ist dreiteilig:

. Folgt auf die Angabe der zu kopierenden Quelldateien gar keine Zielverzeichnisangabe, so werden die Dateien direkt in das betreffende User-spezifische Verzeichnis kopiert. Der Befehl lautet einfach +
`copy` <Quelldatei> +
Dies ist gleichbedeutend mit +
`copy` <Quelldatei> '"%UserProfileDir%\"'

. Wenn außer den zu kopierenden Quelldateien ein Kopierziel 'targetdir' spezifiziert ist, dieses Ziel jedoch keinen absoluten Pfad (beginnend mit Laufwerksname oder mit "\") darstellt, dann wird die Zielangabe als Unterverzeichnisname des User-spezifischen Verzeichnisses interpretiert und der Zielverzeichnisname dementsprechend konstruiert. D.h. man schreibt +
`copy` <Quelldateien> 'targetdir' 
und das wird interpretiert wie: +
`copy` <Quelldatei> '"%UserProfileDir%\targetdir"'

. Enthält der copy-Befehl Quelldateien und einen absoluten Zielpfad targetdir, so wird dieser statische Zielpfad verwendet.

Weiterhin gibt es die Aufrufparameter:

*  `/32Bit`
*  `/64Bit`
*  `/SysNative`

Welche die 'file redirection' auf 64 Bit-Systemen beeinflussen.
siehe <<opsi-winst-64bit,Kapitel 64 Bit-Unterstützung>>
 
==== Kommandos

Innerhalb einer Files-Sektion sind die Anweisungen 

*  `Copy`

*  `Delete`

*  `SourcePath`

*  `CheckTargetPath`

definiert. 

Die Kommandos `Copy` und `Delete` entsprechen im Wesentlichen den Windows-Kommandozeilen-Befehlen xcopy bzw. del.

`SourcePath` sowie `CheckTargetPath` legen Quell- bzw. Zielpfad einer Kopieraktion fest, ähnlich wie sie etwa im Windows-Explorer durch Öffnen von Quell- und Zieldirectory in je einem Fenster realisiert werden kann. Der Zielpfad wird, sofern er nicht existiert, erzeugt.

Im Einzelnen: 

*  `Copy` [-svdunxwnr] <Quelldatei(maske)> <Zielpfad>
+ 
Die Quelldateien können dabei mittels Joker (”* ” in der Dateimaske) oder auch nur mit einer Pfadangabe bezeichnet werden. 
+
CAUTION: Zielpfad wird in jedem Fall als Directory-Name interpretiert. Umbenennen beim Kopieren ist nicht möglich: Ziel ist immer ein Pfad, nicht ein (neuer) Dateinamen. Existiert der Pfad nicht, wird er (auch mit geschachtelten Directories) erzeugt. 
+
Die einzelnen (in beliebiger Reihenfolge aufführbaren) Optionen der Copy-Anweisung bedeuten: 

**  `s` -> Mit Rekursion in Subdirectories.

**  `e` -> Leere (Empty) Subdirectories. +
Gibt es leere Subdirectories im Quellverzeichnis, werden sie im Zielverzeichnis ebenfalls leer ("empty") erzeugt.

**  `V` -> Mit Versionskontrolle +
Mit Versionskontrolle: +
Neuere Versionen von Windows-Bibliotheksdateien im Zielverzeichnis werden nicht durch ältere Versionen überschrieben (bei unklaren Verhältnissen wird in einem Log-Eintrag gewarnt).

**  `v` -> (nicht Verwenden) +
Mit Versionskontrolle: +
Veraltet; bitte nicht bei Betriebssystemversionen höher als Win2k verwenden, da hier nicht nur gegen das Zielverzeichnis, sondern auch gegen %SYSTEM% geprüft wird. Verwenden Sie stattdessen `-V`.

**  `d` -> Mit Datumskontrolle: +
Jüngere *.EXE-Dateien werden nicht durch ältere überschrieben. 

**  `u` -> Datei-Update: +
Es werden Dateien nur kopiert, sofern sie nicht mit gleichem oder jüngerem Datum im Zielpfad existieren. 

**  `x` -> x-tract +
Wenn eine Datei ein Zip-Archiv ist, wird es entpackt (x-tract). Vorsicht: Zip-Archive verbergen sich unter verschiedenen Dateinamen (z.B. sind Java jar-Dateien auch Zip-Archive), daher sollte man die Extract-Option nicht unbesehen auf alle Dateien anwenden. Achtung: Es werden keine Pfade entpackt.

**  `w` -> weak +
Dateien werden nur überschrieben, wenn sie keinen Schreibschutz haben (das Überschreiben ist "weak" (relativ schwach) im Vergleich zum Defaultverhalten, dem Ignorieren des Schreibschutzes).

**  `n` ->  no over write +
Dateien werden nicht überschrieben. 

**  `c` ->  continue +
Wenn eine Systemdatei in Benutzung ist, kann sie erst nur nach einem Reboot überschrieben werden. Das '{opsi-winst}' default-Verhalten ist dabei, dass ein Datei in Benutzung zum Überschreiben beim nächsten Reboot markiert wird UND die '{opsi-winst}' Reboot Markierung gesetzt wird. Das Setzen der Kopiermodifikation "-c" stellt den automatischen Reboot aus. Anstatt das normale Prozesse weiterlaufen (continues) wird das Kopieren nur vervollständigt, wenn ein Reboot auf eine andere Weise ausgelöst wird.

**  `r` -> read-only Attribute +
Nur wenn diese Option gesetzt ist, bleibt ein eventuell vorhandenes read-only-Attribut erhalten (im Gegensatz zu dem default-Verhalten, welches read-only Attribute ausschaltet).

*  `Delete` [-sfd[n]] <Pfad>

oder

*  `Delete` [-sfd[n]] <Datei(maske)>
+
Löschen einer Datei bzw. eines Verzeichnisses. Mögliche Optionen (die in beliebiger Reihenfolge aufgeführt sein können) sind:

**  `s` ->  subdirectories +
Steht für die Rekursion in Subdirectories, das heißt, der ganze Pfad bzw. alle der Dateimaske entsprechenden Dateien im Verzeichnisbaum ab der angegebenen Stelle werden gelöscht.
+
CAUTION: Der Befehl +
`delete -s c:\opsi` +
Bedeutet nicht lösche das Verzeichnis 'c:\opsi' rekursiv, sondern lösche ab 'c:\' rekursiv alle Dateien namens 'opsi' (und führt damit evtl. zum kompletten Durchsuchen der Festplatte). Zum rekursiven Löschen von 'c:\opsi' verwenden Sie das Kommando: +
`delete -s c:\opsi\` +
Durch den angehängen Backslash ist deutlich, dass Sie ein Verzeichnis meinen.

**  `f` ->  force +
Erzwingt ("force") das Löschen auch von read-only-Dateien.

**  `d [n]` ->  date +
Dateien werden nur gelöscht, sofern sie mindestens n Tage alt sind. Default für n ist 1.

*  `SourcePath` = <Quelldirectory> +
Festlegung des Verzeichnisses <Quelldirectory> als Vorgabe-Quelldirectory für in der betreffenden Sektion folgende Copy- sowie (!) Delete-Aktionen.

*  `CheckTargetPath` = <Zieldirectory> +
Festlegung des Verzeichnisses <Zieldirectory> als Vorgabe-Zieldirectory für Copy-Aktionen. Wenn <Zieldirectory> nicht existiert, wird der Pfad auch mehrstufig erzeugt. 

[[opsi-winst-patches]]
=== Patches-Sektionen

Eine Patches-Sektion dient der Modifikation (dem "Patchen") einer "*.INI-Datei", d.h. einer Datei, die Sektionen mit Einträgen der Form '<Variable> = <Wert>' besteht. Die Sektionen oder Abschnitte sind dabei gekennzeichnet durch Überschriften der Form '[Sektionsname]'. 

(Seitdem eine gepatchete INI-Datei auf die gleiche Weise wie die Sektionen vom '{opsi-winst}' Skript erstellt werden, muss man vorsichtig mit den Bezeichnungen umgehen, damit kein Durcheinander entsteht).

[[opsi-winst-patches-examples]]
==== Beispiele

[source,winst]
----
Patches_DUMMY.INI $HomeTestFiles$+"\dummy.ini"

[Patches_dummy.ini]
add [secdummy] dummy1=add1
; werden durch andere Funktionen ueberschrieben
add [secdummy] dummy2=add2
add [secdummy] dummy3=add3
add [secdummy] dummy4=add4
add [secdummy] dummy5=add5
add [secdummy] dummy6=add6
set [secdummy] dummy2=set1
addnew [secdummy] dummy1=addnew1
change [secdummy] dummy3=change1
del [secdummy] dummy4
Replace dummy6=add6 replace1=replace1
----

ergibt folgenden Log:
[source,winst]
----
Execution of Patches_DUMMY.INI
      FILE C:\tmp\testFiles\dummy.ini
      Info: This file does not exist and will be created 
  addEntry [secdummy] dummy1=add1
    addSection [secdummy]
      done
      done
  addEntry [secdummy] dummy2=add2
      done
  addEntry [secdummy] dummy3=add3
      done
  addEntry [secdummy] dummy4=add4
      done
  addEntry [secdummy] dummy5=add5
      done
  addEntry [secdummy] dummy6=add6
      done
  setEntry [secdummy] dummy2=set1
    Entry      dummy2=add2
    changed to dummy2=set1
  addNewEntry [secdummy] dummy1=addnew1
    appended entry
  changeEntry [secdummy] dummy3=change1
    entry      dummy3=add3
    changed to dummy3=change1
  delEntry [secdummy] dummy4
    in section secdummy deleted  dummy4=add4
  replaceEntrydummy6=add6 replace1=replace1
    replaced in line 7
  C:\tmp\testFiles\dummy.ini saved back
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_patches$ = "on"'

[[opsi-winst-patches-params]]
==== Aufrufparameter

Der Name der zu patchenden Datei wird als Parameter übergeben.

[[opsi-winst-patches-commands]]
==== Kommandos

In einer Patches-Sektion sind die Anweisungen 

*  `add`

*  `set`

*  `addnew`

*  `change`

*  `del`

*  `delsec`

*  `replace`

definiert. Eine Anweisung bezieht sich jeweils auf eine Sektion der zu patchenden Datei. Der Name dieser Sektion steht in Klammern `[]`.

Syntax und Funktion der Anweisungen im Einzelnen: 

*  `add [`<section name>`]` <variable1> `=` <value1> +
Fügt einen Eintrag der Form <Variable1> = <value1> in die Sektion <section name> ein, falls dort noch kein Eintrag von <Variable1> (auch mit anderem Wert) existiert. Im anderen Fall wird nichts geschrieben. Existiert die Sektion noch nicht, wird sie zuerst erzeugt.

*  `set [`<section name>`]`<variable1> `=` <value1> +
Setzt einen vorhandenen Eintrag <variable1> = <value X> in der Sektion <section name>, um auf <variable1> = <value1> zu kommen. Existieren mehrere Einträge von <variable1>, wird der Erste umgesetzt. Falls kein Eintrag mit <variable1> existiert, wird <variable1> = <value1> in der Sektion <section name> erzeugt; existiert die Sektion noch nicht, wird sie zuerst erzeugt. 

*  `addnew [`<section name>`]`<variable1> `=` <value1> +
Der Eintrag <variable1> = <value1> wird in der Sektion <section name> auf jeden Fall erzeugt, sofern er dort nicht bereits genau so existiert (gegebenenfalls zusätzlich zu anderen Einträgen von <variable1>). Existiert die Sektion noch nicht, wird sie zuerst erzeugt. 

*  `change [`<section name>`]`<variable1> `=` <value1> +
Ändert einen vorhandenen Eintrag von <variable1> in der Sektion <section name> auf <variable1> = <value1>.  Falls <variable1> nicht vorhanden ist, wird nichts geschrieben.

*  `del [`<section name>`]` <variable1> `=` <value1> +
bzw. +
`del [`<section name>`]` <variable1> +
In der Sektion <section name> wird gemäß dem ersten Syntaxschema der Eintrag <variable1> = <value1> entfernt. Nach dem zweiten Syntaxschema wird der erste Eintrag von <variable1> aus der angesprochenen Sektion gelöscht, unabhängig vom Wert des Eintrags.

*  `delsec [`<section name>`]` +
Die Sektion <section name> der .INI-Datei wird mitsamt ihren Einträgen gelöscht. 

*  `replace` <variable1>`=`<value1> <variable2>`=`<value2> +
In allen Sektionen der .INI-Datei wird der Eintrag <variable1>=<value1> durch <Variable2>=<value2> ersetzt. Zur Anwendung dieses Befehls dürfen Leerzeichen weder um die Gleichheitszeichen stehen noch in <value1> bzw. <value2> enthalten sein.

[[opsi-winst-patchhosts]]
=== PatchHosts-Sektionen

Eine PatchHosts-Sektion dient der Modifikation einer 'hosts'-Datei, das heißt einer Datei, deren Zeilen nach dem Schema +
'ipAdresse	  Hostname  Aliasname(n)   # Kommentar' +
aufgebaut sind. 

Dabei sind 'Aliasname(n)' und 'Kommentar' optional. Eine Zeile kann auch mit dem Symbol '#' beginnen und ist dann insgesamt ein Kommentar.

Die zu patchende Datei kann als Parameter des `PatchHosts`-Aufrufs angegeben sein. Fehlt der Parameter 'HOSTS', so wird in den Verzeichnissen (in dieser Reihenfolge) 'c:\nfs, c:\windows' sowie '%systemroot%\system32\drivers\etc' nach einer Datei mit dem Namen 'hosts' gesucht. 

Wird auf keine dieser Arten eine Datei mit dem Namen 'hosts' gefunden, bricht die Bearbeitung mit einem Fehler ab.

In einer PatchHosts-Sektion existieren die Anweisungen

*  `setAddr`

*  `setName`

*  `setAlias`

*  `delAlias`

*  `delHost`

*  `setComment`


Beispiel:
[source,winst]
----
PatchHosts_add $HomeTestFiles$+"\hosts"

[PatchHosts_add]
setAddr ServerNo1 111.111.111.111
setName 222.222.222.222 ServerNo2
setAlias ServerNo1 myServerNo1
setAlias 222.222.222.222 myServerNo2
setComment myServerNo2 Hallo Welt
----

ergibt folgenden Log:
[source,winst]
----
Execution of PatchHosts_add
    FILE C:\tmp\testFiles\hosts
  Set ipAddress 111.111.111.111 Hostname "ServerNo1"
  Set Hostname "ServerNo2" for ipAddress 222.222.222.222
  Alias "myServerNo1" set for entry "ServerNo1"
  Alias "myServerNo2" set for entry "222.222.222.222"
  SetComment of Host "myServerNo2" to "Hallo Welt"
  C:\tmp\testFiles\hosts saved back
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test' und dort den Bereich '$Flag_winst_patch_hosts$ = "on"'.

Die Anweisungen im einzelnen:

*  `setaddr`  <hostname> <ipaddresse> +
Setzt die IP-Adresse für den Host <hostname> auf <ipadresse>. 
Falls noch kein Eintrag für den Host <hostname> besteht, wird er neu eingetragen.

*  `setname` <ipaddresse> <hostname> +
Setzt den Namen des Hosts mit der angegeben IP-Adresse <ipadresse> auf <hostname>. Falls noch kein Eintrag mit der IP-Adresse <ipadresse> existiert, wird er neu erzeugt.

*  `setalias` <hostname> <alias> +
Fügt für den Host mit dem IP-Namen <hostname> einen ALIAS-Namen <alias> ein. 

*  `setalias` <IPadresse> <alias> +
Fügt für den Host mit der IP-Adresse <IPadresse> einen ALIAS-Namen <alias> ein.

*  `delalias` <hostname> <alias> +
Löscht aus dem Eintrag für den Host mit dem IP-Namen <hostname> den ALIAS-Namen <alias>. 

*  `delalias` <IPadresse> <alias> +
Löscht aus dem Eintrag für den Host mit der IP-Adresse <IPadresse> den ALIAS-Namen <alias>. 

*  `delhost` <hostname>
Löscht den Eintrag des Hosts mit dem IP- (oder Alias-) Namen <hostname>.

*  `delhost` <IPadresse> +
Löscht den Eintrag des Hosts mit der IP-Adresse <IPadresse>.

*  `setComment` <ident> <comment> +
Setzt für den Host mit dem IP-Namen, Alias-Namen oder Adresse <ident> den Kommentareintrag auf <comment>. 

[[opsi-winst-idapi]]
=== IdapiConfig-Sektionen

Eine IdapiConfig-Sektion waren dazu geeignet, in idapi*.cfg-Dateien, die von der Borland-Database-Engine verwendet werden, die benötigten Parameter einzufügen.

IdapConfig-Sektionen werden vom aktuellen '{opsi-winst}' nicht mehr unterstützt.

[[opsi-winst-patchtextfile]]
=== PatchTextFile-Sektionen

PatchTextFile-Sektionen dienen zum Patchen allgemeiner Textdateien. Es gibt aber auch Spezialanweisungen zum Patchen von Mozilla Konfigurationsdateien.

Wichtig für die Arbeit mit Textdateien ist das Überprüfen, ob eine bestimmte Zeile bereits in einer existierenden Datei vorhanden ist. Für diese Zweck gibt es die boolesche Funktionen `Line_ExistsIn` und `LineBeginning_ExistsIn` (vgl. <<opsi-winst-commands-if-else-bool-functions,Kapitel "Boolesche Ausdrücke">>) zur Verfügung.

[[opsi-winst-patchtextfile-params]]
==== Aufrufparameter

Der Name der zu patchenden Datei wird als Parameter übergeben.

[[opsi-winst-patchtextfile-commands]]
==== Kommandos

Zwei Anweisungen dienen speziell dem komfortablen Patchen von Mozilla-Präferenzdateien:

*  `Set_Mozilla_Pref` ("<preference type>", "<preference key>", "<preference value>") +
sorgt dafür, dass in die beim Sektionsaufruf spezifizierten Datei die Zeile <Präferenzvariable> nach <Wert> geschrieben wird. Die ASCII-alphabetische Anordnung der Datei wird beibehalten bzw. hergestellt. +
In den momentanen Mozilla Präferenzdateien gibt es folgende Ausdrücke +
'user_pref("<key>", "<value>") +
pref("<key>", "<value>") +
lock_pref("<key>", "<value>")' +
Jeder dieser Ausdrücke, sozusagen jede (javascript) Funktion, die auf diese Weise aufgerufen wird +
'functionname (String1, String2)' +
kann mit diesem Kommando gepatcht werden über das Setzen des entsprechenden Strings für <preference type> (das ist bspw. für 'functionname'). +
Wenn der Starteintrag '"functionname (String1)"' in dem bearbeitenden File existiert, kann er gepatcht werden (und bleibt an seinem Platz). Andernfalls wird einen neue Zeile eingefügt. +
Für den '{opsi-winst}' - ungewöhnlicherweise - sind alle Strings case sensitive.

*  `Set_Netscape_User_Pref` ("<Präferenzvariable>", "<Wert>")
ist die restriktivere, ältere Version des vorherigen Kommandos und sollte nicht mehr verwendet werden. +
Setzen der Zeile mit den vom User vergebenen Präferenzen für die Variable <Präferenzvariable> und des Wertes <value>.(Abgekündigt!)

*  `AddStringListElement_To_Mozilla_Pref` ("<Präferenztyp>", "<Präferenzvariable>", "<add value>") +
fügt ein Element zu einem Listeneintrag der Präferenzdatei hinzu. Das Element wird überprüft, wenn der Wert, der hinzugefügt werden soll, bereits in der Liste existiert (dann wird er nicht hinzugefügt). 

*  `AddStringListElement_To_Netscape_User_Pref` ("<Präferenzvariable>", "<Werteliste>") +
ist die restriktivere, ältere Version des vorherigen Kommandos und sollte nicht mehr verwendet werden. +
Es fügt einer Werteliste ein Element hinzu (soweit nicht schon enthalten). Angewendet werden kann die Anweisung zur Ergänzung der No-Proxy-Einträge in der prefs.js. (Abgekündigt!)

Alle übrigen Anweisungen von PatchTextFile-Sektionen sind nicht auf spezielle Dateiarten bzw. eine spezielle Syntax der Datei festgelegt:

Die drei Suchanweisungen

*  `FindLine` <Suchstring>
*  `FindLine_StartingWith` <Suchstring>
*  `FindLine_Containing` <Suchstring> 

durchsuchen die Datei ab der Position, auf der der Zeilenzeiger steht. Sofern sie eine passende Zeile finden, setzen sie den Zeilenzeiger auf die erste Zeile, die <Suchstring> gleicht / mit ihm beginnt / ihn enthält. 

Wird <Suchstring> nicht gefunden, so bleibt der Zeilenzeiger an der Ausgangsposition stehen. 

*  `GoToTop` + 
setzt den Zeilenzeiger vor die erste Zeile setzt (werden Zeilen gezählt muss man berücksichtigen, dass dieses Kommando den Zeilenzeiger über die Anfangszeile setzt). 
Der Zeilenzeiger kann vor und zurück bewegt werden mit der <Anzahl Zeilen>.

*  `AdvanceLine` [<Anzahl Zeilen>] +
bewegt den Zeilenzeiger um <Anzahl Zeilen> vor oder zurück.

*  `GoToBottom` +
setzt den Zeilenzeiger auf die letzte Zeile.

*  `DeleteTheLine` +
löscht die Zeile auf der der Zeilenzeiger steht, sofern sich dort eine Zeile befindet (wenn der Zeilenzeiger oben platziert ist, wird nichts gelöscht).

*  `AddLine_` <Zeile> oder `Add_Line_` <Zeile> +
<Zeile> wird am Schluss der Datei angehängt.

*  `InsertLine` <Zeile> oder `Insert_Line_` <Zeile> +
<Zeile> wird an der Stelle eingefügt, an der der Zeilenzeiger steht.

*  `AppendLine` <Zeile> oder `Append_Line`  <Zeile> +
<Zeile> wird nach der Zeile eingefügt, an der der Zeilenzeiger steht.

*  `Append_File`  <Dateiname> +
liest die Zeilen der Datei <Dateiname> ein und fügt sie an den Schluss der gerade bearbeiteten Datei an.

*  `Subtract_File`  <Dateiname> +
entfernt die Anfangszeilen der bearbeiteten Datei, so weit sie mit den Anfangszeilen der Datei <Dateiname> übereinstimmen.

*  `SaveToFile` <Dateiname> +
speichert die bearbeitete Datei als <Dateiname>.

*  `Sorted` +
bewirkt, dass die Zeilen alphabetisch (nach ASCII) geordnet sind.

[[opsi-winst-patchtextfile-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_patch_text_file$ = "on"'

[[opsi-winst-linkfolder]]
=== LinkFolder-Sektionen

Mit LinkFolder-Sektionen werden u.a. die Einträge im Startmenü, die Links auf dem Desktop u.ä. verwaltet. 

Zum Beispiel erzeugt folgende Sektion einen Folder (Ordner) namens „acrobat“ im Programme-Folder des allgemeinen Startmenüs (für alle Nutzer gemeinsam).
[source,winst]
----
[LinkFolder_Acrobat]
set_basefolder common_programs

set_subfolder "acrobat"
set_link 
  name: Acrobat Reader 
  target: C:\Programme\adobe\Acrobat\reader\acrord32.exe
  parameters: 
  working_dir: C:\Programme\adobe\Acrobat\reader
  icon_file: 
  icon_index:
end_link
----

In einer LinkFolder-Sektion muss zuerst bestimmt werden, in welchem virtuellen Systemfolder die nachfolgenden Anweisungen arbeiten sollen. Dafür existiert die Anweisung +
`set_basefolder` '<virtueller Systemfolder>' 

Virtuelle Systemfolder, die angesprochen werden können, sind:

'desktop, sendto, startmenu, startup, programs, desktopdirectory, common_startmenu, common_programs, common_startup, common_desktopdirectory'

Die Folder sind virtuell, weil erst durch das Betriebssystem(-Version) bestimmt wird, an welchem physikalischen Ort des Dateisystems sie real existieren. 
Im zweiten Schritt werden die Subfolder (bzw. Subfolder-Pfade), in denen Links angelegt werden, mit der Anweisung +
`set_subfolder` <Folderpath> +
bestimmt und zugleich geöffnet. Der Subfolder versteht sich absolut (mit Wurzel im gesetzten virtuellen Systemfolder). Wenn direkt im Systemfolder gearbeitet werden soll, wird dieser mit + 
`set_subfolder ""`
geöffnet.

Im dritten Schritt können die Links gesetzt werden. Der Befehl verwendet eine mehrzeilige Parameterliste. Sie startet mit +
`set_link` +
Abgeschlossen wird sie durch +
`end_link.`

Die Parameterliste insgesamt hat folgendes Format:

`set_link` + 
  `name:` [Linkname] +
  `target:` <Pfad und Name des Programms> +
  `parameters:` [Aufrufparameter des Programms] +
  `working_dir`: [Arbeitsverzeichnis für das Programm] +
  `icon_file:` [Pfad und Name der Icon-Datei] +
  `icon_index:` [Position des gewünschten Icons in der Icon-Datei] +
`end_link` 

Die Angabe eines 'target' ist erforderlich. Alle andere Einträge haben Defaultwerte und können leer sein oder entfallen:

*  'name' hat als Defaultwert den Programmnamen,
*  'parameters' ist, wenn nichts anderes angegeben ist, ein Leerstring,
*  'icon_file'  ist, wenn nichts anderes angegeben ist, 'target' und
*  'icon_index' ist per Default 0.

CAUTION: Wenn das referenzierte target auf einem, zum Zeitpunkt der Befehlsausführung nicht erreichbaren, Share liegt, werden alle Bestandteile des Pfades auf das Längenschema 8.3 gekürzt. +
Workaround: +
Manuelles Erzeugen einer korrekten Verknüpfung zu einem Zeitpunkt, in dem das Laufwerk verbunden ist. +
Kopieren der korrekten Link-Datei an einen zur Skriptlaufzeit existenten Ort, z.B. C:\Programme. +
Diese Datei ist dann das Link-'target'.

*  `delete_element` <Linkname> +
wird der angesprochene Link aus dem geöffneten Folder gelöscht.

*  `delete_subfolder` <Folderpath> +
löscht den bezeichneten Folder, wobei Folderpath als absolut bezüglich des gesetzten virtuellen Systemfolders zu verstehen ist.

[[opsi-winst-linkfolder-examples]]
==== Beispiele

[source,winst]
----
set $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
for $var$ in $list2$ do LinkFolder_Dummy

[LinkFolder_Dummy]
set_basefolder $var$
set_subfolder "Dummy"
set_link
	name: Dummy
	target: C:\Programme\PuTTY\putty.exe
	parameters:
	working_dir: C:\Programme\PuTTY
	icon_file:
	icon_index:
end_link
----

Ergibt folgenden Log:
[source,winst]
----
Set  $list2$ = createStringList ('common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory')
    retrieving strings from createStringList [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        
    retrieving strings from $list2$ [switch to loglevel 7 for debugging]
        (string   0)common_startmenu
        (string   1)common_programs
        (string   2)common_startup
        (string   3)common_desktopdirectory
        

~~~~~~ Looping through:  'common_startmenu', 'common_programs', 'common_startup', 'common_desktopdirectory'
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTMENU folder
    Created "Dummy" in the COMMON STARTMENU folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON PROGRAMS folder
    Created "Dummy" in the COMMON PROGRAMS folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON STARTUP folder
    Created "Dummy" in the COMMON STARTUP folder
      ShellLink "Dummy" created
  
  Execution of LinkFolder_Dummy
    Base folder is the COMMON DESKTOPDIRECTORY folder
    Created "Dummy" in the COMMON DESKTOPDIRECTORY folder
      ShellLink "Dummy" created

~~~~~~ End Loop
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_link_folder$ = "on"'.

[[opsi-winst-xmlpatch]]
=== XMLPatch-Sektionen

Immer häufiger werden Daten aller Art, insbesondere auch Konfigurationsdaten, als XML-Dokument gespeichert.

Der '{opsi-winst}' bietet XMLPatch-Sektionen an, um XML-Dokumente zu bearbeiten.

Ähnlich wie bei anderen Sektionen (Registry, Patches, LinkFolder) wird dazu zunächst mit bestimmten Befehlen an die Stelle navigiert, an der gearbeitet werden soll und dann dort Detailkommandos ausgeführt.

Das bedeutet, die Aktionen, die '{opsi-winst}' ausführen kann, gliedern sich in:

* *die Selektion* eines Sets von Elementen des XML-Dokuments, inklusive der Erzeugung nicht vorhandener Elemente,

* *Patch-Aktionen*, die für alle Elemente eines Sets ausgeführt werden sowie

* *die Ausgabe* von Namen und/Attributen der selektierten Elemente für die weitere Verarbeitung.

[[opsi-winst-xmlpatch-params]]
==== Aufrufparameter

Der Name der zu patchenden Datei wird als Parameter übergeben.

Beispiel: + 
`XMLPatch_mozilla_mimetypes $mozillaprofilepath$ + "\mimetypes.rdf"`

[[opsi-winst-xmlpatch-xmldoc]]
==== Struktur eines XML-Dokuments

Ein XML-Dokument beschreibt die Logik eines „Baums“ (tree), der sich ausgehend von einer „Wurzel“ (root) – passenderweise  document root genannt  –  in die "Äste" (branches) verzweigt. Jede Verzweigungsstelle, wie auch jedes „Astende“, wird als „Knoten“ bezeichnet (englisch node). Die nachgeordneten Knoten eines Knotens heißen auch Kinderknoten ihres Elternknotens.

In XML wird dieser Baum konstruiert durch Elemente. Der Anfang der Beschreibung eines Elements ist mit einem Tag gekennzeichnet (ähnlich wie in der Web-Auszeichnungssprache HTML), d.h. durch einen spezifischen Markierungstext, der durch „<“ und „>“ umrahmt ist. Das Ende der Beschreibung wird wieder durch ein Tag desselben Typnamens gekennzeichnet, jetzt aber durch „</“ und „>“ geklammert. Wenn es keine nachgeordneten Elemente gibt, kann die getrennte Endmarkierung entfallen, stattdessen wird das öffnende Tag mit „/>“ abgeschlossen.

Einen „V“-Baum – mit einer einzigen Verzweigung in zwei Teiläste – könnte man so skizzieren (Wurzel nach oben gedreht):      
~~~~
    |     Wurzelknoten
   / \    Knoten 1 auf Ebene 1  bzw.  Knoten 2 auf Ebene 1
  .   .   Implizit vorhandene Endknoten unterhalb von Ebene 1 
~~~~

Er würde in XML folgendermaßen dargestellt:
[source,xml]
----
<?xml version="1.0"?>
<Wurzelknoten>
    <Knoten_Ebene-1_Nummer-1>
    </Knoten_Ebene-1_Nummer-1>
    <Knoten_Ebene-1_Nummer-2>
    </Knoten_Ebene-1_Nummer-2>
</Wurzelknoten>
----

Die erste Zeile benennt nur die XML-Definition nach der sich das Dokument richtet. Die weiteren Zeilen beschreiben den Baum.

Die insoweit noch nicht komplizierte Struktur wird dadurch verwickelt, dass bis jetzt nur „Hauptknoten“ vorkommen. Ein Hauptknoten definiert ein „Element“ des Baums und ist durch ein Tag gekennzeichnet. Einem solchen Hauptknoten können – wie bei der Skizze schon angedeutet – „Unterknoten“ und sogar mehrere Arten davon zugeordnet sein. (Befände sich der Baum in der normalen Lage mit Wurzel nach unten, müssten die Unterknoten „Überknoten“  heißen.) Folgende Arten von Unterknoten sind zu berücksichtigen:

* Nachgeordnete Elemente, z.B. könnte der Knoten Nummer 1 sich in Subknoten A bis C verzweigen:
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-1>
    <Knoten_Ebene-2_A>
    </Knoten_Ebene-2_A>
    <Knoten_Ebene-2_B>
    </Knoten_Ebene-2_B>
    <Knoten_Ebene-2_C>
    </Knoten_Ebene-2_c>
</Knoten_Ebene-1_Nummer-1>
----

* Nur wenn es KEINE nachgeordneten Elemente gibt, kann das Element Text enthalten. Dann heißt es, dass dem Element ein Textknoten untergeordnet ist. Beispiel:
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-2>Hallo Welt
</Knoten_Ebene-1_Nummer-2>
----

* Der Zeilenumbruch, der zuvor nur Darstellungsmittel für die XML-Struktur war, zählt dabei jetzt auch als Teil des Textes! Wenn er nicht vorhanden sein soll, muss geschrieben werden
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-2>Hallo Welt</Knoten_Ebene-1_Nummer-2>
----

* Zum Element können außer dem Hauptknoten noch Attribute, sog. Attributknoten gehören. Es könnte z.B. Attribute „Farbe“ oder „Winkel“ geben, die den Knoten 1 in der Ebene 1 näher beschreiben.
+
[source,xml]
----
<Knoten_Ebene-1_Nummer-1 Farbe="grün" Winkel="65">
</Knoten_Ebene-1_Nummer-1>
----
+
Eine derartige nähere Beschreibung eines Elements ist mit beiden anderen Arten von Unterknoten vereinbar.

Zur Auswahl einer bestimmten Menge von Elemente könnten im Prinzip alle denkbaren Informationen herangezogen werden, insbesondere

. die Elementebene (Schachtelungstiefe im Baum),

. der Name der Elemente, d.h. Name der entsprechenden Hauptknoten, in der Abfolge der durchlaufenen Ebenen (der „XML-Pfad“),

. die Anzahl, Namen und Werte der zusätzlich gesetzten Attribute,

. die Reihenfolge der Attribute,

. die Reihenfolge der Elemente,

. sonstige „Verwandtschaftsbeziehungen“ der Elemente und

. Text-(Knoten-)Inhalte von Elementen.

Im '{opsi-winst}' ist derzeit die Auswahl nach den Gesichtspunkten (1) bis (3) sowie (7) implementiert:

[[opsi-winst-xmlpatch-search-options]]
==== Optionen zur Bestimmung eines Sets von Elementen

Vor jeder weiteren Operation muss das Set von Elementen bzw. von Hauptknoten bestimmt werden, auf die sich die Operation beziehen soll. Das Set wird Schritt für Schritt ermittelt, indem ausgehend von der Dokumentenwurzel  Pfade gebildet werden, die jeweils über akzeptierte nachgeordnete Elemente laufen. Die letzten Elemente der Pfade bilden dann das ausgewählte Set.

Der '{opsi-winst}' Befehl hierfür lautet

*  `OpenNodeSet`

Für die Festlegung der akzeptierten Pfade existiert eine ausführliche und eine Kurzsyntax.

.Ausführliche Syntax

Die ausführliche Syntax für die Beschreibung eines Elemente-Sets bzw. einer Knoten-Menge ist in der folgenden Variante eines Beispiels zu sehen (vgl. Kochbuch, <<opsi-winst-cookbook-patchxml,Kapitel "XML-Datei patchen">>):
[source,winst]
----
openNodeSet
  documentroot
  all_childelements_with:
   elementname:"define"
  all_childelements_with:
    elementname:"handler"
    attribute: extension value="doc"
  all_childelements_with:
    elementname:"application"
end
----

.Kurzsyntax

Das gleiche Nodeset beschreibt folgende Kurzsyntax (muss in einer Zeile des Skripts untergebracht werden):
[source,winst]
----
openNodeSet 'define /handler value="doc"/application /'
----

In dieser Syntax separieren die Schrägstriche die Schritte innerhalb der Baumstruktur, welche in einer Syntax angegeben werden, die ausführlicher als eine eigene Beschreibung ist.

.Selektion nach Text-Inhalten (nur ausführliche Syntax)

Die ausführliche Syntax erlaubt auch die Selektion nach Text-Inhalten eines Tags:
[source,winst]
----
openNodeSet

  documentroot
  all_childelements_with:
  all_childelements_with:
    elementname:"description"
    attribute:“type“ value=“browser“
    attribute:“name“ value=“mozilla“
  all_childelements_with:
    elementname:"linkurl"
    text:"http://www.mozilla.org"
end
----

.Parametrisierung der Suchstrategie

Bei den bislang aufgeführten Beschreibungen eines Elemente-Sets bleiben allerdings eine ganze Reihe von Fragen offen.

* Soll ein Element akzeptiert werden, wenn der Elementname und die aufgeführten Attribute passen, aber weitere Attribute existieren? 

* Soll die Beschreibung im Ergebnis eindeutig sein, d.h. genau ein Element liefern? Und wenn doch die Beschreibung des Pfades auf mehrere Elemente passt, muss dann möglicherweise von einer nicht korrekten Konfigurationsdatei ausgegangen werden? 

* Soll umgekehrt auf jeden Fall ein passendes Element erzeugt werden, wenn keines existiert?

Zur Regelung dieser Fragen kann die OpenNodeSet-Anweisung parametrisiert werden. Bei den nachfolgend genannten Parametern überdecken „stärkere“ Einstellungen „schwächere“, z.B. ersetzt eine Fehlermeldung eine ansonsten geforderte Warnung. Die angegebenen booleschen Werte sind die Default-Werte:
[source,winst]
----
  - error_when_no_node_existing false
  - warning_when_no_node_existing true
  - error_when_nodecount_greater_1 false
  - warning_when_nodecount_greater_1 false
  - create_when_node_not_existing false
  - attributes_strict false
----

Bei Verwendung der Kurzsyntax der OpenNodeSet-Anweisung muss die Parametrisierung vorausgehen und gilt für alle Ebenen des XML-Baumes. In der ausführlichen Syntax kann sie auch direkt nach der OpenNodeSet-Anweisung erfolgen oder für jede Ebene neu gesetzt werden. Sinnvoll kann letzteres vor allem für die Einstellung der Option „create when node not existing“ (Erstellung von Knoten, wenn es keine gibt) sein.

[[opsi-winst-xmlpatch-actions]]
==== Patch-Aktionen

Auf der mit OpenNodeSet geöffneten bzw. erzeugten Knotenmenge arbeiten nachfolgende Patch-Anweisungen. Es existieren solche:

* zum Setzen und Löschen von Attributen,

* zum Entfernen von Elementen und

* zum Setzen von Text.


*  `SetAttribute` "Attributname" value="Attributwert" +
setzt in jedem Element des aktuellen Knoten- bzw. Elementsets das Attribut auf den genannten Wert. Wenn das Attribut nicht vorhanden ist wird es erzeugt. +
Beispiel: +
`SetAttribute "name" value="OpenOffice Writer"`

*  `AddAttribute` "Attributname" value="Attributwert" +
setzt das Attribut dagegen nur auf Attributwert, wenn es vorher nicht existiert, ein vorhandenes Attribut behält seinen Wert. Z.B. würde die Anweisung +
`AddAttribute "name" value="OpenOffice Writer"` +
eine vorher vorhandene Festlegung auf ein anderes Programm nicht überschreiben.

*  `DeleteAttribute` "Attributname" +
wird das betreffende Attribut von jedem Element der aktuellen Knotenmenge entfernt.

*  `DeleteElement` "Elementname" +
entfernt das Element, dessen Hauptknoten den (Tag-) Namen "Elementname" hat, samt Unterknoten aus der aktuellen Knoten- oder Elementmenge. 

Schließlich existieren zwei Anweisungen zum Setzen bzw. Hinzufügen von Textinhalten eines Elements. 
Die beiden Anweisungen lauten 

*  `SetText` "Text"

und

*  `AddText` "Text"

Z.B. wird, wenn das betreffende Element in der geöffneten Elementmenge liegt, durch die Anweisung +
`SetText "rtf"` +
aus + 
'<fileExtensions>doc<fileExtensions>' +
das Element +
'<fileExtensions>rtf<fileExtensions>'

Mit +
`SetText ""` +
wird der Text komplett entfernt.

`AddText "rtf"` +
setzt analog wie bei anderen Add-Anweisungen den Text, sofern kein Text vorhanden ist -  existierender Text bleibt unberührt.

[[opsi-winst-xmlpatch-return]]
==== Rückgaben an das aufrufende Programm

Eine XMLPatch-Sektion kann angewiesen werden, String-Listen an das rufende Programm zurückzugeben. 

Dazu muss sie in einer primären Sektion mit der String-Listen-Anweisung `getReturnListFromSection` aufgerufen werden. Die Anweisung kann in einem String-Listen-Ausdruck verwendet werden, z.B. das Ergebnis einer String-Listen-Variable zugewiesen werden. So kann in der XMLPatch_mime-Sektion stehen:
[source,winst]
----
DefStringList $list1$
set $list1$=getReturnListFromSection ('XMLPatch_mime "c:\mimetypes.rdf"')
----

Eine Return-Anweisung in der XMLPatch-Sektion regelt, welche Zeilen die XMLPatch-Sektion als Inhalt der String-Liste ermittelt:

*  `return elements`+ 
Bewirkt, dass die ausgewählten Elemente komplett (Elementname und Attribute) ausgegeben werden.

*  `return attributes` + 
Erzeugt eine Liste der Attribute.

*  `return elementnames` + 
Listet die Elementnamen. 

*  `return attributenames`
Produziert eine Liste der Attributnamen.

*  `return text` +
Listet die textlichen Inhalte der selektierten Elemente.

*  `return counting` +
Liefert eine Listenstruktur mit summarischen Informationen: In Zeile 0 steht die Anzahl aller ausgewählten Elemente, in Zeile 1 die Zahl aller Attribute. 

[[opsi-winst-xmlpatch-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_xml$ = "on"'


[[opsi-winst-progman]]
=== ProgmanGroups-Sektionen

Dieser Sektionstyp ist abgekündigt.

[[opsi-winst-winbatch]]
=== WinBatch-Sektionen

In einer WinBatch-Sektion kann jedes Windows-Programm als Anweisung verwendet werden. Wie auch aus dem Windows Explorer heraus können Daten-Dateien, die mit einem Programm verknüpft sind, direkt aufgerufen werden. 

Z.B kann mit folgender WinBatch-Sektion ein Setup-Programm gestartet werden:
[source,winst]
----
[winbatch_install]
%scriptpath%\setup.exe
----

[[opsi-winst-winbatch-params]]
==== Aufrufparameter (Modifier)

Durch die Parameter des WinBatch-Aufrufs wird festgelegt, wie sich '{opsi-winst}' gegenüber den in der WinBatch-Sektion gestarteten Programmen verhält.

*  `/WaitOnClose` +
Default +
{opsi-winst} wartet die Selbstbeendigung des angestoßenen Prozesses ab. Dieses Verhalten kann mit dem Parameter auch explizit definiert werden. 

*  `/LetThemGo` +
Verschiebt den aufgerufenen Prozess in den Hintergrund und wartet *nicht* auf dessen Beendigung;
d.h. das sofort die nächste Zeile der WinBatch-Sektion bzw. die nächste Zeile des übergeordneten Programms abgearbeitet werden.

*  `/WaitSeconds` [AnzahlSekunden] +
Die Parametrisierung /WaitSeconds [AnzahlSekunden] modifiziert das Verhalten dahingehend, dass '{opsi-winst}' jeweils erst nach [AnzahlSekunden] die Skriptbearbeitung fortsetzt. Die angegebene Zeit stoppt '{opsi-winst}' auf jeden Fall. In der Default-Einstellung wird zusätzlich auf das Ende der angestoßenen Prozesse gewartet. Ist letzteres nicht gewünscht, so kann der Parameter mit dem Parameter /LetThemGo kombiniert werden.

*  `/WaitForWindowAppearing` [Fenstertitel] +
bzw. +
`/WaitForWindowVanish` [Fenstertitel] +
Abgekündigt. Verwenden Sie `/WaitForProcessEnding` +
Im 1. Fall wartet '{opsi-winst}' solange, bis ein Prozess, der sich durch ein mit [Fenstertitel] benanntes Fenster kenntlich macht, gestartet ist. Im 2. Fall wartet '{opsi-winst}' bis ein, mit [Fenstertitel] benanntes, Fenster auf dem Desktop erst einmal erscheint und dann auch wieder geschlossen wird. Auf diese Weise kann unter geeigneten Umständen geprüft werden, ob sekundäre, indirekt gestartete Prozesse sich beendet haben.
+
CAUTION: Diese Befehle erkennen nur Fenster von 32 Bit-Programmen.

 
*  `/WaitForProcessEnding` <program name> +
Wartet darauf, das sich der Prozess mit dem Namen <program name> beendet. +
Kann und sollte mit `/TimeOutSeconds` kombiniert werden.

*  `/TimeOutSeconds` <seconds> +
Bricht eine Wartebedingung nach Ablauf von <seconds> ab, auch wenn die Wartebedingung noch nicht erfüllt ist. +
Beispiel: 
+
[source,winst]
----
Winbatch_uninstall /WaitForProcessEnding "uninstall.exe" /TimeOutSeconds 20
[Winbatch_uninstall]
%ScriptPath%\uninstall_starter.exe
----

*  `getLastExitCode` +
Die String-Funktion getLastExitCode gibt den ExitCode des letzten Prozessaufrufs der vorausgehenden WinBatch Sektion aus.

[[opsi-winst-winbatch-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_winbatch$ = "on"'

[[opsi-winst-dosbatch]]
=== DOSBatch/DosInAnIcon (ShellBatch/ShellInAnIcon) Sektionen

DOSBatch-Sektionen (auch ShellBatch genannt) sollen in erster Linie dazu dienen, vorhandene Kommandozeilenroutinen für bestimmte Zwecke zu nutzen. '{opsi-winst}' wartet auf die Beendigung des DOS-Batch, bevor die nächste Sektion des Skripts abgearbeitet wird. 

Eine DosBatch-Sektion wird bei der Abarbeitung des Skripts in eine temporäre Batch-Datei '_winst.bat' umgewandelt. Da die Datei in 'c:\tmp' angelegt wird, muss dieses Verzeichnis existieren und zugänglich sein. Die Batch-Datei wird dann in einem Kommando-Fenster mit cmd.exe als Kommando-Interpreter ausgeführt. Dies erklärt warum in einer DosBatch Sektion alle Windows Shell Kommandos verwendet werden können. 

Gegenüber dem Aufruf einer cmd-Datei per Winbatch-Sektion bietet die DosBatch Sektionen drei Vorteile:

* In der Sektion vorhandene '{opsi-winst}' Variablen oder Konstanten werden vor der Ausführung durch Ihren Inhalt ersetzt und können so unkompliziert verwendet werden.

* Die Ausgaben des Aufrufs werden in der Logdatei abgespeichert.

* Die Ausgaben des Aufrufs können einer String-Liste übergeben und weiterverarbeitet werden.

Der Sektionstyp DOSInAnIcon oder ShellInAnIcon ist identisch mit der betreffenden DOSBatch Syntax und ausführenden Methoden. Allerdings wird das aufgerufenen Fenster minimiert dargestellt.

CAUTION: Verwenden Sie keine Kommandos, die auf Eingaben warten.

[[opsi-winst-dosbatch-params]]
==== Aufrufparameter

Parameter des Aufrufs der DosBatch-Sektion in der Actions-Sektion werden unmittelbar als Parameter der Batch-Datei interpretiert. 

Zum Beispiel bewirken die Anweisungen in Actions-Sektionen bzw. der Sektion
DosBatch_1 :
[source,winst]
----
[Actions]
DosBatch_1 today we say "Hello World" 

[DosBatch_1]
@echo off
echo %1 %2 %3 %4
pause
----

die Ausführung des Dos-Batch-Befehls echo mit Parametern "Hello" und "World".

[[opsi-winst-dosbatch-catchout]]
==== Einfangen der Ausgaben

Sollen die Ausgaben, die von Befehlen einer DosBatch-Sektion kommen, aufgefangen werden, so geschieht dies mittels `getOutStreamFromSection ()` aus der Haupt-Sektion des {opsi-winst}-Skripts (siehe <<opsi-winst-stringlist-getstring,Kapitel "(Wieder-) Gewinnen von Einzelstrings aus String-Listen">>). 

Sollen die zurückgegebenen Strings weiterverarbeitet werden, so wird dringend geraten, vor den Befehlszeilen ein '@'-Zeichen zu verwenden bzw. die Kommandos mit '@echo off' zu beginnen. Dies unterdrückt die Ausgabe der Befehlszeile selbst, die je nach System anders formatiert sein kann. 

[[opsi-winst-dosbatch-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_dos$ = "on"'

[[opsi-winst-registry]]
=== Registry-Sektionen

Diese Funktion ist nur unter Windows verfügbar.

Registry-Sektionen dienen dem Erzeugen und Patchen von Einträgen in der Windows-Registrierdatenbank, wobei die Eintragungen mit dem {opsi-winst}-üblichen Detaillierungsgrad protokolliert werden. 

[[opsi-winst-registry-examples]]
==== Beispiele

Man kann eine Registry-Variable setzen indem man die Sektion mit Registry_TestPatch aufruft, wo sie dann wie folgt angegeben ist
[source,winst]
----
[Registry_TestPatch]
openkey [HKEY_Current_User\Environment\Test]
set "Testvar1"  = "c:\rutils;%Systemroot%\hey" 
set "Testvar2" = REG_DWORD:0001
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_subregistry$ = "on"'

[[opsi-winst-registry-params]]
==== Aufrufparameter

* Die Standardform der Registry-Sektionen ist unparametrisiert. Dies genügt, weil auf dem Windows-PC nur eine einzige Registrierdatenbank gibt und somit das globale Ziel der Bearbeitung feststeht.

*  `/AllNTUserDats` +
Es gibt jedoch die Möglichkeit, dass die Patches einer Registry-Sektion automatisch für "alle NT User", entsprechend den verschiedenen User-Zweigen der Registry, vorgenommen werden. Das entsprechende Verfahren bei der Abarbeitung der Sektion wird mit dem Parameter `/AllNTUserDats` aufgerufen.

Außerdem kontrollieren Parameter mit welchen syntaktische Varianten Registry-Sektionen angefordert werden kann:

*  `/regedit` +
Wird das Registry-Kommando mit dem Parameter `/regedit` verwendet, so kann der Export eines Registry-Teilzweiges mit dem Programm, der mit dem gewöhnlichen Windows-Registry-Editor regedit erstellt wurde, direkt als Eingabedatei für Registry dienen (vgl. Abschnitt  <<opsi-winst-registry-regedit,"Registry-Sektionen im Regedit-Format">>).

*  `/addReg` +
Eine weitere Variante des Registry-Aufrufs dient dazu, die Patch-Anweisungen für die Registry zu verarbeiten, die im inf-Datei-Standard erstellt sind. Zur Kennzeichnung dient der Parameter /addReg (in Anlehnung an die entsprechende Abschnittsbezeichnung in einer inf-Datei)(vgl. Abschnitt <<opsi-winst-registry-addreg,"Registry-Sektionen im AddReg-Format">>).

Diese nicht '{opsi-winst}' spezifischen syntaktischen Varianten sind im Handbuch nicht beschrieben, da sie normalerweise automatisch generiert werden.

Weiterhin gibt es die Aufrufparameter,

*  `/32Bit` +
*  `/64Bit` +
*  `/SysNative` +

welche auf 64 Bit-Systemen das Schreiben in den 32 Bit- bzw. 64 Bit-Zweig der Registry beeinflusst (siehe <<opsi-winst-64bit,Kapitel 64 Bit-Unterstützung>>).

[[opsi-winst-registry-commands]]
==== Kommandos

Die Syntax der Defaultform einer Registry-Sektion ist an der Kommandosyntax anderer Patchoperationen des '{opsi-winst}' orientiert.

Es existieren die Anweisungen:

*  `OpenKey`

*  `Set`

*  `Add`

*  `Supp`

*  `GetMultiSZFromFile`

*  `SaveValueToFile`

*  `DeleteVar`

*  `DeleteKey`

*  `ReconstructFrom`

*  `Flushkey`


Im Detail:

*  `OpenKey` <Registryschlüssel> +
Öffnet den bezeichneten Schlüssel in der Registry zum Lesen (und wenn der eingeloggte User über die erforderlichen Rechte verfügt zum Schreiben); existiert der Schlüssel noch nicht, wird er erzeugt.

Registry-Schlüssel sind ja hierarchisch organisierte Einträge Registrierungsdatenbank. Die hierarchische Organisation drückt sich in der mehrstufigen Benennung aus: Für die oberste (Root-) Ebene können standardmäßig insbesondere die "high keys" 'HKEY_CLASSES_ROOT, HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE, HKEY_USERS' und 'HKEY_CURRENT_CONFIG' verwendet werden. Gebräuchliche Abkürzungen sind 'HKCR, HKCU, HKLM' und 'HKU'.

In der '{opsi-winst}' Syntax bei den Registry-Pfaden werden die weiteren folgenden Ebenen jeweils durch einen Backslash getrennt.

Alle anderen Kommandos arbeiten mit einem geöffneten Registry-Key.

*  `Set` <Varname> = <Value> +
setzt die durch <Varname> bezeichnete Registry-Variable auf den Wert <Value>, wobei es sich sowohl bei <Varname> als auch bei <Value> um Strings handelt, die in Anführungszeichen eingeschlossen sind. Existiert die Variable noch nicht, wird sie erzeugt. Es gibt auch den Leerstring als Variablenname; dieser entspricht dem "(Standard)"-Eintrag im  Registry-Schlüssel.

Soll eine Registry-Variable erzeugt oder gesetzt werden, die nicht den Defaulttyp "Registry-String" (REG_SZ), muss die erweiterte Form der Set-Anweisung verwendet werden:

*  `Set` <Varname> = <Registrytyp>:<Value> + 
Setzt die durch <Varname> bezeichnete Registry-Variable auf den Wert <Value> des Typs <Registrytyp>. Es werden folgende Registry-Typen interpretiert:

'REG_SZ'::: (String)

'REG_EXPAND_SZ'::: (ein String, der vom System zu expandierende Teilstrings wie %Systemroot% enthält)

'REG_DWORD'::: (ganzzahlige Werte)

'REG_BINARY'::: (binäre Werte, in zweistelligen Hexadezimalen, d.h. 00 01 02 .. 0F  10 .., notiert)

'REG_MULTI_SZ'::: (Arrays von String-Werten, die in {opsi-winst}-Syntax durch das Zeichen "|" getrennt werden;
+
Beispiel für REG_MULTI_SZ:
[source,winst]
----
set "myVariable" = REG_MULTI_SZ:"A|BC|de"
----

Wenn ein Multi-String zunächst zusammengestellt werden soll, kann dies zeilenweise in einer Datei geschehen, die man dann mit Hilfe der Anweisung GetMultiSZFromFile (s.u.) einliest. 

*  `Add` <Varname> = <Value>
+
bzw.
+
`Add` <Varname> = <Registrytyp> <Value> +
arbeitet analog zu Set mit dem Unterschied, dass nur Variablen hinzugefügt, Einträge für bestehende Variablen nicht verändert werden.

*  `Supp` <Varname> <Listenzeichen> <Supplement> +
Dieses Kommando liest den String-Wert der Variablen <varname>, einer Liste aus Werten, die separiert werden durch <Listenzeichen> und den String <supplement> zu dieser Liste (wenn sie noch nicht enthalten sind), aus. Wenn  <supplement> die <separator> enthält, können mit diesen Listenzeichen die Einträge in einzelne Strings unterteilt werden und die Prozedur wird für jeden Teilstring angewendet.
+
Eine typische Verwendung ist der Eintrag zu einer Pfadvariablen, die in der Registry definiert ist. 
+
Supp behält den ursprünglichen Stringtyp (REG_EXPAND_SZ bzw. REG_SZ) bei.
+
Beispiel:
+
Der allgemeine Systempfad wird festgelegt durch den Eintrag der Variable Path im Registrierschlüssel
+
'KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Environmen'
+
Wenn dieser Schlüssel mit OpenKey geöffnet ist, kann mit der Anweisung
+
`supp "Path" ; "C:\utils;%JAVABIN%"`
+
der Pfad ergänzt werden, um die Einträge '"C:\utils"' sowie '"%JAVABIN%"'.
+
(Weil der Registry-Eintrag für den Systempfad den Datentyp REG_EXPAND_SZ hat, expandiert Windows %JAVABIN% automatisch zum entsprechenden Verzeichnisnamen, falls %JAVABIN% ebenfalls als Variable definiert ist).
+
Unter Win2k ist das Phänomen zu beobachten, dass sich der path-Eintrag nur per Skript auslesen (und dann patchen) lässt, wenn vor dem Lesen ein Wert gesetzt wird.
+
Der alten Wert von Path wird aus der Umgebungsvariable auslesen, wieder in die Registry zurückgeschrieben und dann ist es möglich mit der Registry-Variablen zu arbeiten.
+
[source,winst]
----
[Actions] 
DefVar $Path$ 
set $Path$ = EnvVar ("Path") 
Registry_PathPatch 

[Registry_PathPatch] 
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\control\Session Manager\Environment] 
set "Path"="$Path$" 
supp "Path"; "c:\orawin\bin"
----
+
CAUTION: Nach dem Patchen des Registry-Path enthält die Umgebungsvariable Path den veränderten Wert erst nach einem Reboot.

*  `GetMultiSZFromFile` <Dateiname> +
Liest eine Datei zeilenweise in einen Multistring ein.

*  `SaveValueToFile` <varname> <filename> +
Exportiert die genannten Werte (String oder MultiSZ) in die Datei <filename> 

*  `DeleteVar` <Varname> +
Löscht den Eintrag mit Bezeichnung <Varname> aus dem geöffneten Schlüssel.

*  `DeleteKey` <Registryschlüssel> +
Löscht den Registry-Key rekursiv samt aller Unterschlüssel und den enthaltenen Registry-Variablen und -Werten. Zur Syntax, in der der Registrierschlüssel angegeben wird, vgl. OpenKey. 
+
Beispiel:
+
[source,winst]
----
[Registry_KeyLoeschen]
deletekey [HKCU\Environment\subkey1]
----

*  `ReconstructFrom` <Dateiname> +
(abgekündigt)

*  `FlushKey` +
Sorgt dafür, dass die Einträge des Schlüssels nicht mehr nur im Speicher gehalten, sondern auf die Platte gespeichert werden (geschieht automatisch beim Schließen eines Keys, insbesondere beim Verlassen einer Registry-Sektion).

[[opsi-winst-registry-allntuser]]
==== Registry-Sektionen, die `alle NTUser.dat` patchen

Wird eine Registry-Sektion mit dem Parameter `/AllNTUserdats` aufgerufen, so werden ihre Anweisungen für alle auf dem NT-System angelegten User ausgeführt.

Dazu werden zunächst die Dateien NTUser.dat für alle auf dem System eingerichteten User-Accounts durchgegangen (in denen die Registry-Einstellungen aus 'HKEY_Users' abgelegt sind). Sie werden temporär in einen Hilfszweig der Registry geladen und dort entsprechenden der Anweisungen der Sektion bearbeitet. Weil dies für den zum Zeitpunkt der Programmausführung angemeldeten User nicht funktioniert, werden die Anweisungen der Sektion zusätzlich für 'HKEY_Current_User' ausgeführt. Als Ergebnis verändert sich die gespeicherte NTUser.dat.

Dieser Mechanismus funktioniert nicht für einen angemeldeten User, da seine NTUser.dat in Benutzung ist und der Versuch die Datei zu laden einen Fehler produziert. Damit aber auch für den angemeldeten User Änderungen durchgeführt werden, werden die Registry Kommandos ebenfalls auf den Bereich 'HKEY_Current_User' angewendet ('HKEY_Users' ist der Zweig für den angemeldeten Benutzer).

Auch künftig erst angelegte Accounts werden mit erfasst, da auch die NTUser.dat aus dem Profilverzeichnis des 'Default Users' bearbeitet wird.

Die Syntax der Sektion ist die einer Standard-Registry-Sektion. Allerdings werden alle Schlüsselnamen relativ interpretiert. D.h. *der Hauptkey ist wegzulassen*: Im folgenden Beispiel werden faktisch die Registry-Einträge für die Variable 'FileTransferEnabled' unter 'HKEY_Users\XX\Software...' neu hergestellt, sukzessive für alle User auf der Maschine:
[source,winst]
----
[Registry_AllUsers]
openkey [Software\ORL\WinVNC3]
set "FileTransferEnabled"=reg_dword:0x00000000
----

[[opsi-winst-registry-regedit]]
==== Registry-Sektionen im Regedit-Format

Bei Aufruf von Registry mit dem Parameter `/regedit` wird der Inhalt der Registry-Sektion in dem Exportformat erwartet, dass das Standard-Windows-Programm regedit erzeugt. 

Die von regedit generierten Exportdateien haben – von der Kopfzeile abgesehen - den Aufbau von Ini-Dateien haben. Beispiel:
[source,ini]
----
REGEDIT4

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org]

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\general]
"bootmode"="BKSTD"
"windomain"=""
"opsiconf"=dword:00000001

[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\shareinfo]
"user"="pcpatch"
"pcpatchpass"=""
"depoturl"="\\\\bonifax\\opt_pcbin\\install"
"configurl"="\\\\bonifax\\opt_pcbin\\pcpatch"
"utilsurl"="\\\\bonifax\\opt_pcbin\\utils"
"utilsdrive"="p:"
"configdrive"="p:"
"depotdrive"="p:"
----

Die Sektionen bezeichnen hier Registry-Schlüssel, die geöffnet werden sollen. Die einzelnen Zeilen stehen für die gewünschten Setzungen von Variablen (entsprechend dem Set-Befehl in {opsi-winst}-Registry-Sektionen).

Diese Anweisungen können aber nun nicht als Sektion innerhalb eine '{opsi-winst}' Skripts untergebracht werden. Daher kann die Registry Sektion mit dem Parameter `/regedit` nur als ausgelagerte Sektion oder über die Funktion loadTextFile geladen werden:
[source,winst]
----
registry "%scriptpath%/opsiorgkey.reg" /regedit
----

Zu beachten ist noch, dass regedit ab Windows XP nicht mehr das Regedit4-Format produziert, sondern ein Format, dass durch die erste Zeile +
'"Windows Registry Editor Version 5.00"' +
gekennzeichnet ist.

Windows sieht hier zusätzliche Wertetypen vor. Gravierender ist, dass die Exportdatei ursprünglich in Unicode erzeugt wird. Um sie mit den 8 Bit-Mitteln der Standardumgebung des '{opsi-winst}' zu verarbeiten, muss der Zeichensatz konvertiert werden. Die Konvertierung kann z.B. mit einem geeigneten Editor durchgeführt werden. Eine andere Möglichkeit besteht darin, die Konvertierung on the fly vom '{opsi-winst}' durchführen zu lassen. Dazu lässt sich die String-Listenfunktion `loadUnicodeTextFile` verwenden. Wenn z.B. printerconnections.reg ein Unicode-Export ist, wäre regedit in folgender Form aufzurufen:
[source,winst]
----
registry loadUnicodeTextFile("%scriptpath%/opsiorgkey.reg") /regedit
----

Auch eine Registry-Patch im regedit-Format kann „für alle NT-User“ ausgeführt werden, sinngemäß in der gleichen Weise wie oben für das gewöhnliche winst-Registry-Patch-Format beschrieben. D.h. der Root-Schlüssel 'HKCU' muss aus den Angaben entfernt werden und dann wird aus + '[HKEY_CURRENT_USER\Software\ORL]' -> '[Software\ORL].'

[[opsi-winst-registry-addreg]]
==== Registry-Sektionen im AddReg-Format

Die Syntax einer Registry-Sektion, die mit dem Parameter `/addReg` aufgerufen wird, folgt der Syntax von '[AddReg]'-Sektionen in inf-Dateien, wie sie z.B. von Treiberinstallationen verwendet wird.

Beispiel:
[source,ini]
----
[Registry_ForAcroread]
HKCR,".fdf","",0,"AcroExch.FDFDoc"
HKCR,".pdf","",0,"AcroExch.Document"HKCR,"PDF.PdfCtrl.1","",0,"Acr"
----

[[opsi-winst-opsiservicecall]]
=== OpsiServiceCall Sektion

Mit dieser Sektion ist es möglich Informationen abzufragen – oder Daten zu bestimmen – mit Hilfe des opsi Service. Es gibt drei Optionen, mit denen man die Verbindung zum opsi Service definieren kann:

* Per Voreinstellung wird vorausgesetzt, dass das Skript in der Standard opsi Installationsumgebung ausgeführt werden kann. D.h. es besteht eine Verbindung zum opsi Service, die genutzt wird.

* Es wird eine URL für den gewünschten Service und ebenso der benötigte Benutzername und das Passwort als Sektionsparameter gesetzt. 

* Es kann ein interaktives Login für den Service gesetzt werden – mit einer voreingestellten Service URL und dem Benutzernamen, wenn das gewünscht wird.

Die abgerufenen Daten können als String-Liste zurückgegeben und dann für die Verwendung in Skripten benutzt werden.

[[opsi-winst-opsiservicecall-params]]
==== Aufrufparameter

Es gibt Optionen, mit denen man die Verbindung zu einem opsi Service angeben kann und Einstellungen, die für die Verbindung benötigt werden. 

Verbindungsparameter können mit Hilfe von

*  `/serviceurl` <url to the opsi web service>

*  `/username` <web service user name>

*  `/password` <web service user password>

gesetzt werden. Wenn diese Parameter definiert sind (oder zumindest einer der Parametern), wird versucht eine Verbindung zu der genannten Service URL herzustellen.

Wenn kein Parameter ausgewiesen ist, kann eine bestehende Verbindung wieder verwendet werden.

Mit der Option

*  `/interactive` +
kann man bestimmen, dass eine interaktive Verbindung benutzt werden soll. Das bedeutet, dass der Benutzer die Verbindungsdaten bestätigen muss und das Passwort eingibt. Diese Option kann damit nicht in Skripten verwendet werden, die voll automatisch ausgeführt werden sollen. 

Wenn keine Verbindungsparameter vorgegeben sind setzt der '{opsi-winst}' vorraus, dass die bestehende Verbindung wieder benutzt werden soll.

Wenn keine Verbindungsparameter angegeben und auch die Option „interactive“ nicht ausgewählt wird (weder bei diesem Skript noch zuvor), wird vorausgesetzt das der '{opsi-winst}' mit dem Standard opsi Bootprozess arbeitet und sich darüber mit dem opsi Service verbindet. Theoretisch gibt es eine Verbindung zu einem zweiten opsi Service, die als Verbindung zu dem Standard opsi Service mit der Option

*  `/preloginservice` + 
neu gestartet werden kann.

[[opsi-winst-opsiservicecall-syntax]]
==== Sektionsformat

Ein `opsiServiceCall`, welcher eine existierende Verbindung zu einem opsi Service benutzt, wird bestimmt durch den Methodennamen und eine Parameterliste.

Beide werden in dem Sektionsabschnitt definiert und haben folgendes Format:
[source,winst]
----
"method":<method name>
"params":[
	<params>
	]
----

Dabei sind <params> kein, ein oder auch mehrere durch Komma getrennte Strings.
Welche Parameter benötigt werden, hängt von der aufgerufenen Methode ab.

Beispiel:
[source,winst]
----
[opsiservicecall_clientIdsList]
"method":"getClientIds_list"
"params":[]
----

Die Sektion erstellt eine Liste der PC-Namen (IDs) von allen lokalen opsi Benutzern. Wenn es für andere Zwecke als Test und Dokumentation genutzt werden soll, kann die Sektion als ein Teil eines String-Listen Ausdrucks (vgl. das folgende Beispiel) verwendet werden.
[source,winst]
----
DefStringList $result$
Set $result$=getReturnListFromSection("opsiservicecall_clientIdsList")
----
Die Verwendung von GetReturnListFromSection ist dokumentiert in dem Kapitel zur String-Listenverarbeitung dieses Handbuchs (siehe <<opsi-winst-stringlist-create-by-section,Kapitel "String-Listen-Erzeugung mit Hilfe von Sektionsaufrufen">>).

Ein Hash, der eine Namensliste mit Wertepaaren enthält, wird durch den folgenden opsi Service aufgerufen (beinhaltet keine leere Parameterliste):
[source,winst]
----
[opsiservicecall_hostHash]
"method": "getHost_hash"
"params": [
	"pcbon8.uib.local"
	]
----

CAUTION: Die opsiservicecall Sektionen sind für opsi 3.x Methoden entwickelt worden und für die opsi 4.x Methoden häufig nicht verwendbar. So sind '*_getIdents' Aufrufe zwar möglich, '*_getObjects' Aufrufe aber nicht.

[[opsi-winst-opsiservicecall-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_opsiServiceCall$ = "on"'

[[opsi-winst-execpython]]
=== ExecPython Sektionen

Die ExecPython Sektionen basieren auf Shell-Sektionen (ähnlich wie DosInAnIcon). Während diese den Inhalt der Sektion dem Interpreter cmd.exe übergeben, wird der Inhalt einer ExecPython Sektion dem Python Interpreter übergeben (welcher auf dem System installiert sein muss).

Beispiel

Das folgende Beispiel demonstriert einen execPython Aufruf mit einer Parameterliste zu dem 'print' Python-Kommando. 

Der Aufruf könnte wie folgt aussehen
[source,winst]
----
execpython_hello -a "option a" -b "option b" "there we are"

[execpython_hello]
import sys
print "we are working in path: ", a
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"


print "hello"
----

Die Ausgabe des Druck-(print) Kommandos wird gesammelt und in einen Logdatei geschrieben. So kann man die folgende Logdatei bekommen
[source,winst]
----
output:
 --------------
-a
option a
-b
option b
there we are
       hello
----

Anzumerken ist hierbei, dass der loglevel auf '1' gesetzt werden muss, damit die Ausgabe wirklich den Weg in die Logdatei findet.

[[opsi-winst-execpython-combine]]
==== Verflechten eines Python Skripts mit einem '{opsi-winst}' Skript

Aktuell ist die execPython Sektion dem '{opsi-winst}' Skript über vier Kategorien von gemeinsam genutzten Daten integriert:

* Eine Parameterliste geht zum Python Skript über.

* Alles was vom Python Skript gedruckt wird, wird in die '{opsi-winst}' log-Datei geschrieben.

* Der '{opsi-winst}' Skript Mechanismus für die Einführung von Konstanten und Variablen in Sektionen arbeitet erwartungsgemäß für die execPython Sektion.

* Die Ausgabe einer execPython Sektion kann umgewandelt werden in eine String-Liste und dann vom laufenden '{opsi-winst}' Skript weiter verwendet werden.

Ein Beispiel für die ersten beiden Wege der Verflechtung des Python Skripts mit dem '{opsi-winst}' Skript werden im Anschluss beschrieben. Es wurde erweitert, damit einige der Werte von '{opsi-winst}' Konstanten oder Variablen aufgerufen werden können.
[source,winst]
----
[execpython_hello]
import sys
a = "%scriptpath%"
print "we are working in path: ", a
print "my host ID is ", "%hostID%"
if len(sys.argv) > 1 :
	for arg in sys.argv[1:] :
		print arg
else: 
  print "no arguments"

print "the current loglevel is ", "$loglevel$" 
print "hello"
----

Allerdings muss die '$loglevel$' Variable vor dem Aufruf der ExecPython Sektionn gesetzt werden:
[source,winst]
----
DefVar $LogLevel$
set $loglevel$ = getLoglevel
----

Damit wir am Ende in der Lage sind, die Ergebnisse der Ausgabe weiter zu verarbeiten, wird eine String-List Variable erstellt, die über die execPython Sektion folgendermaßen aufgerufen werden kann:
[source,winst]
----
DefStringList pythonresult
Set pythonResult = GetOutStreamFromSection('execpython_hello -a "opt a“')
----

[[opsi-winst-execpython-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_compare_to_python$ = "on"'

[[opsi-winst-execwith]]
=== ExecWith Sektionen

'ExecWith' Sektionen sind verallgemeinerte 'DosBatch' bzw. 'ExecPython' Sektionen: Welches Programm den Inhalt der Sektionen ausführt wird durch einen Parameter beim Sektionsaufruf bestimmt.

Wenn der Aufruf so lautet: +
`execPython_hello -a "hello" -b "world"`
+
so sind
+
`-a "hello" -b "world"`
+
Parameter, die vom Phythonskript akzeptiert werden. Mit dem ExecWith Aufruf sieht der gleiche Ausdruck wie folgt aus:
+
`execWith_hello "python" PASS -a "hello" -b "world" WINST /EscapeStrings`

Die Option `/EscapeStrings` wird automatisch in der ExecPython Sektion benutzt und bedeutet, dass Backslahes und Konstanten in String-Variablen dupliziert werden, bevor sie das aufgerufene Programm interpretiert.

==== Aufrufsyntax

Generell haben wir die Aufrufsyntax:

`ExecWith`'_SECTION PROGRAM PROGRAMPARAS' `pass` 'PASSPARAS' `winst` 'WINSTOPTS'

Jeder der Ausdrücke 'PROGRAM, PROGRAMPARAS, PASSPARAS, WINSTOPTS' sind frei wählbare -Ausdrücke oder eine String-Konstante (ohne Anführungszeichen). 

Die Schlüsselwörter `PASS` und `WINST` dürfen fehlen, wenn der entsprechende Part nicht existiert.

Es gibt zwei weitere '{opsi-winst}' Optionen zu beachten:

*  `/EscapeStrings`

*  `/LetThemGo`

Wie bei ExecPython Sektionen wird die Ausgabe einer ExecWith Sektion in einer String-Liste über die Funktion `getOutStreamFromSection` erfasst.

Die erste Option erklärt, dass die Backslahes in '{opsi-winst}' Variablen und Konstanten sind - ähnlich wie in der Programmiersprache 'C'. Die zweite Option hat den Effekt (wie für `winBatch` Aufrufe), dass das aufgerufene Programm in einem neuen Thread seine Arbeit beginnt, während der '{opsi-winst}' mit dem Auslesen des Skripts fortfährt.

Mehr Beispiele

Der folgende Aufruf verweist auf eine Sektion, die ein 'autoit3'-Skript ist, dass auf zu öffnende Fenster wartet (dafür ist die Option `/letThemGo` zu benutzen), um sie dann in der aufgerufenen Reihenfolge zu schließen:
[source,winst]
----
ExecWith_close "%SCRIPTPATH%\autoit3.exe" WINST /letThemGo 
----

Ein einfacher Aufruf
[source,winst]
----
ExecWith_edit_me "notepad.exe"  WINST /letThemGo
----
öffnet einen Texteditor und zeigt die Sektionszeilen an (allerdings keine Zeilen die mit einem Komma starten, da der '{opsi-winst}' solche Zeilen als Kommentarzeile ausliest und sie eliminiert bevor sie ausgeführt werden).

[[opsi-winst-execwith-examples]]
==== Beispiele

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_autoit3_test$ = "on"'.

[[opsi-winst-ldapsearch]]
=== LDAPsearch Sektion

Eine LDAPsearch Sektion beschreibt eine Suchanfrage an ein LDAP Verzeichnis, die ausgeführt wird und auch die Antwort empfängt (und wenn möglich im Cache speichert). 

Bevor wir zu den '{opsi-winst}' Kommandos übergehen, gibt es erst noch einige Erklärungen zum Syntax von LDAP selbst

[[opsi-winst-ldapsearch-general]]
==== LDAP – Protokoll, Service, Verzeichnis

LDAP bedeutet "Lightweight Directory Access Protocol" und ist, wie der Name besagt, ein festgelegter Weg der Kommunikation mit einem Datenverzeichnis.

Dieses Verzeichnis ist für gewöhnlich hierarchisch organisiert. Es ist eine hierarchische Datenbank oder ein Datenbaum.

Ein *LDAP Service* implementiert das Protokoll zum Lesen und Schreiben auf diesem Verzeichnis. Ein Verzeichnis, dass über einen LDAP Service angesteuert werden kann, nennt sich *LDAP directory*.

Für ein Beispiel werfen einen Blick auf einen Bereich eines LDAP Verzeichnisbaums mit Daten aus dem opsi LDAP-Backend (angezeigt im Open Source LDAP-Browser JXPlorer).

.Ansicht von verschiedenen Bereichen des opsi LDAP Baums
image::../images/ldap-in-jxplorer.png["opsi LDAP Baum",width=400]

Ein *LDAP search request* ist ein Suchabfrage an das LDAP Verzeichnis über einen LDAP Service. Als Antwort werden verschiedene Inhalte des Datenverzeichnisses zurückgegeben.

Grundsätzlich beschreiben Suchabfragen den Pfad im Verzeichnisbaum, der zu der gewünschten Information führt. Der Pfad ist der *distinguished name* (dn) zusammen gesetzt aus den Namen der Knoten ( "relative distinguished names") welche den Pfad bilden. Zum Beispiel:

'local/uib/opsi/generalConfigs/bonifax.uib.local'

Da jeder Knoten als eine Instanz einer strukturellen Objektklasse konzipiert ist, wird die Pfadbeschreibung in folgender Form ausgegeben: mit  Klassentyp (und beginnend mit dem letzten Pfadelement):

'cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local'

Der Pfad in einer Abfrage muss nicht notwendigerweise „komplett“ sein und auch nicht zu einem einzelnen Blatt (Teil) des Baumes führen. Im Gegenteil, unvollständige Pfade sind üblich. 

Aber auch wenn der Pfad zu einem einzelnen Blatt führt, kann dieses wiederum mehrere Werte enthalten. Jeder Knoten des Baumes hat eine oder mehrere Klassen als Attributtypen. Zu jeder Klasse können ein oder mehrere Werte zugehörig sein. 

Bei einem gegebenen Abfragepfad könnten wir uns interessieren für 

. für die Knoten – auch LDAP Objekte genannt – zu welchen der Pfad führt,

. für die Attribute, die zu den Knoten gehören,

. und die Werte, die sowohl zu den Objekten wie zu den Attributen gehören.

Offensichtlich ist der Umgang mit der Fülle der Informationen möglicher Antworten die vorrangige Herausforderung bei der Abwicklung von LDAP Abfragen.

Der folgende Abschnitt zeigt eine LDAP Abfrage über den Bereich des LDAP Baums, welcher in der obenstehenden Grafik abgebildet ist.

Beispiel einer LDAP Antwort

Eine '{opsi-winst}' Sektion `ldapsearch_generalConfigs` ist wie folgt definiert:
[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=generalConfigs,cn=opsi,dc=uib,dc=local
----

Der Sektionsaufruf gibt eine LDAP Antwort zurück, die folgendermaßen aussieht:
[source,ini]
----
Result: 0
  Object: cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	generalConfigs
  Attribute: objectClass
	organizationalRole
Result: 1
  Object: cn=pcbon4.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: cn
	pcbon4.uib.local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: opsiKeyValuePair
	test2=test
	test=a b c d
Result: 2
  Object: cn=bonifax.uib.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
  Attribute: objectClass
	opsiGeneralConfig
  Attribute: cn
	bonifax.uib.local
  Attribute: opsiKeyValuePair
	opsiclientsideconfigcaching=FALSE
	pcptchlabel1=opsi.org
	pcptchlabel2=uib gmbh
	button_stopnetworking=
	pcptchbitmap1=winst1.bmp
	pcptchbitmap2=winst2.bmp
	debug=on
	secsuntilconnectiontimeout=280
	opsiclientd.global.log_level=
----

Es gibt nun verschiedene '{opsi-winst}' Optionen, um die Komplexität der Auswertung der Ergebnisse solcher Anfragen zu reduzieren und zu handhaben.

[[opsi-winst-ldapsearch-params]]
==== LDAPsearch Aufrufparameter

Für den Aufruf von LDAPSearch Sektionen sind zwei Typen von Optionen definiert.

* cache options
* output options

Die 'cache options' sind:

*  `/cache`

*  `/cached`

*  `/free`

* (no cache option)

Wenn keine cache Option spezifiziert wurde, wird die Antwort der LDAP Suche nicht für zukünftige Anwendung gespeichert.

Bei der `/cache` Option wird die Antwort für zukünftige Auswertungen gespeichert, die `/cached` Option verweist auf die letzte gespeicherte Antwort, welche wiederverwendet wird, statt eine neue Suche zu starten, die `/free` Option löscht die gecachten Antworten (dies ist vor allem bei Suchanfragen mit sehr langen Antworten sinnvoll).

Die output options sind: 

*  `/objects`

*  `/attributes`

*  `/values`

* (no output option)

Die Ausgabeoptionen bestimmen die String-Listen, die produziert werden, wenn eine LDAPsearch Sektion über getReturnlistFromSection aufgerufen wird:

* Wenn die Ausgabeoptionen nicht näher spezifiziert werden, wird die komplette LDAP Antwort aufgelistet.

* Die Optionen objects, attributes und values beschränken die Ausgabe entsprechend auf Zeilen zu Objekten, Attributen bzw. Werten in der LDAP Antwort.

Zu beachten ist, dass die ausgegebenen Listen von Attributen nur dann dem richtigen Objekt zu geordnet werden können, wenn die gesamte Ausgabe nur noch ein Objekt enthält. Ebenso sind Werte nur dann dem korrekten Attribut zuordnenbar, wenn nur noch ein Attribut in der Ausgabeliste vorkommt.

Daher wird so vorgegangen, dass eine ursprüngliche Suche immer weiter eingeengt wird bis nur noch ein Objekt bzw. Attribut zurückgegeben wird. Dies kann über entsprechende Count Aufrufe überprüft werden. 

Die Einengung der ursprünglichen Suche geht sehr schnell, wenn diese auf der gecachten Antwort durchgeführt wird.

[[opsi-winst-ldapsearch-narrow-search]]
==== Einengung der Suche

Ein Beispiel soll zeigen, wie die Suche soweit eingeschränkt werden kann, damit ein bestimmtes Ergebnis bei einer Suche im LDAP Verzeichnis erreicht werden kann.

Wir starten mit dem Aufruf von 'ldapsearch_generalConfigs' (wie oben beschrieben), fügen den cache Parameter hinzu,

`ldapsearch_generalconfigs /cache`

die Abfrage wird ausgeführt und die Antwort für zukünftige Nutzung gespeichert.

Dann gibt der Aufruf

`getReturnlistFromSection("ldapsearch_generalconfigs /cached /objects")`

folgende Liste aus
[source,ini]
----
cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=pcbon4.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----

Wenn wir die Auswahl im Baumverzeichnis mit
[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
----

einschränken und nochmal starten, enthält die Objektliste nur noch folgende Einträge
[source,ini]
----
cn=bonifax.uib.local,cn=generalconfigs,cn=opsi,dc=uib,dc=local
----

Die dazugehörige Attributliste enthält drei Elemente:
[source,ini]
----
objectclass
cn
opsikeyvaluepair
----

Um die zugehörigen Werte zu einem einzelnen Attribut zu bekommen, muss die Abfrage noch erweitert werden:
[source,winst]
----
[ldapsearch_generalConfigs]  
targethost: bonifax               
dn: cn=bonifax.ubi.local,cn=generalConfigs,cn=opsi,dc=uib,dc=local
attribute: opsiKeyValuePair
----

Das Ergebnis ist eine Attributliste, die nur ein Element enthält. Die Liste mit den zugehörigen Werten sieht wie folgt aus
[source,ini]
----
opsiclientsideconfigcaching=false
pcptchlabel1=opsi.org
pcptchlabel2=uib gmbh
button_stopnetworking=
pcptchbitmap1=winst1.bmp
pcptchbitmap2=winst2.bmp
debug=on
secsuntilconnectiontimeout=280
opsiclientd.global.log_level=6
----

Es gibt keine LDAP Mittel um diese Ergebnis noch weiter einzugrenzen!

(Aber die '{opsi-winst}' Funktion getValue (key, list) (vgl. <<opsi-winst-stringlist-getstring, Kapitel "(Wieder-) Gewinnen von Einzelstrings aus String-Listen">>) hilft in diesem Fall: z.B. getValue ("secsuntilconnectiontimeout", list) würde die gewünschte Zahl ausgeben).

Mit der Funktion `count` (list) kann überprüft werden, ob die Eingrenzung der Suchabfrage erfolgreich war. In den meisten Fällen ist gewünscht, dass das Ergebnis "1" ist.

[[opsi-winst-ldapsearch-syntax]]
==== LDAPsearch Sektion Syntax

Eine LDAPsearch Sektion beinhaltet die Spezifikationen:

*  `targethost:` +
Der Server, der das LDAP Verzeichnis verwaltet/gespeichert wird (service), muss benannt werden.

*  `targetport:` +
Wenn der Port eines LDAP Service nicht der voreingestellte Port von 389, muss er an dieser Stelle angegeben werden. Wenn die Spezifizierung nicht erfolgt, wird der Default-Port verwendet.

*  `dn:` +
Hier kann der charakteristische Name (distinguished name), der „Suchpfad“, für die Suchanfrage gegeben werden.

*  `typesonly:` +
Per Voreinstellung ist der Wert "false", was bedeutet das auch die Werte ermittelt werden.

*  `filter:` +
Der Filter für eine LDAP Suche hat eine spezielle LDAP Syntax, die nicht vom '{opsi-winst}' überprüft wird. Voreingestellt ist "(objectclass=*)".

*  `attributes:` +
Durch Kommas werden die Attributnamen in einer Liste getrennt. Die Default-Einstellung ist eine Liste, in der alle Attribute aufgeführt werden.

[[opsi-winst-ldapsearch-examples]]
==== Beispiele

Ein kurze und sehr realistische Beispiel soll am Ende dieses Abschnittes aufgeführt werden:

'$founditems$' ist eine StringList Variable und $opsiClient$ ist eine String-Variable. Der Aufruf von 'getReturnlistFromSection' liefert die Ergebnisse. Das nachfolgende Codefragment gibt das eindeutige Ergebnis für $opsiDescription$ zurück, wenn dieses existiert. Es vermeldet einen Fehler, wenn die Suche ein unerwartetes Ergebnis zurück gibt:
[source,winst]
----
set $opsiClient$ = "test.uib.local"
set $founditems$ = getReturnlistFromSection("ldapsearch_hosts /values")

DefVar $opsiDescription$
set $opsiDescription$ = ""
if count(founditems) = "1"
  set $opsiDescription$ = takeString(0, founditems)
else
  if count(founditems) = "0"
    comment "No result found")
  else
    logError "No unique result for LdAPsearch for client " + $opsiclient$ 
  endif
endif


[ldapsearch_hosts]  
targethost: opsiserver
targetport:               
dn: cn=$opsiclient$,cn=hosts,cn=opsi,dc=uib,dc=local
typesOnly: false
filter: (objectclass=*)
attributes: opsiDescription
----

Für weitere Beispiele beachten Sie das Produkt '{opsi-winst}-test'
und dort den Bereich '$Flag_winst_ldap_search$ = "on"'.

[[opsi-winst-64bit]]
== 64 Bit-Unterstützung

Der '{opsi-winst}' ist ein 32 Bit-Programm. Damit sich auch 32 Bit-Programme auf 64 Bit-Systemen normal arbeiten können, gibt es für 32 Bit-Programme sowohl in der Registry als auch im Dateisystem Spezialbereiche auf die Zugriffe umgeleitet werden, die sonst in 64 Bit vorbehaltenen Bereichen landen würden.

So wird ein Zugriff auf 'c:\windows\system32' umgelenkt auf 'c:\windows\syswow64'.

Aber ein Zugriff auf 'c:\program files' wird *nicht* umgelenkt auf 'c:\program files (x86)'

So wird ein Registry Zugriff auf '[HKLM\software\opsi.org]' umgelenkt auf '[HKLM\software\wow6432node\opsi.org]'.

{opsi-winst} installiert daher als 32 Bit-Programm Skripte, die unter 32 Bit laufen, auch in 64 Bit-Systemen korrekt. 

Für die Installation von 64 Bit-Programmen liefern einige alte Konstanten wie '%ProgramFilesDir%'´ für 64 Bit-Programme die falschen Werte. Daher gibt es ab winst Version 4.10.8 folgende Neuerungen:

In der Regel kann (und sollte) nun explizit angegeben werden, wohin geschrieben und woher gelesen werden soll. Dazu gibt es drei Varianten:

32::	Explizit 32 Bit

64::	Explizit 64 Bit. Wenn es das nicht gibt, dann architekturspezifisch.

SysNative::	Entsprechend der Architektur auf dem das SKript läuft.

Entsprechend gibt es zusätzlichen Konstanten:


.Konstanten
[options="header"]
|=======================
|Konstante|32 Bit|64 Bit
|`%ProgramFilesDir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles32Dir%`|c:\program files|c:\program files (x86)
|`%ProgramFiles64Dir%`|c:\program files|c:\program files
|`%ProgramFilesSysnativeDir%`|c:\program files|c:\program files
|=======================


`%ProgramFilesDir%`:: sollte in Zukunft besser gemieden werden.

`%ProgramFiles32Dir%`:: sollten Sie verwenden, wenn Sie explizit 32 Bit-Software installieren wollen.

`%ProgramFiles64Dir%`:: sollten Sie verwenden, wenn Sie explizit 64 Bit-Software installieren wollen.

`%ProgramFilesSysnativeDir%`:: sollten Sie verwenden, wenn Sie auf den Default der Architektur zugreifen wollen.

Für den Zugriff auf eigentlich 64 Bit-Software vorbehaltene Bereiche kennt der '{opsi-winst}' folgende zusätzlichen Befehle:

*  `GetRegistrystringvalue32`
*  `GetRegistrystringvalue64`
*  `GetRegistrystringvalueSysNative`
*  `FileExists32`
*  `FileExists64`
*  `FileExistsSysNative`

`Registry`-Sektionen schreiben in den 32 Bit-Bereich der Registry. Ebenfalls werden in `Files`-Sektionen Zugriffe auf 'c:\windows\system32' umgelenkt.

Für `Registry` und `Files` Sektionen gibt es daher nun die Aufrufparameter:

*  `/32Bit`
+
Das ist der Default. Schreibzugriffe werden in die 32 Bit-Registry bzw. das 32 Bit-Systemverzeichnis gelenkt.

*  `/64Bit` +
Schreibzugriffe werden in die 64 Bit-Registry bzw. das 64 Bit-Systemverzeichnis gelenkt. Gibt es diesen nicht, so wird der architekturspezifische Zweig verwendet.

*  `/SysNative` +
Schreibzugriffe werden in den architekturspezifischen Zweig der Registry bzw. des Systemverzeichnisses gelenkt.

Als weitere Möglichkeit für explizite 64 Bit-Operationen wird bei der Installation des opsi-client-agent die Datei 'c:\windows\system32\cmd.exe' nach 'c:\windows\cmd64.exe' kopiert. Durch den Aufruf von SKripten mit dieser 'cmd64.exe' im Rahmen von `ExecWith` Sektionen können beliebige 64 Bit-Operationen ausgeführt werden. 

Beispiele: +
File handling:
[source,winst]
----
if $INST_SystemType$ = "64 Bit System"
	comment ""
	comment "-------------------------------------"
	comment "Testing: "
	message "64 Bit redirection"
	Files_copy_test_to_system32
	if FileExists("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 'cmd.exe' /C
	Files_copy_test_to_system32 /64Bit
	if FileExists64("%System%\dummy.txt")
		comment "passed"
	else
		LogWarning "failed"
		set $TestResult$ = "not o.k."
	endif
	ExecWith_remove_test_from_system32 '%SystemRoot%\cmd64.exe' /C
endif
----

Registry Handling:
[source,winst]
----
message "Write to 64 Bit Registry"
if ($INST_SystemType$ = "64 Bit System")
	set $ConstTest$ = ""
	set $regWriteValue$ = "64"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "%systemroot%\cmd64.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
else
	set $regWriteValue$ = "32"
	set $CompValue$ = $regWriteValue$
	Registry_opsi_org_test /64Bit
	ExecWith_opsi_org_test "cmd.exe" /c
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByWinst")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
	set $ConstTest$ = GetRegistryStringValue64("[HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\test] bitByReg")
	if ($ConstTest$ = $CompValue$)
		comment "passed"
	else
		set $TestResult$ = "not o.k."
		comment "failed"
	endif
endif

if ($INST_SystemType$ = "64 Bit System")
	set $regWriteValue$ = "64"
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
else
	set $regWriteValue$ = "32"
	Registry_hkcu_opsi_org_test /AllNtUserDats 
	Registry_hkcu_opsi_org_test /AllNtUserDats /64Bit
endif
----

[[opsi-winst-cookbook]]
== Kochbuch

In diesem Kapitel sind Skript-Beispiele zusammengestellt, wie durch den Einsatz verschiedener '{opsi-winst}' Funktionen gewisse Aufgaben, die sich in ähnlicher Weise immer wieder stellen, bewältigt werden können.

[[opsi-winst-cookbook-recursive-delete]]
=== Löschen einer Datei in allen Userverzeichnissen

Seit '{opsi-winst}' Version 4.2 gibt es für diese Aufgabe eine einfache Lösung: Wenn etwa die Datei alt.txt aus allen Userverzeichnissen gelöscht werden soll, so kann der folgende Files-Sektions-Aufruf verwendet werden:
[source,winst]
----
files_delete_Alt /allNtUserProfiles

[files_delete_Alt]
delete "%UserProfileDir%\alt.txt"
----

Für ältere '{opsi-winst}' Versionen sei hier noch ein Workaround dokumentiert, der hilfreiche Techniken enthält, die eventuell für andere Zwecke dienen können.
Folgende Zutaten werden benötigt:

* Eine DosInAnIcon-Sektion, in der ein dir-Befehl die Liste aller Verzeichnisnamen produziert.

* Eine Files-Sektion, die das Löschen der Datei alt.txt in einem bestimmten Verzeichnis anstößt.

* Eine String-Listen-Verarbeitung, die alles miteinander verknüpft.

Das Ganze kann z.B. so aussehen:
[source,winst]
----
; in der Actions-Sektion:

; Variable für den Dateinamen:
DefVar $loeschDatei$ = "alt.txt"

; Variablendeklaration für die String-Listen
DefStringList list0
DefStringList list1

; Einfangen der vom Dos-dir-Befehl produzierten Zeilen
Set list0 = getOutStreamFromSection ('dosbatch_profiledir')

; Aufruf einer Files-Sektion für jede Zeile
for $x$ in list0 do files_delete_x

; Und hier die beiden benötigten Spezialsektionen:
[dosbatch_profiledir]
dir "%ProfileDir%" /b

[files_delete_x]
delete "%ProfileDir%\$x$\$LoeschDatei$"
----

[[opsi-winst-cookbook-service-running]]
=== Überprüfen, ob ein spezieller Service läuft

Wenn wir überprüfen wollen, ob eine spezieller Service (beispielsweise der "opsiclientd") läuft und ihn, falls er nicht läuft, starten wollen, müssen wir folgendes Skript verwenden.

Um eine Liste der laufenden Services angezeigt zu bekommen, müssen wir das Kommando +
`net start` + 
in einer DosBatch Sektion starten und das Ergebnis in der $list0$ erfassen. Wir gleichen die Liste ab und iterieren die Elemente, um zu sehen, ob der spezielle Service beinhaltet ist. Wenn er nicht da ist, wird er gestartet.
[source,winst]
----
[Actions]
DefStringList $list0$
DefStringList $list1$
DefStringList $result$
Set $list0$=getOutStreamFromSection('DosBatch_netcall')
Set $list1$=getSublist(2:-3, $list0$)

DefVar $myservice$
DefVar $compareS$
DefVar $splitS$
DefVar $found$
Set $found$ ="false"
set $myservice$ = "opsiclientd"


comment "============================"
comment "search the list"
; for developping loglevel = 7
; setloglevel=7
; in normal use we dont want to log the looping
setloglevel = 5
for %s% in $list1$ do sub_find_myservice
setloglevel=7
comment "============================"

if $found$ = "false"
   set $result$ = getOutStreamFromSection ("dosinanicon_start_myservice")
endif


[sub_find_myservice]
set $splitS$ = takeString (1, splitStringOnWhiteSpace("%s%"))
Set $compareS$ = $splitS$ + takeString(1, splitString("%s%", $splitS$))
if $compareS$ = $myservice$
   set $found$ = "true"
endif


[dosinanicon_start_myservice]
net start "$myservice$"


[dosbatch_netcall]
@echo off
net start 
----

[[opsi-winst-cookbook-local-admin]]
=== Skript für Installationen im Kontext eines lokalen Administrators

In manchen Situationen kann es sinnvoll oder notwendig sein, ein '{opsi-winst}' Skript als lokal eingeloggter Benutzer auszuführen anstatt wie üblich im Kontext eines Systemdienstes. Beispielsweise kann es sein, dass Softwareinstallationen, die vom '{opsi-winst}' aus aufgerufen werden, zwingend einen Benutzerkontext benötigen oder dass bestimmte Dienste, die für den Installationsvorgang wichtig sind, erst nach dem Login zur Verfügung stehen. 

MSI-Installationen, die eine lokalen User benötigen lassen, sich häufig durch die Option 'ALLUSERS=2' dazu "überreden" auch ohne aus zukommen. Beispiel:
[source,winst]
----
[Actions]
DefVar $LOG_LOCATION$
Set $LOG_LOCATION$ = "c:\tmp\myproduct.log"
winbatch_install_myproduct

[winbatch_install_myproduct]
msiexec /qb ALLUSERS=2 /l* $LOG_LOCATION$ /i %SCRIPTPATH%\files\myproduct.msi
----

Eine andere aufwendigere Möglichkeit dieses Problem zu lösen, ist einen administrativen User temporär anzulegen und diesen zur Installation des Programms zu verwenden.

Dazu gehen Sie wie folgt vor:

Legen im Verzeichnis 'install\produkid' ein Verzeichnis 'localsetup' an.
Verschieben Sie die gesamten Installationsdateien in dieses Verzeichnis.
Benennen Sie das Installationsscript von '<produktname>.ins' in 'local_<produktname>.ins' um.
Erzeugen Sie im Verzeichnis 'install\produktname' eine neue '<produktname>.ins' mit dem nachfolgenden Inhalt und passen Sie in diesem SKript in der Actions-Sektion die Variablen an (siehe unten). Der Rest des Skriptes bleibt unberührt.

Sorgen Sie dafür, dass das in 'local_<produktname>.ins' umbenannte Skript am Ende einen *Reboot* auslöst. 

Dazu sollte der letzte ausgeführte Befehl der Actions-Sektion folgende Zeile sein:

`ExitWindows /Reboot`

Am Anfang des 'local_<produktname>.ins' Skripts fügen Sie einen Aufruf ein um das Passwort des temporären lokalen Administrators im Autologin zu löschen:
[source,winst]
----
[Actions]
Registry_del_autologin
;....

[Registry_del_autologin]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"=""
set "DefaultPassword"=""
----
Das nachfolgende abgedruckte '{opsi-winst}' Skript-Template erzeugt temporär den gewünschten Benutzerkontext, führt in ihm eine Installation aus und beseitigt ihn schließlich wieder. Für die Verwendung sind die folgende Variablen zusetzen:

* der richtige Wert für die Variable `$Productname$`,
* der richtige Wert für die Variable `$ProductSize$` und
* `$LockKeyboard$` auf „true“, um das Keyboard zu sperren.

Das Skript führt im Einzelnen folgende Schritte aus:

* Anlegen eines lokalen Administrator opsiSetupAdmin;
* Sichern des bisherigen Autologon-Zustands;
* Eintragen des opsiSetupAdmin als Autologon-User;
* Installationsdateien auf den Client kopieren (wohin steht in `$localFilesPath$`), dort befindet sich das Installationsskript, das als lokaler Benutzer ausgeführt werden soll;
* RunOnce-Eintrag in der Registry anlegen, der den '{opsi-winst}' mit dem lokalen Skript als Argument aufruft;
* Neustart des Client (damit die Änderungen an der Registry Wirkung haben);
* '{opsi-winst}' startet und führt ExitWindows /ImmediateLogout aus: durch den Autologon meldet sich nun automatisch der Benutzer opsiSetupAdmin an, es wird der RunOnce-Befehl ausgeführt;
* nun läuft die Installation ganz normal, jedoch am Ende des Skripts muss zwingend neugestartet werden (also mit ExitWindows /ImmediateReboot), da sonst die Oberfläche des momentan eingeloggten Users opsiSetupAdmin mit Administratorrechten(!) freigegeben wird;
* nach dem Reboot wird wieder aufgeräumt (alten Zustand von Autologon wiederherstellen, lokale Setup-Dateien löschen, Benutzerprofil von opsiSetupAdmin löschen).

Wie man sieht, gliedert sich die Installation in 2 Bereiche: ein Skript, das als Service ausgeführt wird, alles zum lokalen Login vorbereitet und später wieder aufräumt (Masterscript) und ein Skript, dass als lokaler Administrator ausgeführt wird und die eigentliche Setup-Routine für das Produkt enthält (Localscript).

CAUTION: Erfordert das Localscript mehr als nur einen Reboot, muss auch das Masterscript verändert bzw. um diese Anzahl von Reboots erweitert werden. Solange das Localscript nicht fertig ist, muss das Masterscript ein ExitWindows /ImmediateLogout ausführen, um die Kontrolle an das Localscript zu übergeben. Der RunOnce-Eintrag muss dann immer wieder neu gesetzt werden. Ebenso müssen Username und Passwort des Autologins nach jedem Reboot neu gesetzt werden.

Es gibt keinen direkten Zugang vom lokalen Skript auf die Produkteigenschaften (üblicherweise erfolgt der Zugang über die String-Funktion GetProductProperty). Wenn Werte benötigt werden, müssen diese über das Masterskript geholt werden und werden ggf. temporär in der Registry gespeichert.

Es kann Produktinstallationen (also aus dem Localscript heraus) geben, die Schlüssel in der Registry verändern, die vorher vom Masterscript gesichert und am Ende durch dieses wieder überschreiben werden. In diesem Fall muss die Wiederherstellung der Werte im Masterscript unterbunden werden.

Das Localscript läuft unter eingeloggtem Administrator Account. Wenn hier nicht Keyboard/Maus gesperrt werden, besteht für den Anwender die Möglichkeit das Skript zu unterbrechen und Administrator zu werden.

Das Passwort des temporären opsiSetupAdmin wird in nachfolgenden Beispiel durch die Funktion RandomStr bestimmt.

Damit die Verarbeitung der Passwörter nicht geloggt wird, wird der LogLevel zeitweise auf -2 gesetzt.

IMPORTANT: Verwenden Sie aktualisierte Versionen des folgenden Beispiels aus dem Templateprodukt: opsi-template-with-admin.
[source,winst]
----
; Copyright (c) uib gmbh (www.uib.de)
; This sourcecode is owned by uib
; and published under the Terms of the General Public License.

; TEMPLATE for
; Skript fuer Installationen im Kontext eines temporaeren lokalen Administrators
; installations as temporary local admin
; see winst_manual.pdf / winst_handbuch.pdf

; !!! requires winst32.exe version 4.2.x !!!

;
; !!! Das lokale Installations-Skript, das durch den temporaeren lokalen Admin ausgefuehrt wird
; !!! (sein Name steht in $LocalSetupScript$), muss mit dem Befehl  
; !!! exitWindows /Reboot
; !!! enden
; 

; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; Vorarbeiten/Voraussetzungen/Doku pruefen wie in Winsthandbuch
; 8.3 Skript fuer Installationen im Kontext eines lokalen Administrators
; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


[Actions]
requiredWinstVersion >= 4.10.6
setLogLevel=7
DefVar $ProductName$
DefVar $ProductSizeMB$
DefVar $LocalSetupScript$
DefVar $LockKeyboard$
DefVar $OpsiAdminPass$
DefVar $OS$
DefVar $MinorOS$
DefVar $MsVersion$
DefVar $RebootFlag$
DefVar $ShutdownRequested$
DefVar $WinstRegKey$
DefVar $RebootRegVar$
DefVar $AutoName$
DefVar $AutoPass$
DefVar $AutoDom$
DefVar $AutoLogon$
DefVar $AutoBackupKey$
DefVar $LocalFilesPath$
DefVar $LocalWinst$
DefVar $SystemType$
DefVar $platform_cmdexe$
DefVar $DefaultLoglevel$
DefVar $PasswdLogLevel$
DefVar $AdminGroup$
DefVar $SearchResult$

DefStringlist $ResultList$
DefStringlist $ResultList2$
DefStringlist $ResultList3$

comment "set $LockKeyboard$ to true to prevent user hacks while admin is logged in"
Set $LockKeyboard$="true"
Set $LockKeyboard$="false"
Set $ProductName$ = "opsi-template-with-admin"
Set $ProductSizeMB$ = "1"

Set $LocalSetupScript$ = "local_setup.ins"
set $OS$ = GetOS
set $MinorOS$ = GetNTVersion
Set $SystemType$ = GetSystemType
Set $MsVersion$ = GetMsVersionInfo
set $DefaultLoglevel$ = "7"
comment " set $PasswdLogLevel$ to 0 for production"
Set $PasswdLogLevel$="7"
SetLogLevel=$DefaultLoglevel$

if not (fileExists ("%Scriptpath%\psgetsid.exe"))
	LogError "psgetsid.exe is missing. Please install it from http://download.sysinternals.com/Files/PsTools.zip to %Scriptpath%"
	isFatalError
endif

if not(($SystemType$ = "64 Bit System") or ($SystemType$ = "x86 System"))
	LogError "Unknown Systemtype: "+$SystemType$+" - aborting"
	isFatalError
endif

if $SystemType$ = "64 Bit System"
	set $platform_cmdexe$ = "%SystemRoot%\cmd64.exe"
else
	set $platform_cmdexe$ = "%System%\cmd.exe"
endif

comment "handle Rebootflag"
Set $WinstRegKey$ = "HKLM\SOFTWARE\opsi.org\winst"
Set $RebootFlag$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"RebootFlag")
Set $ShutdownRequested$ = GetRegistryStringValue("["+$WinstRegKey$+"] "+"ShutdownRequested")

sub_test_autologon_data

comment "some paths required"
Set $AutoBackupKey$ = $WinstRegKey$+"\AutoLogonBackup"
Set $LocalFilesPath$ = "C:\opsi_local_inst"
Set $LocalWinst$ = "c:\opsi\utils\winst32.exe"
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\preloginloader\utils\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\preloginloader\opsi-winst\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	Set $LocalWinst$ = "%ProgramFilesDir%\opsi.org\opsi-client-agent\opsi-winst\winst32.exe"
endif
if not( FileExists($LocalWinst$) )
	LogError "No opsi-winst found. Abborting."
	isFatalError
endif

comment "show product picture"
ShowBitmap /3 "%scriptpath%\localsetup\"+$ProductName$+".png" $ProductName$

if not (($RebootFlag$ = "1") or ($RebootFlag$ = "2") or ($RebootFlag$ = "3"))
	comment "Part before first Reboot"
	comment "just reboot - this must be done if this is the first product after OS installation"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "1"
	Registry_SaveRebootFlag
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2 or 3)

if $RebootFlag$ = "1"
	comment "Part before second Reboot"

	if not(HasMinimumSpace ("%SYSTEMDRIVE%", ""+$ProductSizeMB$+" MB"))
		LogError "Not enough space on drive C: . "+$ProductSizeMB$+" MB on C: required for "+$ProductName$
		isFatalError
	endif
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 1..."
	sub_Prepare_AutoLogon

	comment "we need to reboot now to be sure that the autologon work"
	comment "handle Rebootflag"
	Set $RebootFlag$ = "2"
	Registry_SaveRebootFlag
	sub_test_autologon_data
	ExitWindows /ImmediateReboot
endif ; Rebootflag = not (1 or 2)

if ($RebootFlag$ = "2")
	comment "Part after first Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "3"
	Registry_SaveRebootFlag
	
	comment "Lets work..."
	Message "Preparing "+$ProductName$+" install step 2..."
	Registry_enable_keyboard /64bit
	comment "now let the autologon work"
	comment "it will stop with a reboot"
	ExitWindows /ImmediateLogout
endif ; Rebootflag = 2

if ($RebootFlag$ = "3")
	comment "Part after second Reboot"
	
	comment "handle Rebootflag"
	Set $RebootFlag$ = "0"
	Registry_SaveRebootFlag
	
	comment "Lets work..."
	Message "Cleanup "+$ProductName$+" install (step 3)..."
	sub_Restore_AutoLogon
	set $SearchResult$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce] opsi_autologon_setup")
	if $SearchResult$ = $LocalWinst$+" "+$LocalFilesPath$+"\"+$LocalSetupScript$+" /batch"
		LogError "Localscript did not run. We remove the RunOnce entry and abort"
		Registry_del_runonce /64Bit
		isFatalError
	endif
	comment "This is the clean end of the installation"
endif ; Rebootflag = 3
ExitWindows /Reboot

[sub_Prepare_AutoLogon]
comment "copy the setup script and files"
Files_copy_Setup_files_local
comment "read actual Autologon values for backup"
set $AutoName$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultUserName")
comment "if AutoLogonName is our setup admin user, something bad happend"
comment "then let us cleanup"
if ($AutoName$="opsiSetupAdmin")
	set $AutoName$=""
	set $AutoPass$=""
	set $AutoDom$=""
	set $AutoLogon$="0"
else
	set $AutoPass$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
	set $AutoDom$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
	set $AutoLogon$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")
endif

comment "backup AutoLogon values"
Registry_save_autologon

comment "prepare the admin AutoLogon"
SetLogLevel=$PasswdLogLevel$
set $OpsiAdminPass$= randomstr
Registry_autologon /64Bit

comment "get the name of the admin group"
comment "using psgetsid from sysinernals pstools"
set $ResultList$ = getOutStreamFromSection("DosInAnIcon_get_admin_group")
set $AdminGroup$ = takeString(6,$ResultList$)
set $AdminGroup$ = takeString(1,splitstring($AdminGroup$,"\"))
comment "create our setup admin user"
DosInAnIcon_makeadmin
SetLogLevel=$DefaultLoglevel$

comment "remove c:\tmp\winst.bat with password"
Files_remove_winst_bat

comment "store our setup script as run once"
Registry_runOnce /64Bit

comment "disable keyboard and mouse while the autologin admin works"
if ($LockKeyboard$="true")
	Registry_disable_keyboard /64Bit
endif

[sub_test_autologon_data]
set $AutoPass$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultPassword")
set $AutoDom$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] DefaultDomainName")
set $AutoLogon$ = GetRegistryStringValue64("[HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon] AutoAdminLogon")

[sub_Restore_AutoLogon]
comment "read AutoLogon values from backup"
set $AutoName$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultUserName")
set $AutoPass$ = GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultPassword")
set $AutoDom$= GetRegistryStringValue("["+$AutoBackupKey$+"] DefaultDomainName")
set $AutoLogon$= GetRegistryStringValue("["+$AutoBackupKey$+"] AutoAdminLogon")

comment "restore the values"
SetLogLevel=$PasswdLogLevel$
Registry_restore_autologon /64Bit
SetLogLevel=$DefaultLoglevel$
comment "delete our setup admin user"
DosInAnIcon_deleteadmin
comment "cleanup setup script, files and profiledir"
Files_delete_Setup_files_local
comment "delete profiledir"
DosInAnIcon_deleteprofile

[Registry_save_autologon]
openkey [$AutoBackupKey$]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[Registry_restore_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="$AutoName$"
set "DefaultPassword"="$AutoPass$"
set "DefaultDomainName"="$AutoDom$"
set "AutoAdminLogon"="$AutoLogon$"

[DosInAnIcon_deleteadmin]
NET USER opsiSetupAdmin  /DELETE

[Registry_SaveRebootFlag]
openKey [$WinstRegKey$]
set "RebootFlag" = "$RebootFlag$"

[Files_copy_Setup_files_local]
copy -s %ScriptPath%\localsetup\*.* $LocalFilesPath$

[Files_delete_Setup_files_local]
delete -sf $LocalFilesPath$
; folgender Befehl funktioniert nicht vollständig, deshalb ist er zur Zeit auskommentier
; der Befehl wird durch die Sektion "DosInAnIcon_deleteprofile" ersetzt (P.Ohler)
;delete -sf "%ProfileDir%\opsiSetupAdmin"

[DosInAnIcon_deleteprofile]
rmdir /S /Q "%ProfileDir%\opsiSetupAdmin"

[DosInAnIcon_get_admin_group]
@echo off
"%ScriptPath%\psgetsid.exe" /accepteula S-1-5-32-544

[DosInAnIcon_makeadmin]
NET USER opsiSetupAdmin $OpsiAdminPass$ /ADD
NET LOCALGROUP $AdminGroup$ /ADD opsiSetupAdmin

[Registry_autologon]
openkey [HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon]
set "DefaultUserName"="opsiSetupAdmin"
set "DefaultPassword"="$OpsiAdminPass$"
set "DefaultDomainName"="localhost"
set "AutoAdminLogon"="1"

[Registry_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
set "opsi_autologon_setup"='"$LocalWinst$" "$LocalFilesPath$\$LocalSetupScript$" /batch'

[Registry_del_runonce]
openkey [HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce]
DeleteVar "opsi_autologon_setup"

[Registry_disable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x4
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x4

[Registry_enable_keyboard]
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Kbdclass]
set "Start"=REG_DWORD:0x1
openkey [HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Mouclass]
set "Start"=REG_DWORD:0x1

[Files_remove_winst_bat]
delete -f c:\tmp\_winst.bat
----

[[opsi-winst-cookbook-patchxml]]
=== XML-Datei patchen: Setzen des Vorlagenpfades für OpenOffice.org 2.0

Das Setzen des Vorlagenpfades kann mit Hilfe der folgenden Skriptteile erfolgen:
[source,winst]
----
[Actions]
; ....

DefVar $oooTemplateDirectory$
;----------------------------------------------------------------------
;set path here:

Set $oooTemplateDirectory$ = "file://server/share/verzeichnis"
;----------------------------------------------------------------------
;...

DefVar $sofficePath$
Set $sofficePath$= GetRegistryStringValue ("[HKEY_LOCAL_MACHINE\SOFTWARE\OpenOffice.org\OpenOffice.org\2.0] Path")
DefVar $oooDirectory$
Set $oooDirectory$= SubstringBefore ($sofficePath$, "\program\soffice.exe")
DefVar $oooShareDirectory$
Set $oooShareDirectory$ = $oooDirectory$ + "\share"

XMLPatch_paths_xcu $oooShareDirectory$+"\registry\data\org\openoffice\Office\Paths.xcu"
; ...


[XMLPatch_paths_xcu]
OpenNodeSet
- error_when_no_node_existing false
- warning_when_no_node_existing true
- error_when_nodecount_greater_1 false
- warning_when_nodecount_greater_1 true
- create_when_node_not_existing true
- attributes_strict false

documentroot
all_childelements_with:
elementname: "node"
attribute:"oor:name" value="Paths"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="Template"
all_childelements_with:
elementname: "node"
attribute: "oor:name" value="InternalPaths"
all_childelements_with: 
elementname: "node"

end

SetAttribute "oor:name" value="$oooTemplateDirectory$"
----

[[opsi-winst-cookbook-readxml]]
=== XML-Datei einlesen mit dem {opsi-winst}

Wie bereits im vorangehenden <<opsi-winst-cookbook-patchxml,Kapitel "XML-Datei patchen">> beschrieben, lassen sich auch XML-Dateien mit dem '{opsi-winst}' einlesen. Hier soll nun exemplarisch gezeigt werden, wie man die Werte eines bestimmten Knotens ausliest. Als Quelle dient dazu folgende XML-Datei:
[source,winst]
----
<?xml version="1.0" encoding="utf-16" ?>
<Collector xmlns="http://schemas.microsoft.com/appx/2004/04/Collector" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:schemaLocation="Collector.xsd" UtcDate="04/06/2006 12:28:17" LogId="{693B0A32-76A2-4FA0-979C-611DEE852C2C}"  Version="4.1.3790.1641" >
   <Options>
      <Department></Department>
      <IniPath></IniPath>
      <CustomValues>
      </CustomValues>
   </Options>
   <SystemList>
      <ChassisInfo Vendor="Chassis Manufacture" AssetTag="System Enclosure 0" SerialNumber="EVAL"/>
      <DirectxInfo Major="9" Minor="0"/>
   </SystemList>
   <SoftwareList>
      <Application Name="Windows XP-Hotfix - KB873333" ComponentType="Hotfix" EvidenceId="256" RootDirPath="C:\WINDOWS\$NtUninstallKB873333$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x4235b909">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873333" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873333$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873333" UninstallString="C:\WINDOWS\$NtUninstallKB873333$\spuninst\spuninst.exe" OsComponent="true" UniqueId="256"/>
         </Evidence>
      </Application>
      <Application Name="Windows XP-Hotfix - KB873339" ComponentType="Hotfix" EvidenceId="257" RootDirPath="C:\WINDOWS\$NtUninstallKB873339$\spuninst" OsComponent="true" Vendor="Microsoft Corporation" Crc32="0x9c550c9c">
         <Evidence>
            <AddRemoveProgram DisplayName="Windows XP-Hotfix - KB873339" CompanyName="Microsoft Corporation" Path="C:\WINDOWS\$NtUninstallKB873339$\spuninst" RegistryPath="HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Uninstall\KB873339" UninstallString="C:\WINDOWS\$NtUninstallKB873339$\spuninst\spuninst.exe" OsComponent="true" UniqueId="257"/>
         </Evidence>
      </Application>
   </SoftwareList>
</Collector>
----

Möchte man nur die Elemente und deren Werte aller „Application“-Knoten auslesen, kann man dies machen mit folgendem Code (nur Ausschnitt):
[source,winst]
----
[Actions]
DefStringList $list$

...

set $list$ = getReturnListFromSection ('XMLPatch_findProducts '+$TEMP$+'\test.xml')
for $line$ in $list$ do Sub_doSomething

[XMLPatch_findProducts]
openNodeSet
	; Knoten „Collector“ ist der documentroot
	documentroot
	all_childelements_with:
	  elementname:"SoftwareList"
	all_childelements_with:
	  elementname:"Application"
end
return elements

[Sub_doSomething]
set $escLine$ = EscapeString:$line$
; hier kann man nun diese Elemente in $escLine$ bearbeiten
----

Hier sieht man auch eine weitere Besonderheit. Es sollte vor dem Benutzen der eingelesenen Zeilen erst ein EscapeString der Zeile erzeugt werden, damit enthaltene Sonderzeichen nicht vom '{opsi-winst}' interpretiert werden. Die Zeile wird nun gekapselt behandelt, sonst könnten reservierte Zeichen wie $,%,“ oder \' leicht zu unvorhersehbaren Fehlfunktionen führen.

'
[[opsi-winst-cookbook-xmlnamespace]]
=== Einfügen einer Namensraumdefinition in eine XML-Datei 

Die '{opsi-winst}' XMLPatch-Sektion braucht eine voll ausgewiesenen XML Namensraum (wie es im XML RFC gefordert wird). Aber es gibt XML Konfigurationsdateien, in denen „nahe liegende“ Elemente nicht deklariert werden (und auslesende Programme, die auch davon ausgehen, dass die Konfigurationsdatei entsprechend aussieht). 

Besonders das Patchen der meisten XML/XCU Konfigurationsdateien von OpenOffice.org erweist sich als sehr schwierig. Um dieses Problem zu lösen hat A. Pohl (Vielen Dank!) die Funktionen XMLaddNamespace und XMLremoveNamespace entwickelt. Die Funktionsweise ist im folgenden Beispiel demonstriert:
[source,winst]
----
DefVar $XMLFile$
DefVar $XMLElement$
DefVar $XMLNameSpace$
set $XMLFile$ = "D:\Entwicklung\OPSI\winst\Common.xcu3" 
set $XMLElement$ = 'oor:component-data'
set $XMLNameSpace$ = 'xmlns:xml="http://www.w3.org/XML/1998/namespace"'

if XMLAddNamespace($XMLFile$,$XMLElement$, $XMLNameSpace$) 
  set $NSMustRemove$="1" 
endif 
;
; now the XML Patch should work
; (commented out since not integrated in this example)
;
; XMLPatch_Common $XMLFile$ 
;
; when finished we rebuild the original format 
if $NSMustRemove$="1" 
  if not (XMLRemoveNamespace($XMLFile$,$XMLElement$,$XMLNameSpace$)) 
    LogError "XML-Datei konnte nicht korrekt wiederhergestellt werden"    
    isFatalError
  endif 
endif 
----

Es ist zu beachten, dass die XML Datei so formatiert wird, dass der Element-Tag-Bereich keine Zeilenumbrüche enthält. 


[[opsi-winst-special-errors]]
== Spezielle Fehlermeldungen

* Keine Verbindung mit dem opsi-Service +
Der '{opsi-winst}' meldet "... cannot connect to service".

Hinweise auf mögliche Probleme gibt die dazu angezeigte Nachricht:

Socket-Fehler #10061, Verbindung abgelehnt::
Möglicherweise läuft der Service nicht

Socket-Fehler #10065, Keine Route zum Host::
Keine Netzwerkverbindung zum Server

HTTP/1.1. 401 Unauthorized::
Der Service antwortet, akzeptiert aber das Passwort nicht.



