////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; http://creativecommons.org/licenses/by-sa/3.0/de/
; http://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; http://creativecommons.org/licenses/by-sa/3.0/
; http://creativecommons.org/licenses/by-sa/3.0/legalcode
; 
; credits: http://www.opsi.org/credits/
////


:Author:    uib gmbh
:Email:     info@uib.de
:Date:      11.07.2012
:Revision:  4.0.2
:doctype:		book

// Include common opsi terms
include::../common/opsi_terms.asciidoc[]



opsi-winst (4.11.3): Was ist neu ?
==================================



// Include common opsi copyright
include::../common/opsi_manual_copyright.asciidoc[]


== Start und Aufrufparameter

Der '{opsi-winst}' enthält seit Version 4.11.3 ein Manifest mit der Option: +
`<requestedExecutionLevel level="highestAvailable" />`. Dies bedeutet, dass unter NT6 als Administrator aufgerufen, versucht wird als 'elevated' Prozess zu arbeiten. Wird der '{opsi-winst}' mit User Rechten aufgerufen, so läuft er unter den Rechten dieses Users.

[[opsi-winst-global-const]]
== Globale Textkonstanten


[[opsi-winst-global-const-list-winst]]
=== '{opsi-winst}' Pfad und Verzeichnisse


`%opsiScriptHelperPath%` +
Entspricht: '%ProgramFiles32Dir%\opsi.org\opsiScriptHelper'` +
Pfad in dem Hilfsprogramme, Libraries und ähnliches zur Scriptausführung installiert sein können. +
Seit 4.11.3.2


== Primäre Sektionen

[[opsi-winst-params-errors]]
==== Reaktion auf Fehler

*  `FatalOnSyntaxError =` <Wahrheitswert> +
** 'true' = (default) Bei einem Syntaxfehler wird das Script abgebrochen und 'failed' zurückgeliefert. Dem Server wird die Meldung 'Syntax Error' übergeben.
** 'false' = Bei einem Syntaxfehler wird das Script +nicht+ abgebrochen.

Der Syntaxfehler wird in jedem Fall als 'Critical' in die Logdatei übernommen. +
In jedem Fall wird der Errorcounter um 1 erhöht. +
Seit 4.11.3.2 +
In älteren Versionen wird weder gelogged noch abgebrochen.


[[opsi-winst-params-showmode]]
=== Fenster Modus

* `NormalizeWinst` +
setzt das '{opsi-winst}' Fenster auf 'normal' Modus.

* `IconizeWinst` +
setzt das '{opsi-winst}' Fenster auf 'minimierten' Modus.

* `RestoreWinst` +
setzt das '{opsi-winst}' Fenster auf 'maximierten' Modus.

[[opsi-winst-commands-include]]
=== Include Kommandos

[[opsi-winst-commands-include-syntax]]
==== Include Kommandos: Syntax

Mit Include Kommandos kann der Inhalt einer externen Datei dem laufende Script hinzugefügt werden. Dies kann entweder einfügend oder anhängend erfolgen. Die Include Kommandos sind normale Kommandos der primären Sektionen. Die eingefügten Dateien können weitere Include Kommandos enthalten. +
Diese Kommandos gibt es seit Version 4.11.3

* `include_insert` <file name> +
Fügt den Inhalt von <file name> nach der aktuellen Zeile im laufenden Script ein. Somit ist die erste Zeile der eingefügten Datei die nächste Zeile welche der '{opsi-winst}' interpretiert.

* `include_append` <file name> +
Fügt den Inhalt von <file name> am Ende des laufenden Scriptes ein. Diese Anweisung dient vor allem dazu Sektionen aus z.B. einer Bibliothek hinzu zufügen.

Für beide Funktionen gilt: +
<file name> ist:

* Ein kompletter Pfad zu einer Datei.

* Eine Datei in `%ScriptPath%`

* Eine Datei in `%opsiScriptHelperPath%\lib` +
Entspricht: '%ProgramFiles32Dir%\opsi.org\opsiScriptHelper\lib'

* Eine Datei in `%WinstDir%\lib`

Die Prüfung erfolgt in dieser Reihenfolge. Die erste Datei die gefunden wird, wird genommen.

Beispiel: +
Wir haben folgendes Script:
[source,winst]
----
[Actions]
include_append "include-test3.opsiinc"
include_insert "include-test1.opsiinc"
----

Dabei hat die Datei `include-test1.opsiinc` folgenden Inhalt:
[source,winst]
----
DefVar $inctestvar$
set $inctestvar$ = "inctest"
Files_del_tmp_dummy
include_append "include-test2.opsiinc"
Files_copy_inctest

if fileExists("c:\opsi.org\tmp\dummy.txt") 
	comment "passed"
else
	comment "failed"
	set $TestResult$ = "not o.k."
	LogWarning "include test failed"
endif

if fileExists("%scriptpath%\test-files\dummy.txt") 
	comment "passed"
else
	comment "failed"
	set $TestResult$ = "not o.k."
	LogWarning "include test failed"
endif
Files_del_tmp_dummy
----

Dabei hat die Datei `include-test2.opsiinc` folgenden Inhalt:
[source,winst]
----
[Files_copy_inctest]
copy "%scriptpath%\test-files\dummy.txt" "c:\opsi.org\tmp"
----

Dabei hat die Datei `include-test3.opsiinc` folgenden Inhalt:
[source,winst]
----
[Files_del_tmp_dummy]
del -f "c:\opsi.org\tmp\dummyt.txt"
----

[[opsi-winst-commands-include-library]]
==== Include Kommandos: Library

Mit der Version 4.11.3 werden folgende Includefiles in `%WinstDir%\lib` ausgeliefert:

`insert_check_exit_code.opsiinc`:
[source,winst]
----
; opsi include file

DefVar $ExitCode$

include_append "section_sub_check_exitcode.opsiinc"
----

`insert_get_licensekey.opsiinc`:
[source,winst]
----
; opsi include file

DefVar $LicenseRequired$
DefVar $LicenseKey$
DefVar $LicensePool$

include_append "section_sub_get_licensekey.opsiinc"
----

`section_sub_check_exit_code.opsiinc`:
[source,winst]
----
;opsi include file

[Sub_check_exitcode]
comment "Test for installation success via exit code"
set $ExitCode$ = getLastExitCode
; informations to exit codes see
; http://msdn.microsoft.com/en-us/library/aa372835(VS.85).aspx
; http://msdn.microsoft.com/en-us/library/aa368542.aspx
if ($ExitCode$ = "0")
	comment "Looks good: setup program gives exitcode zero"
else
	comment "Setup program gives a exitcode unequal zero: " + $ExitCode$
	if ($ExitCode$ = "1605")
		comment "ERROR_UNKNOWN_PRODUCT	1605	This action is only valid for products that are currently installed."
		comment "Uninstall of a not installed product failed - no problem"
	else
		if ($ExitCode$ = "1641")
			comment "looks good: setup program gives exitcode 1641"
			comment "ERROR_SUCCESS_REBOOT_INITIATED	1641	The installer has initiated a restart. This message is indicative of a success."
		else
			if ($ExitCode$ = "3010")
				comment "looks good: setup program gives exitcode 3010"
				comment "ERROR_SUCCESS_REBOOT_REQUIRED	3010	A restart is required to complete the install. This message is indicative of a success."
			else
				logError "Fatal: Setup program gives an unknown exitcode unequal zero: " + $ExitCode$
				isFatalError
			endif
		endif
	endif
endif
----

`section_sub_get_licensekey.opsiinc`:
[source,winst]
----
; opsi include file

[Sub_get_licensekey]
if opsiLicenseManagementEnabled
	comment "License management is enabled and will be used"

	comment "Trying to get a license key"
	Set $LicenseKey$ = demandLicenseKey ($LicensePool$)
	; If there is an assignment of exactly one licensepool to the product the following call is possible:
	; Set $LicenseKey$ = demandLicenseKey ("", $ProductId$)
	;
	; If there is an assignment of a license pool to a windows software id, it is possible to use:
	; DefVar $WindowsSoftwareId$
	; $WindowsSoftwareId$ = "..."
	; Set $LicenseKey$ = demandLicenseKey ("", "", $WindowsSoftwareId$)
	
	DefVar $ServiceErrorClass$
	set $ServiceErrorClass$ = getLastServiceErrorClass
	comment "Error class: " + $ServiceErrorClass$
	
	if $ServiceErrorClass$ = "None"
		comment "Everything fine, we got the license key '" + $LicenseKey$ + "'"
	else
		if $ServiceErrorClass$ = "LicenseConfigurationError"
			LogError "Fatal: license configuration must be corrected"
			LogError getLastServiceErrorMessage
			isFatalError
		else 
			if $ServiceErrorClass$ = "LicenseMissingError"
				LogError "Fatal: required license is not supplied"
				isFatalError
			endif
		endif
	endif
else
	LogError "Fatal: license required, but license management not enabled"
	isFatalError
endif
----

[[opsi-winst-string-functions-handling]]
=== String-Verarbeitung

* `contains(`<str>, <substr>`)` +
Boolsche Funktion welche 'true' liefert wenn <substr> in <str> enthalten ist. Die Funktion arbeitet case sensitive. +
Seit 4.11.3 +
Beispiel:
[source,winst]
----
set $ConstTest$ = "1xy451Xy451XY45"
set $CompValue$ ="xy"
if contains($ConstTest$, $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $CompValue$ ="xY"
if not(contains($ConstTest$, $CompValue$))
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `stringReplace(`<string>, <oldPattern>, <newPattern>`)` +
Liefert einen String in dem in <string>, <oldPattern> durch <newPattern> ersetzt ist. Die Funktion arbeitet nicht case sensitive. +
Seit 4.11.3 +
Beispiel:
[source,winst]
----
set $ConstTest$ = "123451234512345"
set $CompValue$ = stringReplace("1xy451Xy451XY45","xy","23")
if ($ConstTest$ = $CompValue$)
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `strLength(`<string>`)` +
Liefert Anzahl der Zeichen in <string> +
Seit 4.11.3 +
Beispiel:
[source,winst]
----
set $tmp$ = "123456789"
set $ConstTest$ = "9"
set $CompValue$ = strLength($tmp$)
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `strPos(`<string>, <sub string>`)` +
Liefert die Position des ersten Vorkommens von <sub string> in <string>. Wird <sub string> nicht gefunden so liefert die Funktion "0". Die Funktion arbeitet case sensitive. +
Seit 4.11.3 +
Beispiel:
[source,winst]
----
set $tmp$ = "1xY451Xy451xy45"
set $ConstTest$ = "7"
set $CompValue$ = strPos($tmp$,"Xy")
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $tmp$ = lower("1xY451Xy451xy45")
set $ConstTest$ = "2"
set $CompValue$ = strPos($tmp$,lower("xy"))
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `strPart(`<string>, <start pos>, <number of chars>`)` +
Liefert einen Teilstring von <string> beginnend mit <start pos> und <number of chars> lang. Wenn ab <str pos> weniger als <number of chars> vorhanden sind, so wird der String bis zum Ende geliefert. +
Seit 4.11.3 +
Beispiel:
[source,winst]
----
set $tmp$ = "123456789"
set $ConstTest$ = "34"
set $CompValue$ = strPart($tmp$,"3","2")
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
set $tmp$ = "123456789"
set $ConstTest$ = "56789"
set $CompValue$ = strPart($tmp$, strPos($tmp$,"56"),strLength($tmp$))
if $ConstTest$ = $CompValue$
	comment "passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "failed"
endif
----

* `unquote(`<string>,<quote-string>`)` +
Wenn <string> mit dem Anführungszeichen <quote-string> versehen ist so liefert diese Funktion <string> ohne Anführungszeichen +
Von <quote-string> wird nur das erste Zeichen berücksichtigt, wobei führende Whitespaces ignoriert werden. +
Seit 4.11.2.1 



[[opsi-winst-string-functions-others]]
=== Weitere String-Funktionen

*  `getDiffTimeSec` +
liefert einen String mit dem ganzahligen Wert der vergangenen Sekunden seit dem letzten Aufruf von `marktime`. +
Seit Version 4.11.3.1

* `SidToName(`<well known sid>`)` +
liefert einen String mit dem lokalisierten Namen der mit <well known sid> bezeichneten Gruppe. Zum Beispiel für 'S-1-5-32-544' je nach lokalisierung des Betriebsystems 'Administratoren' oder 'Administrators'.  +
Seit Version 4.11.3.1

* `GetMyIpByTarget(`<target ip addr>`)` +
liefert einen String mit der IP-Adresse des Interfaces, welches das Betriebssystem verwenden wird, wenn es versucht <target ip addr> zu erreichen. Diese Funktion liefert sicherer den korrekten Wert als die Verwendung der Konstante `%IPAddress%`. +
Seit Version 4.11.3.1 +
Beispiel:
[source,winst]
----
set $CompValue$ = getMyIpByTarget("%opsiServer%")
----

* `GetIpByName(`<ip addr / ip name>`)` +
liefert die IP-Nummer des mit <ip addr / ip name> angegebenen Rechners +
Seit Version 4.11.3.2

*  `getLastExitCode` +
Die String-Funktion getLastExitCode gibt den ExitCode des letzten Prozessaufrufs der vorausgehenden WinBatch / DosBatch / ExecWith Sektion aus. +
Bei DosBatch und ExecWith Sektionen erhalten wir den Exitcode des Interpreters.
Daher muss in der Regel der gewünschte Exitcode in der Sektion explizit übergeben werden.

Beispiel:
[source,winst]
----
DosInAnIcon_exit1
		set $ConstTest$ = "1"
		set $CompValue$ = getLastExitCode
		if ($ConstTest$ = $CompValue$)
			comment "DosBatch / DosInAnIcon  exitcode passed"
		else
			set $TestResult$ = "not o.k."
			LogWarning "DosBatch / DosInAnIcon  exitcode failed"
		endif
		
[DosInAnIcon_exit1]
rem create an errolevel= 1
VERIFY OTHER 2> NUL
echo %ERRORLEVEL%
exit %ERRORLEVEL%
----


[[opsi-winst-commands-if-else-bool-functions]]
=== Boolesche Ausdrücke


* `runningAsAdmin` +
Boolsche Funktion welche 'true' liefert wenn das laufende Script mit Administrativen Rechten ausgeführt wird. +
Seit 4.11.1.1

* `isLoginScript` +
Boolsche Funktion welche 'true' liefert wenn das laufende Script über die opsi Erweiterung 'User Profile Management' als 'userLoginScript' läuft. +
Seit 4.11.2.1

* `contains(`<str>, <substr>`)` +
Boolsche Funktion welche 'true' liefert wenn <substr> in <str> enthalten ist. Die Funktion arbeitet case sensitive. +
Seit 4.11.3

* `isNumber(`<str>`)` +
Boolsche Funktion welche 'true' liefert wenn <str> einen ganzahligen Wert (integer) representiert. +
Seit 4.11.3

[[opsi-winst-stringlist-create-by-registry]]
=== String-Listen aus der Registry


* `getRegistryKeyList32(`<regkey>`)` +
Liefert eine Liste mit dem Namen aller Keys direkt unterhalb von <regkey>. +
32 Bit Modus (mit Redirection). Seit 4.11.3

* `getRegistryKeyList64(`<regkey>`)` +
Liefert eine Liste mit dem Namen aller Keys direkt unterhalb von <regkey>. +
64 Bit Modus (ohne Redirection). Seit 4.11.3

* `getRegistryKeyListSysnative(`<regkey>`)` +
Liefert eine Liste mit dem Namen aller Keys direkt unterhalb von <regkey>. +
Modus abhängig von der Architektur des Betriebssystems. Seit 4.11.3

* `getRegistryVarList32(`<regkey>`)` +
Liefert eine Liste mit dem Namen aller Werte direkt unterhalb von <regkey>. +
32 Bit Modus (mit Redirection). Seit 4.11.3

* `getRegistryVarList64(`<regkey>`)` +
Liefert eine Liste mit dem Namen aller Werte direkt unterhalb von <regkey>. +
64 Bit Modus (ohne Redirection). Seit 4.11.3

* `getRegistryVarListSysnative(`<regkey>`)` +
Liefert eine Liste mit dem Namen aller Werte direkt unterhalb von <regkey>. +
Modus abhängig von der Architektur des Betriebssystems. Seit 4.11.3

Beispiel: +
Wir erzeugen Registryeinträge mit folgender Sektion durch den Aufruf von: +
[source,winst]
----
Registry_createkeys /32Bit

[Registry_createkeys]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test]
set "entry1" = "val1"
set "entry2" = "val2"
set "entry3" = "val3"
set "entry4" = "val4"
set "entry5" = "val5"
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\key1]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\key2]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\key3]
openkey [HKEY_LOCAL_MACHINE\SOFTWARE\opsi.org\opsi-winst-test\key4]
----
Dann liefert uns:
[source,winst]
----
set $list$ = getRegistryVarList32("hklm\software\opsi.org\opsi-winst-test")
----
folgenden Log: 
----
Set  $list$ = GetRegistryVarList32("hklm\software\opsi.org\opsi-winst-test")
Registry started with redirection (32 Bit)
    retrieving strings from GetRegistryVarList32 [switch to loglevel 7 for debugging]
        (string   0)entry1
        (string   1)entry2
        (string   2)entry3
        (string   3)entry4
        (string   4)entry5
----

Dann liefert uns:
[source,winst]
----
set $list$ = getRegistryKeyList32("hklm\software\opsi.org\opsi-winst-test")
----
folgenden Log: 
----
Set  $list$ = GetRegistryKeyList32("hklm\software\opsi.org\opsi-winst-test")
Registry started with redirection (32 Bit)
    retrieving strings from GetRegistryKeyList32 [switch to loglevel 7 for debugging]
        (string   1)key1
        (string   2)key2
        (string   3)key3
        (string   4)key4
----

[[opsi-winst-stringlist-create-by-property]]
=== String-Listen aus Produkt Properties

* `getProductPropertyList(`<propname>,<default value>`)` +
Liefert eine Liste mit den aktiven Werten des multivalue Properties <propname>. Im Gegensatz zu der Funktion `GetProductProperty` welche in diesem Fall die einzelnen Werte auf einem komma separierten String zurück liefert. Diese Vorgehen wird problematisch wenn Kommas auch in der Werten vorkommen. +
Seit 4.11.3 +
Beispiel:
[source,winst]
----
;Property "dummymulti" has the values: ("ab", "cd", "ef", "g,h")
set $list$ = GetProductPropertyList ("dummymulti","True")
if not ("" = takeFirstStringContaining($list$,"g,h"))
	comment "GetProductPropertyList passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "GetProductPropertyList failed"
endif

set $ConstTest$ = "ab,cd,ef,g,h"
set $CompValue$ = GetProductProperty ("dummymulti","True")
if ($ConstTest$ = $CompValue$)
	comment "GetProductProperty passed"
else
	set $TestResult$ = "not o.k."
	LogWarning "GetProductProperty failed"
endif
----

[[opsi-winst-stringlist-misc]]
=== Sonstige String-Listen

* `getProfilesDirList` +
Liefert eine Liste der Pfade zu den lokalen Profilen. +
Profile welche die folgenden Worte enthalten werden *nicht* berücksichtigt: +

** 'localservice'

** 'networkservice'

** 'all users'

** 'systemprofile'

** 'public'

Das Profil des 'Default Users' ist Bestandteil der Liste.

Beispiel:
[source,winst]
----
set $list1$ = getProfilesDirList
----
ergibt folgenden Log:
----
Set  $list1$ = getProfilesDirList
Registry started with redirection (32 Bit)
    retrieving strings from getProfilesDirList [switch to loglevel 7 for debugging]
        (string   0)C:\Users\Administrator
        (string   1)C:\Users\Default
----

[[opsi-winst-commands-isfatalerror]]
=== Fehlgeschlagene Installation anzeigen

Passieren bei einer Installation Fehler, die zum Fehlschlagen der Installation führen, so sollte dies an den Server zurückgemeldet werden.

Um in einem '{opsi-winst}' Skript, eine Installation als gescheitert zu erklären, gibt es eine Ausdruck namens  +
`isFatalError` +
unterbricht die normale Ausführung eines Skripts, an der Stelle, an der er aufgerufen wird. Nach dem der Befehl aufgerufen wurde, werden (außer if-Anweisungen) keine Anweisungen mehr ausgeführt und als Skriptergebnis wird 'failed' zurückgeliefert. Wird dieser Befehl nicht aufgerufen, so ist das Skriptergebnis 'success'.

Seit 4.11.3.2 ist auch die folgende Variante erlaubt:

* `isFatalError` <string> +
wobei <string> als kurze Fehlerbeschreibung an den opsi-server als 'actionProgress' weitergegeben wird und im opsi-configed angezeigt wird.

[[opsi-winst-commands-logging]]
=== Kommandos zur Steuerung des Logging

* `includelog` <file name> <tail size>   //since 4.11.2.1 +
Fügt die Datei <file name> in den aktuellen ein. Dabei werden nur die letzten <tail size> Zeilen und nicht die komplette Logdatei eingfügt. Wenn Sie ein anderes Programm (z.B. ein setup programm) starten das eine Logdatei produziert, können Sie mit diesem Begfehl die Informationen aus dieser Logdatei in den Log des '{opsi-winst}' übernehmen. +
Seit Version 4.11.3.2 kann auch eine negative <tail size> angegeben werden. Dann arbeitet `includelog` im 'Head' Modus, d.h. ist <tail size> = -5, so werden die ersten 5 Zeilen von <file name> in den Log übernommen.
Beispiel: 
[source,winst]
----
includelog "%Scriptpath%\test-files\10lines.txt" "5"
----

[[opsi-winst-secsections]]
== Sekundäre Sektionen

[[opsi-winst-patches]]
=== Patches-Sektionen


[[opsi-winst-patches-params]]
==== Aufrufparameter 

Der Name der zu patchenden Datei wird als Parameter übergeben.

Als optionalen Modifier gibt es:

* `/AllNTUserProfiles` +
Wird eine Patches Sektion mit diesem Modifier aufgerufen und der Pfad zur zu patchenden Datei enthält die Konstante `%UserProfileDir%`, so wird diese Patchsektion für alle Profile ausgeführt. +
Eine 'Patches' Sektion welche in einer `[ProfileActions]` Sektion aufgerufen wird hat im 'Machine' Modus den Modifier `/AllNTUserProfiles` implizit. Im Loginscript Modus wird dann `%UserProfileDir%` als `%CurrentProfileDir%` interpretiert. +
(Seit Version 4.11.3.2)

[[opsi-winst-execwith]]
=== ExecWith Sektionen

Seit Version 4.11.3 wird, wenn als Interpreter 'powershell' angegeben ist, die temporäre Datei als `.ps1` gespeichert. 

[[opsi-winst-winbatch]]
=== WinBatch-Sektionen

[[opsi-winst-winbatch-params]]
==== Aufrufparameter (Modifier)

*  `/WaitSeconds` [AnzahlSekunden] +
Die Parametrisierung /WaitSeconds [AnzahlSekunden] modifiziert das Verhalten dahingehend, dass '{opsi-winst}' jeweils erst nach [AnzahlSekunden] die Skriptbearbeitung fortsetzt. Die angegebene Zeit stoppt '{opsi-winst}' auf jeden Fall. In der Default-Einstellung wird zusätzlich auf das Ende der angestoßenen Prozesse gewartet. Ist letzteres nicht gewünscht, so kann der Parameter mit dem Parameter /LetThemGo kombiniert werden.

 
*  `/WaitForProcessEnding` <program name> +
Wartet darauf, das sich der Prozess mit dem Namen <program name> beendet. +
Kann und sollte mit `/TimeOutSeconds` kombiniert werden.

Erläuterung: +
Der '{opsi-winst}' wartet auf das Ende eines per `winbatch` gestarteten Prozesses bevor mit der nächsten Zeile des Scriptes forgefahren wird:

.Sequentielle Abarbeitung des Scriptes mit Warten auf das Ende eines Prozesses
image::../images/waitforprocess_scheme_std.png["waitforprocess_scheme_std",width=150]

Es gibt allerdings Prozesse, welche einen weiteren Prozess starten und sich Beenden ohne auf das Ende des Kindprozesses zu warten. Aus Sich des '{opsi-winst}' ist admit der Weg zur Ausführung des nächsten Befehls frei:

.Ende eines Prozesses mit weiterlaufenden Kindprozess
image::../images/waitforprocess_scheme_fork1.png["waitforprocess_scheme_fork1",width=200]

Werden z.B. hintereinander ein Uninstall und ein Setup Programm aufgerufen und das Uninstall Programm führt die eigentliche Deinstallation in einem Kindprozess aus, so ist das Ergebnis undefiniert, da deinstallation und Installation gleichzeitig laufen:

.Überlappung von Kindprozess und nächstem gestarteten Prozess
image::../images/waitforprocess_scheme_fork2.png["waitforprocess_scheme_fork2",width=200]

Mit dem Modifier `/WaitForProcessEnding` kann eine solche Situation vermieden werden.

*  `/TimeOutSeconds` <seconds> +
Bricht das Warten auf das Processende oder eine Wartebedingung (`/WaitForProcessEnding`) nach Ablauf von <seconds> ab, auch wenn das Prozessende oder die Wartebedingung noch nicht erfüllt ist. +
Der Prozess auf dessen Ende gewartet werden sollte wird nicht gestopt. +
Kann seit Version 4.11.3 auch alleine (z.B. ohne `/WaitForProcessEnding`) verwendet werden, aber nicht zusammen mit `/WaitSeconds`. +
Beispiel: 
+
[source,winst]
----
Winbatch_uninstall /WaitForProcessEnding "uninstall.exe" /TimeOutSeconds 20
[Winbatch_uninstall]
"%ScriptPath%\uninstall_starter.exe"
----

* `/RunElevated` +
Started dem Prozeß mit einem höheren Security Token (d.h. mit höheren Rechten). Dieser Modifier hat folgende Einschränkungen: +
** Unter NT5 hat er keine Auswirkungen
** Ein Zugriff auf das Netz ist in dem Prozess nicht möglich. Daher müssen die aufzurufenden Programme von einem Netzlaufwerk in ein temporäres lokales Verzeichnis kopiert werden.
** Evtl. kann es zu Problemen bei der Nutzung der grafischen Oberfläche kommen. Daher sind echte silent aufrufe hier zu bevorzugen.
** Funktioniert nur im opsi-service Kontext

*  `getLastExitCode` +
Die String-Funktion getLastExitCode gibt den ExitCode des letzten Prozessaufrufs der vorausgehenden WinBatch / DosBatch / ExecWith Sektion aus.


== Sonstiges

* wisynth: TuibInstScript.doInfo: optimal fill for LabelInfo

* name of installing product shown in inital info block. fixes #367

* wisynth: executeWith: use extension '.ps1' if interpreter = powershell, fixes #382

* logfiles now again not locked against reading while opsi-winst is running
                         fixes: https://forum.opsi.org/viewtopic.php?f=7&t=3655
                         
* winbatch: test if extension of exitsting file is exe or com now not case sensitive.
         fixes: https://forum.opsi.org/viewtopic.php?f=7&t=3592#p18127
         
* Winbatch: The parameter to /timeoutseconds may now be a variable fixes #352