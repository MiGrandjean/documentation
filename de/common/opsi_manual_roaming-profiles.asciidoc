////
; Copyright (c) uib gmbh (www.uib.de)
; This documentation is owned by uib
; and published under the german creative commons by-sa license
; see:
; http://creativecommons.org/licenses/by-sa/3.0/de/
; http://creativecommons.org/licenses/by-sa/3.0/de/legalcode
; english:
; http://creativecommons.org/licenses/by-sa/3.0/
; http://creativecommons.org/licenses/by-sa/3.0/legalcode
; 
; credits: http://www.opsi.org/credits/
////

:Author:    uib gmbh
:Email:     info@uib.de
:Date:      05.09.2011
:Revision:  4.0.1
:toclevels: 6


include::../common/opsi_terms.asciidoc[]

[[opsi-manual-roamingprofiles]]
== opsi Erweiterung 'Roaming Profile Support'


[[opsi-manual-roamingprofiles-preconditions]]
=== Vorbedingungen für die opsi Erweiterung 'Roaming Profile Support'

Dieses Modul ist momentan eine
http://www.uib.de/www/kofinanziert/index.html[kofinanzierte opsi Erweiterung]. +
Es sind eine Reihe von Vorbedingungen nötig, um dieses Modul einsetzen
zu können. Das bedeutet, das Sie zum Einsatz eine Freischaltdatei benötigen. Diese Freischaltung erhalten Sie wenn Sie die Erweiterung kaufen. Zu Evaluierungszwecken stellen wir Ihnen auch eine zeitlich befristete Freischaltung kostenlos zur Verfügung ( -> mail an info@uib.de).

Technische Voraussetzungen sind opsi 4.0.1 mit den Paketständen:

.Benötigte Pakete
[options="header"]
|==========================
|opsi-Paket|Version
|opsi-client-agent|>=4.0.1-23
|'{opsi-winst}'|>=4.11.2.1
|python-opsi|>=4.0.1.31-1
|==========================


[[opsi-manual-roamingprofiles-introduction]]
=== Einführung

Der '{opsi-winst}' verfügt über eine Reihe von speziellen Befehlen um Modifikationen in Profilen vorzunehmen. Diese Arbeiten aber auf den lokalen Profilen und sind beim Einsatz von 'Roaming Profiles' weitgehend nutzlos.
Mit der opsi Erweiterung 'Roaming Profile Support' wird nun eine Möglichkeit geschaffen auch hier Veränderungen an den Profilen vorzunehmen.
Dies geschieht in dem beim User login der '{opsi-winst}' gestartet wird um spezielle 'userLoginScripte' auszuführen. 

[[opsi-manual-roamingprofiles-concept]]
=== Konzept

Wenn die Profile nicht bei der Installation der Software gleich mit gepatcht werden können, muss zwischen dem 'Maschinen Teil' und dem 'Profil Teil' der Installation deutlicher unterschieden werden. Die kann sowohl innerhalb eines Scriptes geschehen als auch durch die Auslagerung des 'Profil Teils' in ein eigenes Script. Vielerorts passiert dies auch jetzt schon, in dem die 'Profil Teile' im Rahmen eines Domain Login Scripts ausgeführt werden.

Je nach Praxis liegen daher die 'Profil Teile' von opsi-Produkten als Bestandteil der opsi-scripte zur Installation und Deinstalltion vor, als auch als Bestandteil eines Domain Loginscriptes. Ziel dieser Erweiterung ist es, beide Varianten möglichst einfach in den neuen Mechanismus integrieren zu können.

Die Kernkonzepte dieser opsi Erweiterung sind:

* Ausführen spezieller userLoginScripte beim Login des users +
Im Rahmen des User Logins wird der '{opsi-winst}' gestartet aber in einem speziellem Modus ausgeführt in dem nur bei den Produkten hinterlegte 'userLoginScripte' ausgeführt werden.

* Ausführen der Scripte mit administrativen Rechten aber im Userkontext +
Domain Login Scripte werden vom User mit user Rechten ausgeführt. Die opsi 'userLoginScripte' werden vom '{opsi-winst}' ausgeführt, welcher mit administrativen Rechten läuft. Gleichzeitig begibt sich der '{opsi-winst}' aber in den Kontext des Users der sich eingelogged hat, so dass die Manipulation der Profile mit den selben Befehlen durchgeführt werden kann, wie in einem Domain Loginscript.

*  Ausführen der Scripte innerhalb des opsi-service Kontext +
Die opsi 'userLoginScripts' laufen innerhalb des opsi-service Kontextes und haben so über Scriptkonstanten die Informationen zu Produktnamen, Version und Packageversion die gerade bearbeitet wird. Weiterhin sind die Werte der Produktproperties im Zugriff sowie alle sonstigen Informationen welche eventuell über opsiservicalls abgerufen werden sollen.

Einschränkungen:

* Die 'userLoginScripte' werden auch bei der Verwendung der opsi-WAN-Erweiterung nicht aus dem lokalen Cache geladen, sondern online. 


[[opsi-manual-roamingprofiles-winst]]
=== Neue und erweiterte '{opsi-winst}' Funktionen
 
* Aufrufparameter `/allloginscripts` +
Wird der '{opsi-winst}' im opsi-service Kontext mit dem zusätzlichen Parameter '/allloginscripts' aufgerufen, so hat das im wesentlichen folgende Auswirkungen:

** Es werden die Produkte ermittelt welche ein 'userLoginScript' haben. Nur für diese Produkte werden die 'userLoginScripte' ausgeführt.

** Es wird der user der sich eingelogt hat ermittelt und dafür gesorgt, dass die Konstanten zum aktuellen User wie z.B. +%CurrentAppdataDir%+ auf die entsprechenden Verzeichnisse des eingelogten users zeigen. Ebenso werden Registry Operationen (`Registry` Sektionen und `GetRegistryString`) welche sich auf +HKCU+ beziehen, so ausgeführt, das die Daten aus dem Registryzweig des Users kommen.

* Aufrufparameter `/silent` +
Der Aufrufparameter `/silent` sorgt dafür, das während der Scriptabarbeitung das Fenster des '{opsi-winst}' nicht angezeigt wird.

* Funktion `GetScriptMode` +
Um innerhalb eines Scriptes zu unterscheiden in welchem Modus das Script gerade ausgeführt wird, liefert die Funktion `GetScriptMode` zwei mögliche Werte zurück:
** 'Machine' +
Das Script wird *nicht* als 'userLoginScript' ausgeführt (sondern z.B. als setup oder uninstall Script).
** 'Login' +
Das Script wird als 'userLoginScript' ausgeführt.

* Registry Sektionen +
** Registry Sektionen welche auf 'HKCU' bzw. 'HKEY_CURRENT_USER' arbeiten, werden im Loginscript Mode so ausgeführt, dass die Änderungen im Zweig des eingeloggten users landen. Entsprechendes gilt für die Funktionen `GetRegistryStringValue*`.
** Registry Sektionen welche im Normalen Modus ('Machine') mit dem Modifier '/AllNtUserDats' aufgerufen werden, dürfen jetzt in der `openkey` Anweisung den Root 'HKCU' bzw. 'HKEY_CURRENT_USER' enthalten. Dies ermöglicht es, die selbe Registry Sektion in den unterschiedlichen Modi auszuführen.

* Vermeidung unnötiger Läufe: +
Mit den Befehl `saveVersionToProfile` kann im aktuelle Profil hinterlegt werden, das das userLoginscript zu diesem Produkt in dieser Version gelaufen ist. Mit der Stringfunktion `readVersionFromProfile` bzw. der boolschen Funktion `scriptWasExecutedBefore` kann überprüft werden ob das userLoginScript zu diesem Produkt in dieser Version schon mal zuvor gelaufen ist und eine erneute Ausführung unnötig ist. Dazu liest diese Funktion zunächst einen evtl. vorhandenen Versionsstempel vom Profil ein (wie das mit `readVersionFromProfile` möglich ist) und vergleicht diesen mit der aktuell laufenden Version. Aus dem Vergleich ergibt sich der Rückgabewert (wahr/falsch). Danach werden noch die aktuellen Werte in das Profil zurückgeschrieben (wie das mit `saveVersionToProfile` möglich ist). Somit benötigen Sie nur diese eine Funktion in einer `if` Anweisung, um zu prüfen ob das Script schon mal gelaufen ist.  +
Weiterhin liefert die Stringlistenfunktion `getProductMap` eine Infomap, aus der entnommen werden kann ob das aktuelle Produkt installiert oder deinstalliert usw. ist.

* Logging +
Die Logs von userLoginScripten werden geschrieben nach: +
`c:\opsi.org\log\<login user name>_login.log` +
Diese Logdateien werden auch an den opsi-server übertragen. Dabei wird eine neue Logdatei an eine existierende angehängt. Der opsi-server sorgt dafür, dass diese Dateien in der Größe beschränkt bleiben (max. 5 MB). Auf dem opsi server liegen diese logs unter +/var/log/opsi/userlogin/<clientid>.log+ +
Im opsi Managementinterface (opsi-configed) werden diese Logs in einem zusätzliche Untertab 'userlogin' in dem Tab 'Logdateien' angezeigt.

[[opsi-manual-roamingprofiles-scripts]]
=== Beispiele von userLoginScripten

Zunächst zwei Beispiele die so aufgebaut sind, wie sie auch in Domain Loginscripten eingesetzt werden könnten.

Ein sehr einfaches allgemeines Beispiel:

[source,winst]
----
[Actions]
Message "Example Profile Patch ...."

Files_profile_copy
Registry_currentuser_set

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%CurrentAppdataDir%\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"
----

Ein Beispiel zur Firefoxkonfiguration:

[source,winst]
----
[Actions]
Message "Firefox Profile Patch ...."

DefVar $akt_profile_ini$
DefVar $rel_prefs_path$

comment "check for existing profile ..."
Set $akt_profile_ini$ = "%CurrentAppdataDir%\Mozilla\Firefox\profiles.ini"
if FileExists($akt_profile_ini$)
	Set $rel_prefs_path$ = GetValueFromInifile($akt_profile_ini$,"Profile0","Path","")
	if FileExists("%CurrentAppdataDir%\Mozilla\Firefox\\"+$rel_prefs_path$)
		comment "We found the profile and will now patch it ....."
	endif
else
	comment "no firefox profile found for user"
endif
----

Als nächstes zeigen wir ein Beispiel welches das erste erweitert um die Möglichkeit Dinge aus dem Profil auch wieder zu entfernen. Je nachdem ob das Produkt auf dem Rechner installiert oder deinstalliert wird ein anderer Scriptteil ausgeführt:

[source,winst]
----
[Actions]
Message "Example Profile Patch ...."

if getValue("installationstate", getProductMap) = "installed"
	comment "Product is installed"
	Files_profile_copy
	Registry_currentuser_set
endif

if getValue("lastactionrequest", getProductMap) = "uninstall"
	comment "Product was uninstalled"
	Files_profile_del
	Registry_currentuser_del
endif

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%CurrentAppdataDir%\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"

[Files_profile_del]
del -s -f "%CurrentAppdataDir%\ACME"

[Registry_currentuser_del]
deletekey [HKCU\Software\ACME]
----

Nun ein Beispiel welches das Setup Skript (setup32.ins und delsub32.ins) nutzt um unnötige Verdopplung des Codes zu vermeiden:

setup32.ins:
[source,winst]
----
[Actions]
requiredWinstVersion >= "4.11.2"

DefVar $MsiId$
DefVar $UninstallProgram$
DefVar $ProductId$  
DefVar $InstallDir$

; ----------------------------------------------------------------
; - Please edit the following values                             -
; ----------------------------------------------------------------
Set $ProductId$       = "ACME"
Set $InstallDir$      = "%ProgramFiles32Dir%\ACME"
; ----------------------------------------------------------------
	comment "Show product picture"
	ShowBitmap "%ScriptPath%\\" + $ProductId$ + ".png" $ProductId$

	if FileExists("%ScriptPath%\delsub32.ins")
		comment "Start uninstall sub section"
		Sub "%ScriptPath%\delsub32.ins"
	endif

if GetScriptMode = "Machine"
	Message "Installing " + $ProductId$ + " ..."
	
	comment "Start setup program"
	Winbatch_install
	
	comment "Patch the local Profiles ..."
	Registry_currentuser_set /AllNtUserDats
	Files_profile_copy /AllNtUserProfiles
endif

if GetScriptMode = "Login"
	comment "login part"
	Files_profile_copy
	Registry_currentuser_set
endif


[Winbatch_install]
"%ScriptPath%\setup.exe" /sp- /silent /norestart

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%UserProfileDir%\Appdata\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"
----

delsub32.ins:
[source,winst]
----
Message "Uninstalling " + $ProductId$ + " ..."

if GetScriptMode = "Machine"
	comment "The machine part ..."
	Set $UninstallProgram$ = $InstallDir$ + "\uninstall.exe"
	if FileExists($UninstallProgram$)
		comment "Uninstall program found, starting uninstall"
		Winbatch_uninstall
	endif
	; does also work since 4.11.2.1 
	Registry_currentuser_del /AllNtUserDats
	Files_profile_del /AllNtUserProfiles
endif

if GetScriptMode = "Login" 
	comment "The profile part ..."
	Files_profile_del
	Registry_currentuser_del
endif

[Winbatch_uninstall]
"$UninstallProgram$" /silent /norestart

[Files_profile_del]
del -s -f "%UserProfileDir%\Appdata\ACME"

[Registry_currentuser_del]
deletekey [HKCU\Software\ACME]
----

Nun eine Variante, welche sich im Profil merkt ob das Skript für dieses Produkt in dieser Version und diesen User schon mal ausgeführt wurde.

[source,winst]
----
[Actions]
Message "Example Profile Patch ...."

comment "Did we run this script before ? - and set version stamp in profile"
if not (scriptWasExecutedBefore)
	comment "loginscript was not run yet "	
	Files_profile_copy
	Registry_currentuser_set
endif

[Files_profile_copy]
copy "%Scriptpath%\profiles\*.*" "%CurrentAppdataDir%\ACME"

[Registry_currentuser_set]
openkey [HKCU\Software\ACME]
set "show_greeting_window" = "no"
----




[[opsi-manual-roamingprofiles-configuration]]
=== Konfiguration

Um die Roaming Profiles Erweiterung zu nutzen muss in der Konfiguration des opsiclientd das Loginevent aktiviert werden und dann der '{opsi-winst}' mit dem ergänzenden Parameter '/allloginscripts' gestartet werden. Damit der '{opsi-winst}' erfolgreich in den Kontext des eingelogten users wechseln kann, muss er selbst unter dem 'SYSTEM' Account gestartet werden.

Diese notwendigen Konfigurationen können Sie auf der Kommandozeile wie folgt einrichten:

[source, prompt]
----
opsi-admin -d method config_createBool opsiclientd.event_user_login.active "user_login active" true

opsi-admin -d method config_createUnicode opsiclientd.event_user_login.action_processor_command "user_login action_processor" "%action_processor.command% /sessionid %service_session% /allloginscripts"

opsi-admin -d method config_createUnicode opsiclientd.action_processor.run_as_user "action_processor run_as_user" "SYSTEM"
----

Als weiterer '{opsi-winst}' Parameter kann zusätzlich auch noch der Parameter '/silent' verwendet werden, welcher die Anzeige des '{opsi-winst}' Fensters unterbindet.

[source, prompt]
----
opsi-admin -d method config_createUnicode opsiclientd.event_user_login.action_processor_command "user_login action_processor" "%action_processor.command% /sessionid %service_session% /allloginscripts /silent"
----

Die so eingerichteten Einstellungen können Sie im opsi Managementinterface im Tab 'Hostparameter' Server- oder Client-spezifisch modifizieren.

[[opsi-manual-roamingprofiles-notification]]
=== Notification

Wenn Sie (wie oben beschrieben) das Loginevent aktiviert haben, so sehen Sie nach jedem Login den user_login_nofier:

.User Login Notifier
image::../images/login-action-notifier.png["User Login Notifier", width=100]







